Optimization-based Trajectory Generation with Linear Temporal Logic
Speciﬁcations
Eric M. Wolff, Ufuk Topcu, and Richard M. Murray
Abstract— We present a mathematical programming-based
method for optimal control of discrete-time dynamical systems
subject to temporal logic task speciﬁcations. We use linear
temporal logic (LTL) to specify a wide range of properties and
tasks, such as safety, progress, response, surveillance, repeated
assembly, and environmental monitoring. Our method directly
encodes an LTL formula as mixed-integer linear constraints on
the continuous system variables, avoiding the computationally
expensive processes of creating a ﬁnite abstraction of the system
and a B¨ uchi automaton for the speciﬁcation. In numerical
experiments, we solve temporal logic motion planning tasks for
high-dimensional (10+ continuous state) dynamical systems.
I. INTRODUCTION
We are motivated by safety-critical robotics applications
involving autonomous air, ground, and space vehicles car-
rying out complex tasks. In this context, it is important to
concisely and unambiguously specify the desired system be-
havior. Given such as task speciﬁcation, it is desirable to au-
tomatically synthesize a controller that provably implements
this behavior. Controller synthesis is complicated by the
fact that autonomous systems often have high-dimensional,
nonlinear dynamics and require efﬁcient (not just feasible)
controllers.
Linear temporal logic (LTL) is an expressive task-
speciﬁcation language for specifying a variety of tasks such
as responding to a dynamic environment, visiting goals, peri-
odically monitoring areas, staying safe, and remaining stable.
These properties generalize classical point-to-point motion
planning. LTL is also promising as a common language for
reasoning about the software and dynamics of autonomous
systems, due to the widespread use of LTL in software
veriﬁcation [4].
Standard methods for motion planning with LTL task
speciﬁcations ﬁrst create a ﬁnite abstraction of the original
dynamical system (see [2], [5], [15], [23]). This abstraction
can informally be viewed as a labeled graph that represents
possible behaviors of the system. Given a ﬁnite abstraction
of a dynamical system and an LTL speciﬁcation, controllers
can be automatically constructed using an automata-based
approach [4], [8], [11], [15]. The main drawbacks of this
approach are: 1) it is expensive to compute a ﬁnite abstrac-
tion, and 2) the size of the automaton may be exponential in
the length of the speciﬁcation.
Eric M. Wolff and Richard M. Murray are with the Department of Control
and Dynamical Systems, California Institute of Technology, Pasadena, CA.
Ufuk Topcu is with the Department of Electrical and Systems Engineering,
University of Pennsylvania, Philadelphia, PA. The corresponding author is
ewolff@caltech.edu
Instead of the automata-based approach, we directly en-
code an LTL formula as mixed-integer linear constraints on
the original dynamical system. We enforce that an inﬁnite
sequence of system states satisﬁes the speciﬁcation by using
a ﬁnite number of constraints on a trajectory parameterization
of bounded length. This is possible by enforcing that the
system’s trajectory is eventually periodic, i.e., it contains a
loop. The loop assumption is motivated by the use of “lassos”
in LTL model checking of ﬁnite, discrete systems [4]. This
direct encoding of the LTL formula avoids the potentially
expensive computations of a ﬁnite abstraction of the system
and a B¨ uchi automaton for the speciﬁcation.
Our approach applies to any deterministic system model
that is amenable to ﬁnite-dimensional optimization, as the
temporal logic constraints are independent of any particular
system dynamics or cost functions. Of particular interest are
mixed logical dynamical (MLD) systems [6] and certain
differentially ﬂat systems [17], whose dynamics can be
encoded with mixed-integer linear constraints. MLD systems
include constrained linear systems, linear hybrid automata,
and piecewise afﬁne systems. Differentially ﬂat systems
include quadrotors [19] and car-like robots.
Our work extends the bounded model checking paradigm
for ﬁnite, discrete systems [9] to continuous dynamical
systems. In bounded model checking, one searches for coun-
terexamples (i.e., trajectories) of a ﬁxed length by transform-
ing the problem into a Boolean satisﬁability (SAT) problem.
This approach was extended to hybrid systems in [13] by
ﬁrst computing a ﬁnite abstraction of the system, and then
using a SAT solver for the resulting discrete problem. Hybrid
systems are also considered in [3], [12], where SAT solvers
are extended to reason about linear inequalities. In contrast,
we consider a larger class of dynamics and use mixed-integer
linear programming techniques.
Mixed-integer linear programming has been used for tra-
jectory generation for continuous systems with ﬁnite-horizon
LTL speciﬁcations in [14] and [16]. However, ﬁnite-horizon
properties are too restrictive to model a large class of in-
teresting robotics problems, including surveillance, repeated
assembly, periodic motion, and environmental monitoring.
A fragment of LTL that includes certain periodic properties
is encoded with mixed-integer linear constraints in [22]. We
generalize these results by encoding all LTL properties using
mixed-integer linear constraints.
Our main contributions are a novel method for encod-
ing LTL speciﬁcations as mixed-integer linear constraints
on a dynamical system. This generalizes previous Boolean
satisﬁability encodings of LTL formulas for ﬁnite, discrete
2014 IEEE International Conference on Robotics & Automation (ICRA)
Hong Kong Convention and Exhibition Center
May 31 - June 7, 2014. Hong Kong, China
978-1-4799-3684-7/14/$31.00 ©2014 IEEE 5319
systems. Our mixed-integer encoding works for any LTL
formula, as opposed to previous approaches that only con-
sider ﬁnite-horizon properties or fragments. Our encoding
is also efﬁcient; it requires a number of variables linear
in the length of the trajectory, instead of quadratic as in
previous approaches [14]. We demonstrate how our mixed-
integer programming formulation can be used with off-the-
shelf optimization solvers (e.g. CPLEX [1]) to compute both
feasible and optimal controllers for high-dimensional (10+
continuous state) systems with temporal logic speciﬁcations.
II. PRELIMINARIES
An atomic proposition is a statement that is eitherTrue or
False. A propositional formula is composed of only atomic
propositions and propositional connectives, i.e., ? (and), ?
(or), and ¬ (not).
A. System model
We consider discrete-time nonlinear systems of the form
x
t+1
=f(x
t
;u
t
); (1)
where t = 0;1;::: are the time indices, x ? X ? (R
nc
?
{0;1}
n
l
) are the continuous and binary states, u ? U ?
(R
mc
? {0;1}
m
l
) are the control inputs, and x
0
?X is the
initial state.
LetAP be a ﬁnite set of atomic propositions. The labeling
functionL?X?2
AP
maps the continuous part of each state
to the set of atomic propositions that are True. The set of
states where atomic proposition p holds is denoted by [[p]].
A run (trajectory) x = x
0
x
1
x
2
::: of system (1) is an
inﬁnite sequence of its states, where x
t
?X is the state of
the system at index t and for each t = 0;1;:::, there exists
a control input u
t
?U such that x
t+1
=f(x
t
;u
t
). A word is
an inﬁnite sequence of labels L(x)=L(x
0
)L(x
1
)L(x
2
):::
where x=x
0
x
1
x
2
::: is a run. Given an initial state x
0
and
a control input sequence u, the resulting run x = x(x
0
;u)
is unique.
B. Linear temporal logic
We use linear temporal logic (LTL) to concisely and
unambiguously specify the desired system behavior [4].
LTL allows the speciﬁcation of safety, guarantee, liveness,
response, and stability properties which generalize traditional
point-to-point motion planning [17].
Syntax: LTL is built from (a) a set of atomic propositions
AP , (b) Boolean operators: ¬ (not), ? (and), and ? (or),
and (c) temporal operators: # (next), U (until), and R
(release). An LTL formula in positive normal form (negation
normal form) is deﬁned by the following grammar:
'??=p S¬p S'
1
?'
2
S'
1
?'
2
S#' S'
1
U '
2
S'
1
R'
2
;
where p?AP is an atomic proposition.
Every LTL formula can be rewritten in positive normal
form, where all negations only appear in front of atomic
propositions [4]. The following rules transform a given LTL
formula into an equivalent LTL formula in positive normal
form:¬True =False,¬¬'=',¬('
1
?'
2
)=¬'
1
?¬'
2
,¬#
'=#¬', and ¬('
1
U '
2
)=¬'
1
R¬'
2
. An LTL formula
' of size S'S can always be rewritten as a formula '
?
in
positive normal form of size S'
?
S=O(S'S) [4].
The standard Boolean operators Ô? (implies) and ??
(equivalent) can be deﬁned as p Ô? q = ¬p ?q and
p ?? q = (p Ô? q)? (q Ô? p), respectively.
Commonly used abbreviations for LTL formulas are the
derived temporal operators n = True U (eventually),
? =¬n¬ (always),?n (always eventually), andn? 
(eventually always).
Semantics: The semantics of an LTL formula is deﬁned
over an inﬁnite sequence of states x = x
0
x
1
x
2
:::. Let
x
i
= x
i
x
i+1
x
i+2
::: denote the run x from position i. The
semantics are deﬁned inductively as follows:
x
i
?p if and only if (iff) p?L(x
i
)
x
i
?¬p iff x
i
~ ?p
x
i
? 
1
? 
2
iff x
i
? 
1
?x
i
? 
2
x
i
? 
1
? 
2
iff x
i
? 
1
?x
i
? 
2
x
i
?# iff x
i+1
? 
x
i
? 
1
U 
2
iff ?j ≥i s.t. x
j
? 
2
and x
n
? 
1
?i≤n<j
x
i
? 
1
R 
2
iff ?j ≥i?x
j
? 
2
or x
n
? 
1
?i≤n<j:
Informally, the notation #' means that ' is true at the
next step, ?' means that ' is always true, n' means that
' is eventually true, ?n' means that ' is true inﬁnitely
often, and n?' means that' is eventually always true [4].
Deﬁnition 1. A run x =x
0
x
1
x
2
::: satisﬁes ', denoted by
x?', if x
0
?'.
III. PROBLEM STATEMENT
In this section, we formally state both a feasibility and an
optimization problem and give an overview of our solution
approach. Let ' be an LTL formula deﬁned over AP .
Problem 1. Given a system of the form (1) and an LTL
formula ', compute a control input sequence u such that
x(x
0
;u)?'.
To distinguish among all trajectories that satisfy Prob-
lem 1, we introduce a generic cost function J(x;u) that
maps trajectories and control inputs toR?∞.
Problem 2. Given a system of the form (1) and an LTL
formula ', compute a control input sequence u such that
x(x
0
;u)?' and J(x(x
0
;u);u) is minimized.
We now brieﬂy overview our solution approach. We rep-
resent the system trajectory as a ﬁnite sequence of states.
Inﬁnite executions of the system are captured by enforcing
that a loop occurs in this sequence, making the trajectory
eventually periodic. We then encode an LTL formula as
mixed-integer linear constraints on this ﬁnite trajectory pa-
rameterization in Section IV-B. Additionally, both dynamic
constraints (see Section IV-B.3) and a cost function can
also be included as part of the mixed-integer optimization
problem. For mixed logical dynamical (or piecewise afﬁne)
and certain differentially ﬂat systems, Problems 1 and 2 (with
5320
linear costs) can thus be solved using a mixed-integer linear
program (MILP) solver. While even checking feasibility of
a MILP is NP-hard, modern solvers using branch and bound
methods routinely solve large problems [1]. We give results
on systems with more than 10 continuous states in Section V.
Remark 1. We only consider open-loop trajectory gener-
ation, which is already a challenging problem due to the
LTL speciﬁcations and continuous dynamics. Incorporating
disturbances during trajectory generation is the subject of
future work.
IV. SOLUTION
We build on the work in bounded model checking of
ﬁnite, discrete systems [9], and extend it to dynamical
systems using mixed-integer programming. Our presentation
and notation follows that of [10].
We will search for a trajectory of lengthk that satisﬁes'.
Although a satisfying trajectory for an LTL formula describes
an inﬁnite sequence of states, an inﬁnite sequence can be
captured by a ﬁnite trajectory that has a loop. Note that this
approach is conservative for systems of the form (1) due
to both the bounded trajectory length k and the assumption
that the trajectory is eventually periodic. This is in contrast
to ﬁnite systems, where the assumption that the trajectory is
eventually periodic is without loss of generality.
Deﬁnition 2. A run x is a (k;l)-loop if x =
(x
0
x
1
:::x
l?1
)(x
l
:::x
k
)
!
such that0<l≤k andx
l?1
=x
k
,
where ! denotes inﬁnite repetition.
Deﬁnition 3. Given a run x and a bound k ?N, x?
k
' iff
x is a (k;l)-loop for some 0<l≤k and x
0
?'.
For a bounded trajectory length k, Problems 1 and 2,
with x? ' replaced by x?
k
', can be represented as a
ﬁnite-dimensional mixed-integer program. We will build a
set [[M;';k]] of mixed-integer constraints that is satisﬁable
if and only if a trajectory of length k exists for system M
that satisﬁes '. The satisﬁability of these constraints can
then be checked with a mixed-integer programming solver.
In the following sections, we will describe the construction
of the loop constraints, the LTL constraints, and the system
constraints. However, we ﬁrst detail how to relate the con-
tinuous state to the set of valid atomic propositions.
Remark 2. Our results can be extended to the bounded
semantics for LTL, i.e., the no-loop case, as detailed in [10].
A. Representing the labels
We now relate the state of a system to the set of atomic
propositions that are True at each time instance. We as-
sume that each propositional formula is described by the
Boolean combination of a ﬁnite number of halfspaces. Our
approach here is standard, see e.g., [6], [14].
1) Halfspace representation: We will give a necessary
and sufﬁcient condition on a state x
t
being in a halfspace
H = {x ?X Sh
T
x ≤k} at time t. This can be extended to
unions of polyhedra using conjunctions and disjunction as
detailed in Section IV-A.2.
We introduce binary variables z
t
? {0;1} for time indices
t=0;:::;k. We enforce that z
t
=1 if and only if h
T
x
t
≤k
with the following constraints
h
T
x
t
≤k+M
t
(1?z
t
);
h
T
x
t
>k?M
t
z
t
+;
whereM
t
are large positive numbers and is a small positive
number. Note that z
t
= 1 if and only if the state is in the
halfspace H at time t (with precision  on the boundary).
2) Boolean operations: In this section, we encode¬ (not),
? (and), and ? (or) of propositions using mixed-integer
linear constraints. We assume that each proposition p has
a corresponding variable (binary or continuous) P
p
t
which
equals 1 if p is True at time t, and equals 0 otherwise. We
will use new continuous variables P
 
t
? [0;1] to represent
the resulting propositions. In each case, P
 
t
= 1 if holds
at time t and P
 
t
=0 otherwise.
The negation of propositionp, i.e., =¬p, is modeled for
t=0;:::;k as
P
 
t
=1?P
p
t
:
The conjunction of propositions p
i
for i = 1;:::;m, i.e.,
 =?
m
i=1
p
i
, is modeled for t=0;:::;k as
P
 
t
≤P
pi
t
; i=1;:::;m;
P
 
t
≥1?m+
m
Q
i=1
P
pi
t
The disjunction of propositions p
i
for i = 1;:::;m, i.e.,
 =?
m
i=1
p
i
, is modeled for t=0;:::;k as
P
 
t
≥P
pi
t
; i=1;:::;m;
P
 
t
≤
m
Q
i=1
P
pi
t
:
B. A mixed-integer encoding
We now encode Problem 1 as a set [[M;';k]] of mixed-
integer constraints, which includes loop constraints, LTL
constraints, and system constraints. Note that while the
loop and LTL constraints are always mixed-integer linear
constraints, the system constraints will depend on the dy-
namic model used. Problem 2 uses the same constraint set
[[M;';k]], with the addition of a cost function deﬁned over
the (k;l)-loop.
1) Loop constraints: The loop constraints are used to
determine where a loop is formed in the system trajectory.
We introduce k binary variables l
1
;:::;l
k
which determine
where the trajectory loops. These are constrained so that only
one loop selector variable is allowed to be True, and if l
j
is True, then x
j?1
=x
k
. These constraints are enforced by
∑
k
i=1
l
i
=1 and
x
k
≤x
j?1
+M
j
(1?l
j
); j =1;:::;k;
x
k
≥x
j?1
?M
j
(1?l
j
); j =1;:::;k;
where M
j
are sufﬁciently large positive numbers.
5321
2) LTL constraints: Given a formula ', we denote the
satisfaction of ' at position i by [[']]
i
. The variable
[[']]
i
? {0;1} corresponds to an appropriate set of mixed-
integer linear constraints so that [[']]
i
= 1 if and only if
' holds at position i. We recursively generate the mixed-
integer linear constraints corresponding to [[']]
0
to deter-
mine whether or not a formula ' holds in the initial state,
i.e., if [[']]
0
= 1. In this section, we use the encoding of
the U and R temporal operators from [10] for Boolean
satisﬁability. Our contribution here is linking this satisﬁa-
bility encoding to the continuous system state through the
mixed-integer linear constraints described in Section IV-A.
This encoding ﬁrst computes an under-approximation for
U and an over-approximation for R with the auxiliary
encoding ?????. The under-approximation of'
1
U '
2
assumes
that '
2
does not hold in the successor of state x
k
. The
over-approximation of'
1
R'
2
assumes that'
2
holds in the
successor of statex
k
. These approximations are then reﬁned
to exact values by [[?]]. The encoding is recursively deﬁned
over an LTL formula, where there is a case for each logical
and temporal connective.
The reader might wonder why an auxiliary encoding is
necessary. A seemingly straightforward approach for U
is to use the textbook identity (see [4]) [[ 
1
U 
2
]]
i
=
[[ 
2
]]
i
? ([[ 
1
]]
i
? [[ 
1
U 
2
]]
i+1
) for i = 0;:::;k, where
index k + 1 is replaced by an appropriate index to form
a loop. However, this approach can lead to circular rea-
soning. Consider a trajectory consisting of a single state
with a self loop, and the LTL formula True U , i.e., n 
(eventually). The corresponding encoding is [[True U ]]
0
=
[[ ]]
0
? [[True U ]]
0
. This can be trivially satisﬁed by
setting [[True U ]]
0
equal to 1, regardless of whether or
not is visited. The auxiliary encoding prevents this circular
reasoning, as detailed in [10].
We ﬁrst deﬁne the encoding of propositional formulas as
[[ ]]
i
=P
 
i
;
[[¬ ]]
i
=P
¬ 
i
;
[[ 
1
? 
2
]]
i
= [[ 
1
]]
i
?[[ 
2
]]
i
;
[[ 
1
? 
2
]]
i
= [[ 
1
]]
i
?[[ 
2
]]
i
;
for i = 0;:::;k, where these operations were deﬁned in
Section IV-A using mixed-integer linear constraints.
Next, we deﬁne the auxiliary encodings of U and R .
The until (release) formulas at k use the auxiliary encoding
?? 
1
U 
2
??
j
(?? 
1
R 
2
??
j
) at the index j where the loop
is formed, i.e., wherel
j
holds. The auxiliary encoding of the
temporal operators is
?? 
1
U 
2
??
i
= [[ 
2
]]
i
?([[ 
1
]]
i
??? 
1
U 
2
??
i+1
);
?? 
1
R 
2
??
i
= [[ 
2
]]
i
?([[ 
1
]]
i
??? 
1
R 
2
??
i+1
);
for i=1;:::;k?1, and is
?? 
1
U 
2
??
i
= [[ 
2
]]
i
;
?? 
1
R 
2
??
i
= [[ 
2
]]
i
;
for i=k.
Finally, we deﬁne the encoding of the temporal operators
as
[[# ]]
i
= [[ ]]
i+1
;
[[ 
1
U 
2
]]
i
= [[ 
2
]]
i
?([[ 
1
]]
i
?[[ 
1
U 
2
]]
i+1
);
[[ 
1
R 
2
]]
i
= [[ 
2
]]
i
?([[ 
1
]]
i
?[[ 
1
R 
2
]]
i+1
);
for i=0;:::;k?1, and as
[[# ]]
i
=
k

j=1
(l
j
?[[ ]]
j
);
[[ 
1
U 
2
]]
i
= [[ 
2
]]
i
?([[ 
1
]]
i
?(
k

j=1
(l
j
??? 
1
U 
2
??
j
)));
[[ 
1
R 
2
]]
i
= [[ 
2
]]
i
?([[ 
1
]]
i
?(
k

j=1
(l
j
??? 
1
R 
2
??
j
)));
for i=k.
We also explicitly give the encodings for safety, per-
sistence, and liveness formulas. These formulas frequently
appear in speciﬁcations and can be encoded more efﬁciently
than the general approach just described.
A safety formula ? can be encoded as
[[? ]]
i
= [[ ]]
i
?[[? ]]
i+1
; i=0;:::;k?1
[[? ]]
k
= [[ ]]
k
:
An auxiliary encoding is not necessary here, as noted in [10].
Due to the loop structure of the trajectory, both persistence
and liveness properties either hold at all indices or no indices.
We encode a persistence n? and liveness ?n formulas
as
[[n? ]]=
k

i=1
Œl
i
?
k

j=i
[[ ]]
j
‘;
[[?n ]]=
k

i=1
Œl
i
?
k

j=i
[[ ]]
j
‘;
for i=0;:::;k. Although the encodings for persistence and
liveness appear to require a number of variables that are
quadratic ink, one can share subformulas to make this linear
in k [9].
3) System constraints: The system constraints encode
valid trajectories of length k for a system of the form (1),
i.e., they hold if and only if trajectory x(x
0
;u) satisﬁes the
constraints in equation (1) for t=0;1;:::;k.
System constraints, e.g., the dynamics in equation (1), can
be encoded on the sequence of states using standard tran-
scription methods [7]. However, the resulting optimization
problem may then be a mixed-integer nonlinear program due
to the dynamics.
A useful class of nonlinear systems where the dynamics
can be encoded using mixed-integer linear constraints are
mixed logical dynamical (MLD) systems. MLD systems
can model nonlinearities, logic, and constraints [6]. These
include constrained linear systems, linear hybrid automata,
and piecewise afﬁne systems.
Additionally, differentially ﬂat systems can sometimes be
encoded using mixed-integer linear constraints, e.g., if the
5322
labels over the ﬂat output can be represented as a ﬁnite
union of polyhedra. However, input constraints are typically
non-convex the output space, and thus hard to enforce.
Input constraints can often be satisﬁed by planning smooth
trajectories or changing the time-scaling [20]. Many vehicles
are differentially ﬂat, including quadrotors and simple car-
like robots [17].
The intersection of the LTL constraints, the system con-
straints, and the loop constraints gives the full mixed-integer
linear encoding of the bounded model checking problem, i.e.,
[[M;';k]]. Problem 1 is solved by checking the feasibility
of this set using a MILP solver (assuming the dynamics are
mixed logical dynamical). Similarly, Problem 2 is solved by
optimizing over this set using a MILP solver (assuming the
cost function is linear). More general dynamics and cost
functions can be included by using an appropriate mixed-
integer solver, potentially at the expense of completeness.
C. Complexity
The main source of complexity of our approach comes
from the number of binary variables needed to relate the
satisfaction of an atomic proposition to the continuous state
of the system. A binary variable is introduced at each
time index for each halfspace. If n
h
halfspaces are used to
represent the atomic propositions used in the LTL formula
at each time index, then O(k ? n
h
) binary variables are
introduced, where k is the number of time indices.
Continuous variables are used to represent the propositions
introduced during the encoding of the LTL formula. The
number of continuous variables used is O(k ? S'S), where
k is the number of time indices and S'S is the length of
the formula. This linear dependence on k improves on the
the quadratic dependence onk in [14]. Finally, although the
loop constraints introducek additional binary variables, they
are constrained such that only one is active. In summary,
our mixed-integer linear encoding of an LTL formula '
requires the use of O(k?n
h
) binary variables and O(k?S'S)
continuous variables. Note that the complexity of solving a
mixed-integer linear program is worst-case exponential in the
number of binary variables [1].
We do not give bounds on the number of constraints, as
they depend heavily on the details of a given speciﬁcation,
and are not the major factor in the complexity of solving a
mixed-integer linear program.
Remark 3. Our solution approaches for Problems 1 and 2
are only complete with respect to a given bound of k. If a
solution is not found for a given value of k, there may exist
a solution for a larger value. Future work will identify cases
when an upper bound onk can be computed a priori, similar
to the notion of a completeness threshold [10].
V. EXAMPLES
We consider two LTL motion planning problems for
different system models. We demonstrate our techniques on
a chain of integrators model, a quadrotor model from [21],
and a nonlinear car-like vehicle with drift. All computations
are done on a laptop with a 2.4 GHz dual-core processor and
Fig. 1. Illustration of the environment for the reach-avoid scenario. The
goal is labeledG and dark regions are obstacles. The light regions around the
obstacles give a safety margin so that the continuous evolution of the system
does not intersect an obstacle, which would otherwise be possible since
constraints are enforced at discrete time steps. A representative trajectory for
the “chain-6” model is shown, where we additionally minimized an additive
cost function with cost c(xt;ut)=SutS accrued at each time index.
4 GB of memory using CPLEX [1] through Yalmip [18]. All
continuous-time models are discretized with a 0:35 second
sample time.
Our ﬁrst example is a simple reach-avoid motion planning
scenario (see Figure 1), which we use to directly compare our
encoding of the until operator (U ) with that given in [14].
The task here is to remain in the safe region S until the
goal region G is reached. The corresponding LTL formula
is'=SU G. This formula is a key component for building
more complex LTL formulas, and thus performance of this
encoding is important. We show that our formulation scales
better with respect to the trajectory length k. This is antici-
pated, as our encoding of U requires a number of variables
linear in k, while the encoding in [14] requires a number
of variables quadratic in k. For this example, all results are
averaged over ten randomly generated environments where
75 percent of the area is safe (labeledS), i.e., the remaining
regions are obstacles.
The second example is motivated by a surveillance mis-
sion. Let A, B, C, and D describe regions of interest in a
planar planning space that must be repeatedly visited (see
Figure 2). The robot must remain in the safe region S (in
white) and either visit regions A and B repeatedly or visit
regionsC andD repeatedly. Formally, the task speciﬁcation
is ' = ?S ? ((?nA??nB)?(?nC??nD)). This
formula is recursively parsed according to the grammar in
Section II-B and encoded as mixed-integer linear constraints
as described in Section IV-B. For this example, all results
are averaged over ﬁve randomly generated environments
where 85 percent of the area is safe, i.e., the remaining
regions are obstacles. The length of the trajectory is k =25,
corresponding to 8:75 seconds.
5323
Fig. 2. Illustration of the environment for the surveillance scenario.
The goals are labeled A, B, C, and D. Dark regions are obstacles.
A representative trajectory for the quadrotor model is shown, where we
additionally minimized an additive cost function with cost c(xt;ut)=SutS
accrued at each time index. The system starts in region D and repeatedly
visits regions A and C.
A. Chain of integrators
The ﬁrst system is a chain of orthogonal integrators in
the x and y directions. The k-th derivative of the x and
y positions are controlled, i.e., x
(k)
= u
x
and y
(k)
= u
y
.
The control input constraints are Su
x
S ≤ 0:5 and Su
y
S ≤ 0:5.
The state constraints are Sx
(i)
S ≤ 1 and Sy
(i)
S ≤ 1 for i =
1;:::;k?1. Results are given in Figure 4 under “chain-2,”
“chain-6,” and “chain-10,” where “chain-k” indicates that the
k-th derivative in both the x and y positions are controlled.
B. Quadrotor
We now consider the quadrotor model used in [21],
to which we refer the reader for details. The state x =
(p;v;r;w) is 10-dimensional, consisting of position p?R
3
,
velocity v ? R
3
, orientation r ? R
2
, and angular velocity
w ?R
2
. This model is the linearization of a nonlinear model
about hover, and with the yaw constrained to be zero. The
control input u ? R
3
is the total, roll, and pitch thrust. A
sample trajectory is shown in Figure 2, and results are given
in Figure 4 under “quadrotor.”
C. Nonlinear car
Finally, we consider a nonlinear car-like vehicle with state
x= (p
x
;p
y
;) and dynamics _ x= (vcos();vsin();u). The
variables p
x
;p
y
are position (m) and  is orientation (rad).
The vehicle’s speedv is ﬁxed at 1 (m/s) and its control input
is constrained as SuS≤2:5.
We form a hybrid mixed logical dynamical model by
linearizing the system about different orientations
^

i
for
i = 1;:::;k. The dynamics are governed by the closest
linearization to the current . Results with k = 4 are given
in Figure 4 under “car-4.”
20 30 40
0
5
10
15
20
25
30
35
40
k
Solver time (sec)
 
 
chain?2 ? our method
chain?6 ? our method
chain?2 ? method in [14]
chain?6 ? method in [14]
Fig. 3. Solver time (mean ± standard error) to compute a feasible control
input for the reach-avoid example with our approach and the approach
in [14].
D. Discussion
The results for the ﬁrst example are presented in Figure 3,
where we used the “chain-2” and “chain-6” models. Our en-
coding of the key U temporal operator scaled signiﬁcantly
better than a previous approach, likely due to the fact that
our encoding is linear in the trajectory length k, while the
previous encoding was quadratic in k.
The results for the surveillance example are presented in
Figure 4. Due to the periodic nature of these tasks, the
approaches presented in [14] and [16] are not applicable.
We were able to quickly compute trajectories that satisﬁed
periodic temporal tasks for systems with more than 10
continuous states. The total time was dominated by prepro-
cessing in Yalmip, and we expect that this can be reduced
close to the solver time with a dedicated implementation.
Finally, we compared our mixed-integer linear program-
ming approach to a reachability-based algorithm that com-
putes a ﬁnite abstraction of a continuous system [24]. This
method took 22 seconds to compute a discrete abstraction
for a simple kinematic system (i.e., “chain-1”). In contrast,
our mixed-integer approach ﬁnds solutions to LTL motion
planning problems for these systems in a few seconds.
Abstraction-based approaches scale poorly as the dimension
increases, and cannot currently solve problems with more
than a handful of dimensions. Our approach is also promising
for situations where the environment is dynamically chang-
ing and it would be prohibitively expensive to repeatedly
compute a ﬁnite abstraction.
VI. CONCLUSIONS
We presented a mixed-integer programming-based method
for optimal control of nonlinear systems subject to linear
temporal logic task speciﬁcations. We directly encoded an
LTL formula as mixed-integer linear constraints on contin-
uous system variables, which avoiding the computationally
5324
1 2
0
5
10
15
20
25
30
35
40
45
50
Computation time (sec)
 
 
chain?2
chain?6
chain?10
quadrotor
car?4
Fig. 4. Solver (1) and total (2) time (mean± standard error) to compute a
feasible control input for various systems for the surveillance example. Each
example used an average of 570 binary variables and 4;800 constraints.
expensive processes of creating a ﬁnite abstraction of the
system and creating a B¨ uchi automaton for the speciﬁcation.
We solved LTL motion planning tasks for dynamical systems
with more than 10 continuous states, and showed that our
encoding of the until operator theoretically and empirically
improves on previous work.
Directions for future work include directly encoding met-
ric and past operators, exploiting incremental computation
for varying bounds k, and performing a more detailed
comparison of mixed-integer linear programming solvers
and Boolean satisﬁability solvers that have been extended
to support linear operations, e.g., [12]. Reasoning about
Boolean operations may be substantially improved using
modern SMT solvers.
ACKNOWLEDGEMENTS
The authors would like to thank the anonymous reviewers
for their helpful feedback. This work was supported by an
NDSEG fellowship, the Boeing Corporation, AFOSR award
FA9550-12-1-0302, and ONR award N00014-13-1-0778.
REFERENCES
[1] User’s Manual for CPLEX V12.2. IBM, 2010.
[2] R. Alur, T. A. Henzinger, G. Lafferriere, and G. J. Pappas. Discrete
abstractions of hybrid systems. Proc. IEEE, 88(7):971–984, 2000.
[3] G. Audemard, M. Bozzano, A. Cimatti, and R. Sebastiani. Verifying
industrial hybrid systems with MathSAT. Electronic Notes in Theo-
retical Computer Science, 119:17–32, 2005.
[4] C. Baier and J.-P. Katoen. Principles of Model Checking. MIT Press,
2008.
[5] C. Belta and L. C. G. J. M. Habets. Controlling of a class of nonlinear
systems on rectangles. IEEE Trans. on Automatic Control, 51:1749–
1759, 2006.
[6] A. Bemporad and M. Morari. Control of systems integrating logic,
dynamics, and constraints. Automatica, 35:407–427, 1999.
[7] J. T. Betts. Practical Methods for Optimal Control and Estimation
Using Nonlinear Programming, 2nd edition. SIAM, 2000.
[8] A. Bhatia, M. R. Maly, L. E. Kavraki, and M. Y . Vardi. Motion plan-
ning with complex goals. IEEE Robotics and Automation Magazine,
18:55–64, 2011.
[9] A. Biere, A. Cimatti, E. Clarke, and Y . Zhu. Symbolic model checking
without BDDs. In Proc. of TACAS, 1999.
[10] A. Biere, K. Heljanko, T. Junttila, T. Latvala, and V . Schuppan. Linear
encodings of bounded LTL model checking. Logical Methods in
Computer Science, 2:1–64, 2006.
[11] G. E. Fainekos, A. Girard, H. Kress-Gazit, and G. J. Pappas. Temporal
logic motion planning for dynamic robots. Automatica, 45:343–352,
2009.
[12] M. Fr¨ anzle and C. Herde. Efﬁcient proof engines for bounded model
checking of hybrid systems. Electronic Notes in Theoretical Computer
Science, 133:119–137, 2005.
[13] N. Giorgetti, G. J. Pappas, and A. Bemporad. Bounded model checking
of hybrid dynamical systems. In Proc. of IEEE Conf. on Decision and
Control, 2005.
[14] S. Karaman, R. G. Sanfelice, and E. Frazzoli. Optimal control of mixed
logical dynamical systems with linear temporal logic speciﬁcations. In
Proc. of IEEE Conf. on Decision and Control, pages 2117–2122, 2008.
[15] M. Kloetzer and C. Belta. A fully automated framework for control
of linear systems from temporal logic speciﬁcations. IEEE Trans. on
Automatic Control, 53(1):287–297, 2008.
[16] Y . Kwon and G. Agha. LTLC: Linear temporal logic for control. In
Proc. of HSCC, pages 316–329, 2008.
[17] S. M. LaValle. Planning Algorithms. Cambridge Univ. Press, 2006.
[18] J. L¨ ofberg. YALMIP : A toolbox for modeling and optimization in
MATLAB. In Proc. of the CACSD Conference, Taipei, Taiwan, 2004.
Software available at http://control.ee.ethz.ch/?joloef/yalmip.php.
[19] D. Mellinger and V . Kumar. Minimum snap trajectory generation and
control for quadrotors. In In Proc. of Int. Conf. on Robotics and
Automaton, 2011.
[20] D. Mellinger, A. Kushleyev, and V . Kumar. Mixed-integer quadratic
program trajectory generation for heterogeneous quadrotor teams. In
Proc. of Int. Conf. on Robotics and Automation, 2012.
[21] D. J. Webb and J. van den Berg. Kinodynamic RRT*: Asymptotically
optimal motion planning for robots with linear dynamics. In Proc. of
IEEE Int. Conf. on Robotics and Automation, 2013.
[22] E. M. Wolff and R. M. Murray. Optimal control of nonlinear systems
with temporal logic speciﬁcations. In Proc. of Int. Symposium on
Robotics Research, 2013. (to appear).
[23] T. Wongpiromsarn, U. Topcu, and R. M. Murray. Receding horizon
temporal logic planning. IEEE Trans. on Automatic Control, 2012.
[24] T. Wongpiromsarn, U. Topcu, N. Ozay, H. Xu, and R. M. Murray.
TuLiP: A software toolbox for receding horizon temporal logic plan-
ning. In Proc. of Int. Conf. on Hybrid Systems: Computation and
Control, 2011. http://tulip-control.sf.net.
5325
