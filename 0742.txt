Vector Field Following for Quadrotors using Differential Flatness
Dingjiang Zhou and Mac Schwager
Abstract— This paper proposes a differential ﬂatness-based
method for maneuvering a quadrotor so that its position follows
a speciﬁed velocity vector ﬁeld. Existing planning and control
algorithms often give a 2D or 3D velocity vector ﬁeld to
be followed by a robot. However, quadrotors have complex
nonlinear dynamics that make vector ﬁeld following difﬁcult, es-
pecially in aggressive maneuvering regimes. This paper exploits
the differential ﬂatness property of a quadrotor’s dynamics
to control its position along a given vector ﬁeld. Differential
ﬂatness allows for the analytical derivation of control inputs
in order to control the 12D dynamical state of the quadrotor
such that the 2D or 3D position of the quadrotor follows the
ﬂow speciﬁed by a given vector ﬁeld. The method is derived
mathematically, and demonstrated in numerical simulations
and in experiments with a quadrotor robot for three different
vector ﬁelds.
I. INTRODUCTION
In this paper we propose a control design method for
driving a quadrotor helicopter along a desired velocity vector
ﬁeld using tools from differential ﬂatness theory, as shown in
Fig. 1. This method is intended to make existing planning and
control algorithms that assume simple robot dynamics useful
for quadrotor robots with complex nonlinear dynamics. Our
method produces a low-level feedback controller so that
the quadrotor will reliably follow a desired vector ﬁeld,
even in aggressive dynamic ﬂight regimes. The method
uses differential ﬂatness theory to produce an input signal
to effectively cancel the complex internal dynamics of the
quadrotor, so it can be controlled as if it were an integrator.
Many control and planning techniques give an output
in the form of a vector ﬁeld along which the robot is
intended to move. For example, navigation, obstacle avoid-
ance, collision avoidance, swarming and ﬂocking, and mobile
network connectivity maintenance controllers often give a
vector ﬁeld for the robot or robots to follow to accomplish
the desired task. This is effective for robots moving in
a pseudo-static regime in which dynamics do not play a
major role in the motion, for example ground robots with
signiﬁcant gear reduction, or slow moving aerial robots.
However, in a dynamic regime in which inertial effects
cannot be neglected, it is challenging to control a robot along
an arbitrary vector ﬁeld. Speciﬁcally, quadrotor helicopters
have high dimensional, nonlinear dynamics to contend with,
so algorithms that give a vector ﬁeld are of questionable
This work was supported in part by ONR grant N00014-12-1-1000. We
are grateful for this support.
D. Zhou is with the Department of Mechanical Engineering, Boston
University, Boston, MA 02215, USA, zdj@bu.edu.
M. Schwager is with the Department of Mechanical Engineering and the
Division of Systems Engineering, Boston University, Boston, MA 02215,
USA, schwager@bu.edu.
Fig. 1. A quadrotor ﬂying to a limit cycle (left) and along a logarithmic
spiral (right) using our proposed vector ﬁeld following controller.
applicability without an “inner loop” controller to guide
the quadrotor along the vector ﬁeld. For example, a typical
obstacle avoidance algorithm will give a vector ﬁeld along
which a robot can drive to avoid obstacles. Using this vector
ﬁeld as a control input for a quadrotor may be effective at
low velocities, but as the commanded velocities increase, the
quadrotor will deviate more and more from the desired path,
eventually hitting the obstacle. Using our control method, the
quadrotor will maneuver itself to precisely follow the vector
ﬁeld, even for high desired velocities.
The chief difﬁculty lies in effectively compensating for the
dynamics of the quadrotor so that it achieves the velocity
commanded by the vector ﬁeld. We do this by exploiting
the differential ﬂatness property of quadrotor dynamics.
This property allows for the 12 dimensional state of the
quadrotor to be speciﬁed analytically from a desired position
and yaw angle, and their time derivatives. Furthermore, the
required control inputs for the quadrotor can also be speciﬁed
analytically in a similar way. Typically, differential ﬂatness is
used to plan trajectories for a quadrotor, and to give open-
loop control inputs to achieve this trajectory (for example
[10], [12]). Instead, we use differential ﬂatness to produce
a closed-loop feedback controller, that effectively causes the
quadrotor to move along the ﬂow of a given vector ﬁeld as
if it were a point particle, even in highly dynamic regimes.
We use the endogenous transformation for quadrotor dy-
namics described in [10], with some modiﬁcations, together
with a low level SE(3) controller, also used in [10], and
originally presented in [8]. The main contribution in our work
is to derive the instantaneous velocity, acceleration, jerk, and
snap required in the quadrotors endogenous transformation
analytically from a given vector ﬁeld. The vector ﬁeld can
be speciﬁed numerically with a given interpolation function
between points, or it can be speciﬁed analytically. In either
case, we require that up to third order spatial derivatives
can be computed from the vector ﬁeld description (for
acceleration, jerk, and snap). From these derivatives we ﬁnd
the state of the quadrotor to achieve the velocity required by
the vector ﬁeld, and then control the quadrotor to that state
2014 IEEE International Conference on Robotics & Automation (ICRA)
Hong Kong Convention and Exhibition Center
May 31 - June 7, 2014. Hong Kong, China
U.S. Government work not protected by
U.S. copyright
6567
with the low-level SE(3) controller. The overall architecture
does not require any explicit trajectory planning or trajectory
representation, and gives a reactive closed-loop controller.
The control method is demonstrated in simulations and
in experiments with a quadrotor robot ﬂying along three
different vector ﬁelds.
A. Related Work
Our control method renders many existing vector-ﬁeld
based control algorithms useful for quadrotors, which would
otherwise be ineffective. For example, classical techniques
that employ artiﬁcial potential ﬁelds and navigation functions
for navigation to a goal [15], [4] can be used with our
controller to navigate quadrotors. The foundational work on
navigation functions [15] can be used with our method to
navigate quadrotors. Also, algorithms for controlling linear
dynamics in polytopic regions of a state space [4] have
been used as building blocks for more complex control
strategies [7], [1]. Our method can be used with [4] to control
quadrotors through polytopic regions, extending these high
level control techniques to quadrotors. Methods for obstacle
avoidance also commonly generate vector ﬁelds to avoid
obstacles, and these can now be used for quadrotors given
our control method. For example, the seminal work [6] uses
time varying artiﬁcial potentials that result in time varying
velocity ﬁelds for a robot to avoid moving obstacles. These
can be used directly with our control method for quadrotors.
Similarly, the concept of reciprocal velocity obstacles [19]
allows multiple robots to avoid collisions with one another,
but relies on integrator dynamics of the robots (which is
mathematically equivalent to giving a velocity vector ﬁeld).
Our method renders this approach useful for quadrotors as
well.
In multi-robot control, it is particularly common to assume
the robots have integrator dynamics. For example, well
known control algorithms for ﬂocking [5], herding [14], and
consensus [13] assume either single or double integrator
dynamics. Also, controllers for multi-agent sensor coverage
and surveillance often assume integrator dynamics, as in
[17], [2], [16], and controllers for connectivity maintenance
in mobile wireless networks commonly use this assumption
[21], [3]. Our method in this paper controls quadrotors so
that they behave as single integrators, thus making all of
these multi-agent control strategies directly applicable to
quadrotors.
The rest of this paper is organized as follows. Differential
ﬂatness theory as it applies to quadrotor dynamics is for-
mulated in Sec. II. The method for deriving a vector ﬁeld
following controller from a given vector ﬁeld is described in
Sec. III. Results of simulations and experiments are given in
Sec. IV and Sec. V, respectively. We offer our conclusions
in Sec. VI.
II. DIFFERENTIAL FLATNESS FOR QUADROTORS
In this section we deﬁne differential ﬂatness, provide a
model for the quadrotor dynamics, and we give a theorem
that compactly states the endogenous transform for the
quadrotor from the ﬂat outputs (and their time derivatives)
to the states and inputs. This material summarizes and
formalizes the derivation from [10].
A. Differential Flatness
Differential ﬂatness is a property of some nonlinear control
systems that allows the state vector and the input vector
to be written in terms of a smaller number of, so called,
ﬂat outputs, and some number of time derivatives of those
outputs. The function that maps from the outputs and their
time derivatives to the states and inputs is known as the
endogenous transformation [12]. Quadrotor dynamics are
known to be differentially ﬂat. This is typically useful
in trajectory planning, because a desired trajectory in the
ﬂat outputs can be used to analytically ﬁnd the open-loop
trajectory of the inputs required to reproduce the trajectory.
In contrast, here we use differential ﬂatness to ﬁnd a closed-
loop controller to drive a quadrotor as if it were a simple
integrator traveling through a desired velocity vector ﬁeld.
More formally, a nonlinear control system
_
 =f(;) is
called differentially ﬂat if there exists an invertible function
 such that
 =(;; _  ;
(p)
);
for some ﬁnite number of time derivatives p, where  is
called the ﬂat output. Furthermore, the inverse of  gives
the trajectories of  and  as functions of the ﬂat outputs
and q time derivatives,
(
 =(; _ ; ;
(q)
);
 =(; _ ; ;
(q)
):
(1)
We call the two functions (;) together the endogenous
transformation. In this section we give the endogenous
transformation for a quadrotor robot, with the position and
yaw angle as ﬂat outputs.
B. Quadrotor Dynamics
A quadrotor is well-modeled as a rigid body with forces
and torques applied from the four rotors and gravity [10].
This is similar to the dynamics of a ﬁxed wing aircraft,
but without the aerodynamic forces and moments from the
wings and stabilizers [18]. The relevant forces, moments, and
coordinate frames are shown in Fig. 2.
Fig. 2. Quadrotor coordinate frames with a North-East-Down world
coordinate system. The world frame is denotedFw , the aircraft body-ﬁxed
frame is F
b
, and Fc is an intermediate frame after the yaw angle rotation.
6568
We deﬁne the rotation matrix from the body frame to the
world frame using ZYX Euler angles as
R =R
z; 
R
y
0
;
R
x
00
;
=
2
4
CC SSC  CS CSC +SS 
CS SSS +CC CSS  SC 
 S SC CC
3
5
(2)
where is roll, is pitch, is yaw, andS is sin(), andC
is cos() for simplicity. The quadrotor dynamics are given
by the nonlinear system of equations
_ v =ge3 +
1
m
Rfze3 (3)
_
R =R
 (4)
_ !
b
=J
 1
 J
 1

J!
b
(5)
_
h =v (6)
where v = [v
x
;v
y
;v
z
]
T
is the velocity in the world frame
F
w
,g is the acceleration due to gravity,m is the mass,f
z
is
the total thrust force from the rotors, e
3
= [0; 0; 1]
T
, hence
f
z
e
3
is aligned with the negative vertical body-ﬁxed direction
 z
b
of the body frame F
b
. The rotation matrix R is from
(2), !
b
= [p;q;r]
T
is the angular velocity of the quadrotor
expressed in F
b
, 
 = !
^
b
= [0; r;q;r; 0; p; q;p; 0]
is the tensor form of !
b
. The torque on the quadrotor is
given by  = [
x
;
y
;
z
]
T
in the body frame F
b
, J is
the inertia matrix of the quadrotor, and h = [x;y;z]
T
is the position of the quadrotor in F
w
. The quadrotor’s
inputs are the total thrust and the three torques  =
[f
z
;
x
;
y
;
z
]
T
, and the system has a 12 dimensional state,
 = [x;y;z;v
x
;v
y
;v
z
; ;;;p;q;r]
T
.
C. Endogenous Transformation
Consider the ﬂat outputs consisting of position and yaw
angle  = [
1
;
2
;
3
;
4
]
T
= [x;y;z; ]
T
. In this sec-
tion we give the functions () and () such that, given
(; _ ;  ;
...
;
....
 ), we can ﬁnd the associated state  and input
. The following theorem summarizes the results of [10].
Theorem 1: The quadrotor dynamics (3)–(6), with state
 = [x;y;z;v
x
;v
y
;v
z
; ;;;p;q;r]
T
and input  =
[f
z
;
x
;
y
;
z
]
T
, are differentially ﬂat, with the ﬂat outputs
 = [
1
;
2
;
3
;
4
]
T
:= [x;y;z; ]
T
; (7)
such that  =(; _ ;  ;
...
), with
8
>
>
>
>
>
>
<
>
>
>
>
>
>
:
[x;y;z;v
x
;v
y
;v
z
; ]
T
=
1:7
(; _ )
= [
1
;
2
;
3
; _ 
1
; _ 
2
; _ 
3
;
4
]
T
 =
8
(; _ ;  ) = atan2(
a
;
b
)
 =
9
(; _ ;  ) = atan2(
c
;
p

2
a
+
2
b
)
[p;q;r]
T
=
10:12
(; _ ;  ;
...
) = (R
T
_
R)
_
;
(8)
where
8
>
<
>
:

a
=  cos
4
 
1
  sin
4
 
2

b
=  
3
+g

c
=  sin
4
 
1
+ cos
4
 
2
;
(9)
andR is from (2) with the Euler angles (;) deﬁned in (8).
Furthermore,  =(; _ ;  ;
...
;
....
 ), with
8
>
<
>
:
f
z
=
1
(; _ ;  ) = mk  
1:3
 ge
3
k
[
x
;
y
;
z
]
T
=
2:4
(; _ ;  ;
...
;
....
 )
=J(
_
R
T
_
R +R
T

R)
_
+R
T
_
RJ(R
T
_
R)
_
;
(10)
where  
1:3
= [ 
1
;  
2
;  
3
]
T
for short and the
_
map is the
inverse operation of
^
.
Proof: (Abbreviated) The expression 
1:7
() in (8)
follows immediately from (7). Equation (3) shows thatz
b
=
 
 1:3 ge3
k 1:3 ge3k
andf
z
= mk  
1:3
 ge
3
k
1
(), sincef
z
e
3
is aligned toz
b
but in the opposite direction. Comparingz
b
to
the third column of rotation matrixR in (2) we can solve for
cos sin, cos cos and sin, which are
a
,
b
and
c
in
(9), respectively, and ﬁnd =
8
() and =
9
(), as well as
the rotation matrix R. Equation (4) shows that 
 = R
T
_
R,
hence !
b
= (R
T
_
R)
_
. Finally, (5) gives  = [p;q;r]
T
=
J _ !
b
+ 
J!
b
= J(
_
R
T
_
R + R
T

R)
_
+ R
T
_
RJ(R
T
_
R)
_


2:4
().
The
_
map is feasible due to the following lemma.
Lemma 1: For all rotation matricesR, we haveR
T
_
R and
_
R
T
_
R +R
T

R are skew-symmetric matrices. In other words,
8R2SO(3), R
T
_
R2so(3), and
_
R
T
_
R +R
T

R2so(3).
Proof: Take the time derivative of R
T
R = I to get
_
R
T
R + R
T
_
R = 0. Hence we have (R
T
_
R)
T
+ R
T
_
R =
0, satisfying the so(3) condition for R
T
_
R. Differentiate
(R
T
_
R)
T
+R
T
_
R = 0 to get (
_
(R
T
)
_
R +R
T

R)
T
+ (
_
(R
T
)
_
R +
R
T

R) = (
_
R
T
_
R +R
T

R)
T
+ (
_
R
T
_
R +R
T

R) = 0, implies
that
_
R
T
_
R +R
T

R2so(3).
III. VECTOR FIELD FOLLOWING
In many scenarios, it is desirable for a robot to follow
a given velocity vector ﬁeld, for example for navigation,
collision avoidance, connectivity maintenance, ﬂocking, and
herding applications. In this section, we describe our method
for deriving the time derivatives of the ﬂat outputs from a
given velocity vector ﬁeld. This is the main contribution of
our work.
The key to our method is to ﬁnd the required time
derivatives ( _ ,  ,
...
,
....
 ) by taking spatial derivatives of
the vector ﬁeld. With these time derivatives, the states and
inputs of the quadrotor can be generated from the endoge-
nous transformation as described in Theorem 1. The SE(3)
controller described in [10] and [8] is then used to stabilize
the quadrotor along the required trajectory (t). Here we
only consider vector ﬁelds specifying spatial velocity, hence
the yaw angle 
4
is irrelevant. We arbitrarily set 
4
(t) 0,
and the expressions for the time derivatives of 
1:3
(t) are
computed with the following theorem.
Theorem 2: The ﬂat output derivatives required to com-
pute the endogenous transformation _ 
1:3
;  
1:3
;
...

1:3
;
....

1:3
at
any point x in a vector ﬁeld V (x) can be calculated by
8
>
>
>
<
>
>
>
:
_ 
1:3
(x) =V (x)
 
1:3
(x) =J ( _ 
1:3
(x);x) _ 
1:3
(x)
...

1:3
(x) =J ( 
1:3
(x);x) 
1:3
(x)
....

1:3
(x) =J (
...

1:3
(x);x)
...

1:3
(x);
(11)
6569
whereJ (f(x);x) denotes the Jacobian matrix of the func-
tion f(x).
Proof: _ 
1:3
(x) = V (x) is true by deﬁnition.
Then  
1:3
(x) =
d(_ 1:3(x))
dt
=
@(_ 1:3(x))
@x
d(x(t))
dt
=
J ( _ 
1:3
(x);x) _ 
1:3
(x), and the procedure can be recursively
applied to obtain the expressions for the third and forth time
derivatives.
The method is applicable to 1D, 2D, or 3D vector ﬁelds,
but we show examples only with 2D vector ﬁelds for clarity.
For example, consider a velocity vector ﬁeld given by the
equation
V (x
1
;x
2
) =

x
2
 x
1

 0:5 sin(x
2
1
+x
2
2
 1)

x
1
x
2

; (12)
in which all trajectories converge to the limit cyclex
2
1
+x
2
2
=
1. Fig. 3 shows the velocity ﬁeld (12) and its three time
derivatives.
?1 0 1
?1.5
?1
?0.5
0
0.5
1
1.5
(a) Velocity
?1 0 1
?1.5
?1
?0.5
0
0.5
1
1.5
(b) Acceleration
?1 0 1
?1.5
?1
?0.5
0
0.5
1
1.5
(c) Jerk
?1 0 1
?1.5
?1
?0.5
0
0.5
1
1.5
(d) Snap
Fig. 3. Vector ﬁeld as in (12), with scaled vector length for plotting.
Using the endogenous transformation described in Sec. II,
we then obtain the states and inputs for the quadrotor to be
used as a control reference to control it along the desired
vector ﬁeld. Speciﬁcally, for the vector ﬁeld in (12), the
simulation in Sec. IV and the experiment in Sec. V will show
that the trajectory of the quadrotor converges asymptotically
to the limit cyclex
2
1
+x
2
2
= 1, with the origin be translated.
IV. SIMULATION
To illustrate the concept, in this section we consider simu-
lation with a dynamical model of the quadrotor ﬂying in three
different velocity vector ﬁelds: 1), limit cycle; 2), logarithmic
spiral and 3), obstacle avoidance. Sec. V gives the results of
hardware experiments with a quadrotor executing our control
method in the same three vector ﬁelds.
A. Limit Cycle
As in (12) and Fig. 3, the vector ﬁeld is designed to
cause the quadrotor to converge to a circle centered at
[0:9; 1:5; 0:5]
T
. The trajectory of the quadrotor is shown
in Fig. 4, with the quadrotor image drawn at various time
instants to give an indication of pitch and roll angles. The
quadrotor does not actually enter the vector ﬁeld until the
third image. Before then, it is executing a planned maneuver
to take off and enter the vector ﬁeld with the appropriate
velocity.
?0.5
0
0.5
1
1.5
0 0.5 1 1.5 2 2.5
0
0.5
1
 
 
altitude = ?z
Quadrotor trajectory
Limit cycle
Fig. 4. The 2D vector ﬁeld is the same with Fig. 3(a) but translated to
[0:9;1:5; 0:5]
T
, with a constant altitude 0:5m. The trajectory converges
to the circle (x 0:9)
2
+(y 1:5)
2
=1, with z = 0:5, as expected.
B. Logarithmic Spiral
The equation of a logarithmic spiral in polar coordinates
is r = ae
 b
;a;b > 0;2 [0;1), with the corresponding
vector ﬁeld in Cartesian coordinates deﬁned by
V (x) =

x
2
 x
1

 b

x
1
x
2

; (13)
as shown in Fig. 5. The trajectory of the quadrotor is shown
in Fig. 6. Again, the ﬁrst two images show a pre-planned
take-off trajectory, and the quadrotor enters the vector ﬁeld
at the third image.
?1.5 ?1 ?0.5 0 0.5 1 1.5
?1.5
?1
?0.5
0
0.5
1
1.5
(a) Logarithmic spiral with a =
1:5; b=0:2, and !1.
?1.5 ?1 ?0.5 0 0.5 1 1.5
?1.5
?1
?0.5
0
0.5
1
1.5
 
 
Spiral path
(b) A path following the vector
ﬁeld as eq. (13) with b=0:2.
Fig. 5. Starts from[ 1:5;0]
T
in the vector ﬁeld, the path eventually spires
to [0;0]
T
, showing the same trajectory as the logarithmic spiral.
C. Obstacle Avoidance
In this scenario, the quadrotor travels to a destination
point, with an obstacle in its path. The destination generates
an attracting ﬁeld to pull the quadrotor to it, while the
obstacle generates a repelling ﬁeld to push the quadrotor
away.
The attracting and repelling vector ﬁelds in Fig. 7 are
formulated from the gradient of a 2D Gaussian G(x) =
Ae
( (x x0)
T
(x x0))=2
2
. Taking the gradient, the attracting
vector ﬁeld of the destination at x
a
is deﬁned as v
a
(x) =
G(x)

2
(x
a
  x), 8x. And the repelling vector ﬁeld of the
obstacle at x
r
is deﬁned as v
r
(x) =
G(x)
kx xrk
(x x
r
),8x,
such that k x  x
r
k r
ob
, where r
ob
is the minimum
6570
?0.5
0
0.5
1
1.5
0 0.5 1 1.5 2 2.5
0
0.5
1
 
 
altitude = ?z
Quadrotor trajectory
Logarithmic spiral
Fig. 6. The quadrotor starts from [0:9;0; 0:5]
T
to follow the vector
ﬁeld, and spire to the center [0:9;1:5; 0:5]
T
, to which the vector ﬁeld is
translated. The quadrotor achieves a trajectory the same with the logarithmic
spiral as in Fig. 5.
0 0.5 1 1.5 2 2.5 3
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
 
 
Start
Destination
Path
Fig. 7. A composite 2D vector ﬁeld of an attracting ﬁeld from the destina-
tion at[2:5;1:5]
T
and a repelling ﬁeld from the obstacle at[1:2;0:6]
T
. The
path shows the expected trajectory of a robot starts from the point[0;0:2]
T
,
and then follow the vector ﬁeld to the destination, where the vector vanishes
to zero.
safety distance to the center of the obstacle. Fig. 8 shows
the simulation results.
V. EXPERIMENTS
Hardware experiments were conducted with a
K500 quadrotor, from KMel Robotics (http:
//kmelrobotics.com/). The position and orientation
of the quadrotor are observed by an OptiTrack motion
capture system (http://www.naturalpoint.com/
optitrack/) at the default update rate 120Hz and
obtained by MATLAB via Java scripts reading UDP packets
from the OptiTrack. The velocity and angular velocity are
computed by numerical differentiation from the position and
Euler angles, as well as with an Extended Kalman Filter
(EKF) in MATLAB.
The UDP packet parsing, the EKF algorithm, and the
SE(3) controller are implemented in C language and are
called by MATLAB via the MEX interface to speed up the
calculation, making it possible to run the algorithm online
without degrading the OptiTrack update rate, even when
ﬂying multiple quadrotors. Meanwhile, the K500 receives
the desired thrust, Euler angles and Euler angles’ rate as the
inputs, and executes its onboard SO(3) controller based on
?0.5
0
0.5
1
1.5
0 0.5 1 1.5 2 2.5
0
0.5
1
 
 
altitude = ?z
Quadrotor trajectory
Vector flow path
(a) The virtual obstacle is at[0:6;1:2; 0:5]
T
, the quadrotor pass
it from left.
?0.5
0
0.5
1
1.5
0 0.5 1 1.5 2 2.5
0
0.5
1
 
 
altitude = ?z
Quadrotor trajectory
Vector flow path
(b) The virtual obstacle is at[1:0;1:2; 0:5]
T
, the quadrotor pass
it from right.
Fig. 8. The quadrotor avoids the obstacle with different trajectories when
the virtual obstacles (black circle) are at different positions.
the onboard IMU data at a 500Hz update rate. The control
framework is shown in Fig. 9, which is a typical feedback
control system.
Fig. 9. System diagram, the markers are used for tracking.
All experiments were conducted corresponding to the
same setup as in the simulations in Sec. IV. As in the
simulations, the quadrotor takes off and ﬂies into the vector
ﬁeld by following a predeﬁned trajectory, which is generated
from spline curves [20],[12]. The ﬁnal state of this trajectory
is designed to match the vector ﬁeld so that the quadrotor
can transition smoothly into from the trajectory following to
the vector ﬁeld following control.
A. Limit Cycle
The quadrotor ﬁrst ﬂies to [0:5; 0:5; 0:5]
T
, which is
outside of the limit cycle (x  0:9)
2
+ (y  1:5)
2
= 1, with
6571
a predeﬁned trajectory, then in the vector ﬁeld following, it
converges to the limit cycle as expected, with a small position
error. Along the cycle, the quadrotor ﬂies at a constant speed
1:4m=s, as in Fig. 10(a).
(a) Composite image of a sin-
gle quadrotor ﬂying a limit cycle,
http://tinyurl.com/qbus6c7.
(b) Composite image of a single
quadrotor ﬂying a logarithmic spi-
ral, http://tinyurl.com/kx2meq4.
Fig. 10. A single quadrotor ﬂying a limit cycle and a logarithmic spiral
path at a constant altitude 0:5m.
B. Logarithmic Spiral
The quadrotor ﬁrst ﬂies to [0:9; 0; 0:5]
T
where it enters
the vector ﬁeld, as shown in Fig. 10(b). The maximum speed
in this case is 1:4m=s, and the quadrotor quickly slows down
when approaching the center of the logarithmic spiral.
C. Obstacle Avoidance
We present two experiments to demonstrate the obstacle
avoidance with the vector ﬁeld following strategy. In each
experiment, the virtual obstacle is presented at a different
position. In the vector ﬁeld, the quadrotor ﬂies from the same
start position at [0:2; 0; 0:5]
T
to the same destination at
[1:5; 2:5; 0:5]
T
.
(a) The virtual obstacle
is at [0:6;1:2; 0:5]
T
,
http://tinyurl.com/o475fna.
(b) The virtual obstacle
is at [1:0;1:2; 0:5]
T
,
http://tinyurl.com/qdmucrm.
Fig. 11. Composite image of a single quadrotor avoiding an obstacle at
different positions.
VI. CONCLUSIONS AND FUTURE WORK
In this paper we persent a method for controlling a
quadrotor robot along a desired vector ﬁeld. This is difﬁcult
because quadrotors have complex nonlinear dynamics. It
is useful because many algorithms for robot navigation,
collision avoidance, surveillance, ﬂocking, and herding give a
vector ﬁeld for a robot to follow to accomplish its task. Our
control method leverages the tools of differential ﬂatness,
and obtains the desired velocity, acceleration, jerk, and snap
of the quadrotor directly from the vector ﬁeld. The method
is demonstrated in simulations and experiments with three
different vector ﬁelds. In the future we will consider the
yaw angle and its derivatives to the second order from the
vector ﬁeld, and explore extensions to multiple quadrotors
interacting with vector ﬁelds. Also, The conditions of the
vector ﬁeld under which the quadrotor dynamics can satisfy
should be studied.
REFERENCES
[1] Nora Ayanian and Vijay Kumar. Decentralized feedback controllers for
multi-agent teams in environments with obstacles. IEEE Transactions
on Robotics, 26(5):878 – 887, October 2010.
[2] J. Cort´ es, S. Mart´ ınez, T. Karatas, and F. Bullo. Coverage control
for mobile sensing networks. IEEE Transactions on Robotics and
Automation, 20(2):243–255, April 2004.
[3] D. V . Dimarogonas and K. H. Johansson. Decentralized connectivity
maintenance in mobile networks with bounded inputs. In Robotics
and Automation, 2008. ICRA 2008. IEEE International Conference
on, pages 1507–1512, 2008.
[4] L. Habets and J. H. van Schuppen. A control problem for afﬁne
dynamical systems on a full-dimensional polytope. Automatica,
40(1):21–35, 2004.
[5] A. Jadbabaie, J. Lin, and A. S. Morse. Coordination of groups
of mobile autonomous agents using nearest neighbor rules. IEEE
Transactions on Automatic Control, 48(6):988–1001, June 2003.
[6] O. Khatib. Real-time obstacle avoidance for manipulators and mobile
robots. The international journal of robotics research, 5(1):90–98,
1986.
[7] M. Kloetzer and C. Belta. A fully automated framework for control of
linear systems from temporal logic speciﬁcations. Automatic Control,
IEEE Transactions on, 53(1):287–297, 2008.
[8] Taeyoung Lee, M Leoky, and N Harris McClamroch. Geometric
tracking control of a quadrotor uav on se (3). In Decision and
Control (CDC), 2010 49th IEEE Conference on, pages 5420–5425.
IEEE, 2010.
[9] P. Martin, R. M. Murray, and P. Rouchon. Flat systems, equivalence,
and trajectory generation. Technical report, California Institute of
Technology, Control and Dynamical Systems, April 2003.
[10] Daniel Mellinger and Vijay Kumar. Minimum snap trajectory genera-
tion and control for quadrotors. In Robotics and Automation (ICRA),
2011 IEEE International Conference on, pages 2520–2525. IEEE,
2011.
[11] Nathan Michael, Daniel Mellinger, Quentin Lindsey, and Vijay Ku-
mar. The grasp multiple micro-uav testbed. Robotics & Automation
Magazine, IEEE, 17(3):56–65, 2010.
[12] Richard M Murray. Optimization-based control. California Institute
of Technology, CA, 2009.
[13] R. Olfati-Saber and R. R. Murray. Consensus problems in networks of
agents with switching topology and time-delays. IEEE Transactions
on Automatic Control, 49(9):1520–1533, September 2004.
[14] C. Reynolds. Flocks, herds, and schools: A distributed behavioral
model. Computer Graphics, 21:25–34, 1987.
[15] E. Rimon and D. E. Koditschek. Exact robot navigation using artiﬁcial
potential functions. IEEE Transactions on Robotics and Automation,
8(5):501–518, 1992.
[16] M. Schwager, B. Julian, M. Angermann, and D. Rus. Eyes in the sky:
Decentralized control for the deployment of robotic camera networks.
Proceedings of the IEEE, 99(9):1541–1561, September 2011.
[17] M. Schwager, D. Rus, and J. J. Slotine. Unifying geometric, prob-
abilistic, and potential ﬁeld approaches to multi-robot deployment.
International Journal of Robotics Research, 30(3):371–383, March
2011.
[18] Brian L Stevens and Frank L Lewis. Aircraft control and simulation.
2003.
[19] J. Van den Berg, M. Lin, and D. Manocha. Reciprocal velocity obsta-
cles for real-time multi-agent navigation. In International Conference
on Robotics and Automation (ICRA), pages 1928–1935, 2008.
[20] Fujio Yamaguchi and Fujio Yamaguchi. Curves and surfaces in
computer aided geometric design. Springer-Verlag Berlin, 1988.
[21] M. M. Zavlanos and G. J. Pappas. Potential ﬁelds for maintaining
connectivity of mobile networks. IEEE Transactions on Robotics,
23(4):812–816, August 2007.
6572
