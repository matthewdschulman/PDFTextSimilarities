Constraint- and synergy-based speciﬁcation of manipulation tasks
Gianni Borghesan, Erwin Aertbeli¨ en and Joris De Schutter
Abstract— This work aims to extend the application ﬁeld of
the constraint-based control framework called iTaSC (instanta-
neous task speciﬁcation using constraints) toward manipulation
tasks. iTaSC offers two advantages with respect to other meth-
ods: the ability to specify tasks in different spaces (and not only
in Cartesian coordinates as for the Task Frame Formalism),
and the treatment of geometric uncertainties. These properties
may be very useful within a manipulation context, where tasks
are executed by robots with many degrees of freedom, which
calls for some degree of abstraction; by choosing a suitable
set of coordinates, it is possible to reduce the complexity and
the number of constraints that fully describe such tasks; in
addition, controlling only the subspace that is needed to fulﬁl
a task allows us to use the remaining degrees of freedom of
the robot system to achieve secondary objectives. This paper
discusses the instruments and techniques that can be employed
in manipulation scenarios; in particular it focuses on aspects
like the speciﬁcation of a grasp and control of the stance of the
robotic arm.
iTaSC offers the possibility of specifying a grasp. While this
approach allows for very ﬁne control of a grasping task, in
most cases a less ﬁne-grain speciﬁcation sufﬁces to guarantee a
successful execution of the grasping action. To this end synergy-
based grasp speciﬁcation is formulated within iTaSC.
We also show how to take into account secondary objectives
for the arm stance. In particular we consider, as an example,
the manipulability index along a given direction. Such indexes
are maximised by exploring the null space of the other tasks.
The proposed approach is demonstrated by means of simu-
lations, where a robotic hand grasps a cylindrical object.
I. INTRODUCTION
One of present challenges in robotic research is to bring
robots outside their fences, and make them operate in
environments designed for people rather than for robots,
[1]. Lack of structure, uncertain a priori knowledge of the
environment, and unexpected changes are difﬁculties that
robots should cope with autonomously.
Vagueness in the environment description reﬂects also
in vagueness of a task. While in an industrial scenario a
robot may be programmed by means of joint trajectories, a
household task is expressed in a more high level language:
many of the details for actually computing the robot control
action may be available only at run-time, and they may
change with each execution. For such reasons, employing
a framework that allows to express a task in local reference
frames, in a suitable space, and to omit the speciﬁcation of
whatever is not strictly needed, seems to be an appropriate
approach to develop such applications.
All authors gratefully acknowledge the European FP7 project RoboHow
(FP7-ICT-288533).
The authors are with the Department of Me-
chanical Engineering, K.U.Leuven, Heverlee, Belgium.
name.surname@mech.kuleuven.be
Among these frameworks (e.g. the stack of tasks, [2],
the operational space formulation, [3], task frame formalism
by Mason, [4] and more recent developments, [5], etc. )
we opted for iTaSC, [6], a velocity-resolved framework
that allows for the automatic derivation of the control law,
starting from the geometric speciﬁcation of the task. While
this aspect will not be emphasized in this work, one of
the characteristics of iTaSC is the treatment of geometric
uncertainties, i.e. unknown object positions, kinematic un-
certainties, etc., which are deﬁnitely relevant for the above
mentioned applications.
iTaSC introduces feature variables and feature frames, as
well as the concept of virtual kinematic chains. This allows
us to model the quantities (outputs) to be controlled in the
most convenient way. For example, cylindrical or spherical
coordinates represent the distance between a point and a line,
or between two points, respectively, and therefore should
be introduced whenever such distances are the subject of
constraints.
By employing iTaSC and the modelling procedure de-
scribed in Sec. II the robot programmer does not have to
worry about the derivation of geometric jacobians that are
needed in velocity-resolved schemes. The iTaSC controller
takes care of the robot control in an optimal way (given
the cost function to be used in the optimization process),
solves conﬂicts between constraints when the problem is
over-constrained, and is able to execute more than one task
at a time.
What iTaSC is partly missing, and what this work focuses
on, is the control and representation of robotic grasping and
the control of the arm conﬁguration. We address the ﬁrst
issue by looking at hand control, Sec. III, with a particular
emphasis on grasp synergy integration, while for the latter
issue we focus on how to express complex constraints that
live in the joint space (such as a manipulability index) in the
iTaSC formulation, Sec. IV.
II. ITASC MODELLING PROCEDURE
An iTaSC application consists of tasks, robots and objects,
a scene-graph, and a solver. For every application, the
programmer ﬁrst has to identify the robots and objects.
In the framework an object can be any object in the robot
system (for example the robot end-effector, a robot link, or
an object attached to it) or in the robot environment. Next,
the programmer deﬁnes object frames {o} on the robots and
objects (i.e. frames on their kinematic chains) at locations
where a task will take effect, for instance the robot end-
effector or an object to be tracked.
The object frames {o} are deﬁned w.r.t. the respective
base frames {b} which are placed at the base of a robot or
2014 IEEE International Conference on Robotics & Automation (ICRA)
Hong Kong Convention and Exhibition Center
May 31 - June 7, 2014. Hong Kong, China
978-1-4799-3684-7/14/$31.00 ©2014 IEEE 397
?
uI

b
1
	

b
2
	

f
1
	 
f
2
	

f
3
	

f
4
	 
f
5
	

o
1
	

o
2
	
{w}
q
1
?
fI
?
fII
?
fIII
?
fIV
?
fV
?
fVI
Fig. 1: Kinematic task loop with different frames and
robot (q) and feature (?
f
) coordinates. q
1
and q
2
are the
controllable DOF of the ﬁrst and second object respectively
(typically the robot joints). The feature coordinates ?
f
are
the DOF between {o1} and {o2}, which, by introducing
the feature frames, are distributed over six submotions: the
relative motion of {f1} with respect to {o1} (submotion I,
with feature coordinates ?
fI
), the relative motion of {f2}
with respect to {f1} (submotion II, with feature coordinates
?
fII
), and so on.
in reference frame of an object; these frames, in turn, are
described in function of a world frame {w} .
The actual tasks deﬁne the space between pairs of object
frames ({o1} and {o2}), the feature space, as a virtual
kinematic chain (VKC). To simplify the task deﬁnition,
feature frames are introduced [6]. The feature frames are
linked to an object, and indicate a physical entity on that
object (such as a vertex or surface), or an abstract geometric
property of a physical entity (such as the symmetry axis
of a cylinder). Each task needs at least two object frames
(called {o1} and {o2}, each attached to one of the objects),
and any number of feature frames (called {f1}, {f2}, . . . )
For an application in 3D space, there are in general six
DOF between{o1} and{o2}. Without loss of generality, we
restrict to the case where the six DOF are distributed over
six sub-motions, as shown in Fig. 1, i.e. each sub-motion is
characterized with a sole degree of freedom.
The general framework allows to account for geometric
uncertainties inside kinematic chains of objects or robots, or
virtual kinematic chains. Uncertainties are represented with
a minimal set of coordinates in strict analogy with feature
coordinates, and are indicated with ?
uI
, ?
uII
, etc.
The treatment of uncertainties goes beyond the scope of
this paper and (without loss of generality) will be omitted,
assuming that all the geometrical properties of objects are
known.
At this point, it is necessary to deﬁne how the robots and
objects are located in the application scene. This is achieved
by deﬁning the relations between the reference frames of the
robots and objects and a global world reference frame {w}.
By connecting the VKC of the tasks to the object frames
on the robots and objects, the programmer deﬁnes which
robots execute the tasks on which objects. Each task deﬁnes
a kinematic loop in the scene as shown in Fig. 1.
The kinematic loops introduce constraints between the
robot coordinates q and the feature coordinates ?
f
=

?
fI
T
,?
fII
T
,...

T
expressed by the loop closure equation:
l(q,?
f
) =0, (1)
from which is possible to compute the loop closure equation
at velocity level:
∂l(q,?
f
)
∂q
˙ q +
∂l(q,?
f
)
∂?
f
˙ ?
f
, J
q
˙ q +J
f
˙ ?
f
=0, (2)
At this point, in order to obtain the desired task behaviour,
one has to impose constraints on the relative motion be-
tween the two objects. To this end, the programmer has to
choose the outputs that have to be constrained by deﬁning
an output equation:
y =f (q,?
f
). (3)
Feature coordinates are usually chosen so that they include
the output, and thus f (·) reduces to selection matrices:
y =C
q
q +C
f
?
f
, and (4)
˙ y =C
q
˙ q +C
f
˙ ?
f
, (5)
where C
q
and C
f
only contain zeros except for one ‘1’ in
each row.
The imposed constraints used to specify the task are then
directly expressed on the outputs as:
y =y
d
, (6)
where subscript d denotes a desired value.
Constraints are enforced by a controller, and a solver.
The controller receives the desired output values (y
d
) and
its derivatives (˙ y
d
) from a set-point generator, and computes
the desired velocity ˙ y
?
d
in the output space:
˙ y
?
d
=g(y,y
d
, ˙ y
d
). (7)
This equation is normally implemented as a feed-
back/feed-forward combination:
˙ y
?
d
=K
p
(y
d
?y)+ ˙ y
d
. (8)
The solver provides a solution for the optimization prob-
lem of calculating the desired robot joint velocities ˙ q
d
from
the desired velocities computed by the controller (˙ y
?
d
):
˙ q
d
=A
#
W
˙ y
?
d
, A =C
q
?C
f
J
?1
f
J
q
. (9)
The weighed pseudo-inverse computation involves two
weighting matrices which allow us to weight conﬂicting con-
straints (over-constrained case), and to weight the actuation
cost at joint velocity level (under-constrained case).
III. HAND CONTROL
This section deals with the problem of controlling the
hand. We propose two approaches: direct speciﬁcation of
the contact constraints, merely considering the robotic hand
as a branched robot, and a synergy-based approach. Further
on, in Sec. IV, we will introduce the tasks inﬂuencing the
whole body conﬁguration.
398

o
wrist
	

b
object
	

b
robot
	
q
hand
q
arm

o
f1 tip
	 
o
f2 tip
	

o
f3 tip
	

o
side1
	 
o
side2
	
?
u
ﬁng. 1 task
ﬁng. 2 task
{w}
y[m
Fig. 2: Pinch grasping can be achieved by specifying the
desired locations of two or more contact points: in iTaSC
this can be achieved by imposing a zero distance between
the origins of the object frames

o
fi tip
	
and

o
side i
	
.
A. Direct speciﬁcation of contacts
The ﬁrst, natural approach to deﬁne a grasp is to specify
it in terms of where each contact point should be on the
surface of the object; in other words, the desired position of
the robotic ﬁngers’ “end-effector” is deﬁned (with respect to
an object feature or locally deﬁned frame). Many approaches
investigate how to optimize the grasp contact point positions
in order to achieve different goals, such as limiting the force
in order to ensure the minimum internal force, minimise the
number of contacts, e.g. [7]. Regardless of the method used
to specify the location of the contact points, the outcome is a
set of points that the ﬁngers should reach: this translates into
a set of kinematic loops (each one relating a frame attached
to the robot and a frame on the object surface), and a set of
constraints.
Fig. 2 shows an example of how a pinch grasp may be
speciﬁed. Such grasp consists of opposing ﬁngers making
contacts on opposite sides of an object; the goal is to position
the ﬁnger tips in the desired locations, while satisfying
additional constraints on their relative orientation.
Employing iTaSC to specify the grasping by means of
the contact points does not simplify the description of the
grasp itself; however, its use allows us to take advantage
of the other properties of this formalism, such as the use of
geometric uncertainties, the combination with other tasks (for
example imposing a certain behaviour to the robotic arm, as
will be discussed in Sec. IV), and ﬁne tuning the behaviour
by means of weights.
This kind of task description can be realised with tools
already offered in iTaSC, and will not be further discussed.
B. Synergy-based speciﬁcation of hand conﬁguration
When the goal of a robotic hand-centred task is grasping,
it is possible to resort to the so-called postural synergies [8].
Synergies provide a reduced dimension base for the hands
joint, that allows us to specify most of the hand postures
needed for grasping as a combination of eigen-grasp vectors,
[9]. Synergiess are deﬁned as
q
hand
=S
?1
(s), (10)
where S
?1
(·) may be realised with a simple linear map S
(that contains the eigen-vectors) plus an initial offset q
so
:
q
hand
=S
?1
(s) ,Ss+q
so
(11)
In order to deﬁne the grasp, along with the desired
conﬁguration s
d
, the relative pose of the hand’s wrist with
respect to the object must be given: we follow and expand
the guidelines given by Prats, [10], where the object frames
(called hand frameH and grasp frameG) employed in the
task depend on the task itself, and optionally on the hand
conﬁguration.
The remainder of the section addresses the synthesis of the
synergy controller and the speciﬁcation of the wrist position.
1) synergy-based controller: Synergies fully constrain the
joint space of the hand (at each s corresponds a given
joint vector), without spanning the whole space, and so the
matrix S has more rows than columns. By pseudo-inverting
(11), we obtain the surjective function S(·) , which maps
different hand conﬁgurations to the same synergy without
discerning whether a joint conﬁguration actually belongs to
the space spanned by the eigen-grasp base S. Hence, unless
additional constraints are added, a constraint in the synergy
space cannot ensure that the hand will reach the correct
conﬁguration.
For this reason, the constraints are enforced directly in
joint space: given the desired conﬁguration of the hand, that
is fully described bys
d
, the desired hand joint valueq
d,hand
is computed, and imposed as a set of joint constraints. The
selection matrix C
q
is chosen accordingly.
2) Control of the wrist frame: The complementary aspect
of controlling the conﬁguration of the hand is positioning
the wrist in the correct pose with respect to the object that
will be grasped. This desired wrist pose strongly depends
on the hand conﬁguration itself, but also on the task being
performed.
For this reason, a set of object frames is associated with
the hand, where each frame is associated with one or more
grasp strategies. For example, Fig. 3 introduces two frames
used for the envelope and pinch grasps. For the envelope
grasp, the corresponding frame is positioned above the palm,
in such a way it coincides with the center of a virtual object
that is typically manipulated with a full grasp, while for the
pinch grasp the corresponding frame is located where the
ﬁnger-tips join together.
The robot system, including the hand and the arm,
is thus described by the forward kinematic relation
T
b
o
(q
arm
,q
hand
) from the base to each object frame deﬁned,
along with the corresponding jacobian matrix.
Without loss of generality, frames have been cho-
sen to be independent of the hand conﬁguration (i.e.
T
b
o
(q
arm
,q
hand
),T
b
o
(q
arm
)). Subtler and smarter choices
involving the adjustment of the object frame locations de-
pending on the hand conﬁguration and the characteristics of
the objects to be grasped are deferred to future works, where
399

o
wrist
	 
b
object
	

o
envelope
	

o
pinch
	

o
pinched
	
q
hand
q
arm
?
u
pinch task
{w}
y[m
Fig. 3: By using synergies to deﬁne grasps, the wrist pose
(w.r.t. the object) must be speciﬁed explicitly. Object frames
(e.g.

o
pinch
	
and

o
envelope
	
) are used to deﬁne wrist
positioning. Depending on the object, more than one frame
can be deﬁned to provide reference for a speciﬁc grasp.
we will address the synthesis of grasping tasks rather than
just their description.
IV. ARM CONTROL: SPECIFICATION OF THE ARM
CONFIGURATION
Tasks are often speciﬁed with respect to only a single
frame attached to the robotic hand and a single frame on
the object to be grasped, and the constraints are therefore
applied to just one virtual kinematic chain. However, systems
that are inspired by human kinematics offer some degrees of
redundancy; in iTaSC (and similar frameworks) redundancy
translates in the possibility to execute additional tasks, in-
volving different parts of the robot. Such additional tasks
are executed in the null space of the primary task, such that
the execution of former does not inﬂuence the latter.
In addition, robotic systems have tasks related to the
preservation of their integrity, such as joint limit and ob-
stacle avoidance, as well as self-collision avoidance. In a
framework that allows for task prioritization, these tasks are
given the highest priority, and they are normally formulated
as inequalities. Therefore, they reduce the feasible space of
the solution.
On the other side, there are other tasks (scheduled at lower
priorities) that may support the execution of other tasks, e.g.
by maximising manipulability at one of the frames involved
in higher level tasks, or by mimicking human behaviour [11].
Several of these options exist, most of which are based on the
computation of functions involving the manipulator jacobian
(commonly applied to the object frame, and expressed in
some other reference frame), which, in turn, depends on the
robot conﬁguration. These scalar functions can be stacked
together in the function vector I(·) , and the corresponding
results in index vectori:
i =I(q). (12)
In order to impose the new constraints, eqs. (4) and (5) are
modiﬁed as follows:
y =C
i
I(q) +C
q
q +C
f
?
f
, (13)
˙ y =C
i

∂I(q)
∂q

˙ q +C
q
˙ q +C
f
˙ ?
f
, (14)
where C
i
is a selection matrix that selects which kind of
“behaviour” amongstI(q) is imposed.
V. PROPOSED SCENARIO
As a practical example we consider: (i) the grasp of
a cylindrical object (the glass), (ii) with a pinch grasp,
(iii) while maintaining maximum manipulability along the z-
axis, which coincides with the axis of the cylindrical object.
This task is executed in simulation, employing a seven dof
system (a Kuka LWR) equipped with an eight dof, three
ﬁngered robotic hand (a Schunk SDH). Each ﬁnger of the
hand has two joints, while the hand includes two additional
joints to rotate two ﬁngers w.r.t the wrist in order to achieve
wide grasps.
Speciﬁcation of the task requires the choice of object
frames and virtual kinematic chain (Sec. V-A), synergy
directions (Sec. V-B), and manipulability index (Sec. V-C).
A. wrist pose control
For the pinch grasp, the object frames between which the
virtual kinematic chain is built are

o
pinch
	
,

o
2
	
and

o
pinched
	
,

o
1
	
, attached to the hand and to the object,
respectively (see Fig. 4). The decision process on which
virtual kinematic chain is the most suited takes into account
the nature of the object and task, and whether it is necessary
(or not) to completely specify the pose of the hand. Having
chosen a cylindrical object, a cylindrical coordinate system is
most appropriate to describe the task. In this case the virtual
kinematic chain is built with the following choice of feature
coordinates:
?
f
= (h, ?, r, ?, ?, ?),
where h is the height along the cylinder axis, ? is the angle
in cylindrical coordinates, and r is the distance from the axis
of the cylinder. ?, ?, and ? are three generic angles, whose
rotations close the kinematic loop, as shown in Fig. 4.
Lacking the need to identify a preferential direction of
approach,? is left unconstrained; conversely, we impose that:
(i) the hand is directed toward the object axis, and with a
given orientation w.r.t. to the cylinder axis (three constraints),
(ii) the hand grasps the object between a minimum and
maximum height (h ? [?0.1,0.1]m), and (iii) the distance
r goes to zero (i.e. the origin of

o
2
	
belongs to the z-
axis of

o
1
	
). These speciﬁcations result in four equality
constraints, and two inequalities enforced the same output
(i.e. the height expressed relative to the cylinder axis).
B. The synergy function
Once the wrist is in the correct position, the ﬁngers are
brought into a given conﬁguration by: (i) computing the
desired joint (ﬁnger) positions, given the desired synergy
vector, and (ii) imposing these positions to each joint,
resulting in a total of eight constraints. Given the structure
400

f
1
	

f
2
	

f
3
	

o
1
	

o
2
	
{w}
T
o1
f1
(h)
T
f1
f2
(?)
T
f2
f3
(r)
T
f3
f4
(?)
T
f4
f5
(?)
T
f5
o2
(?)
T
o2
w
(q)
T
w
o1
(?
u
)
h[m
Fig. 4: Representation of the virtual kinematic chain used
for grasping a cylindrical object. It consists of a cylindrical
coordinate system, with ?
f
= (h,?,r,?,?,?). The ﬁgure
shows the object frames

o
pinched
	
,

o
1
	
and

o
pinch
	
,

o
2
	
and the ﬁrst three feature frames,

f
1
	
,

f
2
	
,

f
3
	
.
The other two feature frames,

f
4
	
,

f
5
	
, omitted for the
sake of clarity, have their origin in common with

o
2
	
.
Arrows with empty head represent transformations T(·),
that can be constant, (T
w
o1
), dependent on joint coordinates
(T
o2
w
(q)), or on feature coordinates (T
o1
o2
(?
f
)).
of the hand, the relation between synergies and joint angles
is given by the following equations:
q
hand
=
"
π/2 0 π/2 0 π/2 0 0 0
.
.
.
#
T
s+q
so
,Ss+q
so
,
(15)
where the synergy matrix base S is speciﬁed only for the
ﬁrst component (relative to the pinch grasp) that will be
actually used, for imposing the desired values
d
= [1, 0,···].
The desired synergy vectors
d
corresponds to a conﬁguration
where all ﬁngers are perpendicular to the wrist base. In (15)
the non-zero components are relative to the ﬁrst joints of
each ﬁnger.
C. The manipulability function
The speciﬁcation given in Sec. V-A involves some re-
dundancy (i.e. do not fully specify the conﬁguration) in the
positioning of the wrist (that can freely rotate along one axis,
and can translate along thez-axis of

o
1
	
between0.1m and
?0.1m), as well as in the joint space of the robot arm (the
robot is redundant, having seven joints).
Taking advantage of these unconstrained degrees of free-
dom, a low-priority constraint on manipulability is enforced:
for example, we consider the manipulability along a speciﬁc
direction with respect to the world frame, expressed in the
object frame used for grasping. This manipulability index
(m
i
) can be computed by intersecting the manipulability
ellipsoid in six dimensions with a speciﬁc axis, (e.g. ˆ z =
[0,0,1,0,0,0]). These manipulability indexes are expressed
along three axes as follows:
i?
?
?
1/m
2
x
1/m
2
y
1/m
2
z
?
?
=I(q) =
?
?
ˆ x
T
J
†T
r
J
†
r
ˆ x
ˆ y
T
J
†T
r
J
†
r
ˆ y
ˆ z
T
J
†T
r
J
†
r
ˆ z,
?
?
(16)
ˆ y
ˆ y
ˆ z
ˆ z
m
z
m
y

o
2
	
{w}
Fig. 5: Visual representation, on two dimensions, of the
manipulability ellipsoid. Manipulability along a speciﬁc di-
rection is measured by the coefﬁcient m that is obtained by
measuring the length of the vector between the intersection
of the manipulability ellipsoid with the given axis, and the
origin of the frame where the manipulability is measured.
where m
x
, m
y
, m
z
are the distances between the axis origin
and the intersection between the manipulability ellipsoid and
the unit vectors ˆ x, ˆ y, and ˆ z, respectively.J
†
r
corresponds to
the pseudo-inverse of the robot jacobianJ
r
. If the manipula-
bility analysis does not consider all robot joints to be equal,
a columnspace-weighted pseudo-inverse ofJ
r
can be used. A
graphical representation of these indexes is reported in Fig. 5.
As shown in (16), the manipulability indexes are the inverse
of the square value of the m
i
indexes: this choice allows to
maximize the indexm
i
by imposing the respective index ini
to be zero. In this application we would like to maximize the
manipulability in the z direction, thus the selection matrix
C
i
in eqs. (13) and (14) must be chosen accordingly.
D. Simulations
We present two simulations, each one divided in two
sequential actions: an approach motion that brings the object
frame

o
2
	
in a position where the constraints are fulﬁlled,
and a closing grasp sequence. In the two experiments we
compare the behaviour of the system when the manipulability
constraints are active or not. It is worth noticing that, when
redundancy is available, the solution algorithm minimizes the
modulus of the instantaneous joint velocity vector.
The most signiﬁcant data of the approach motion are
reported in Fig. 6. Fig. 6a shows that the behaviour of output
r is the same in both cases, and evolves as a ﬁrst order system
as governed by (8). This behaviour is expected, since the
constraint on distance is a high priority task, and no other
task is conﬂicting with it.
The same reasoning applies to the ﬁrst part of Fig. 6b:
the hand is constrained to stay within the length of the
cylinder (delimited by the two vertical dashed black lines),
and for this reason the height of the hand decreases on both
cases until the limit is met; then, in the experiment without
manipulability optimization, the movements parallel to this
axis practically stops, while, in the other case, the hand
reaches the lower limit while trying to bring the index i
z
as near as possible to zero.
The ﬁnal position of the wrist is different in both height
and approach angle, as shown in Fig. 7. Fig. 7a shows the
401
 
 
0.2
0.4
0.6
0.8
0
0 1 2 3 4 5 6 7 8
Time [s]
r [m]
m. off
m. on
[rad]
(a) distance from the the cylinder axis.
 
 
?0.2
0.2
0.4
0.6
0.8
0
0 1 2 3 4 5 6 7 8
Time [s]
h [m]
m. off
m. on
limits
(b) Height on the cylinder axis.
 
 
0
20
40
60
0 1 2 3 4 5 6 7 8
Time [s]
iz
m. off
m. on
(c) Manipulability index iz = 1/(mz)
2
.
Fig. 6: Comparison between some of the outputs recorded
in the two simulations; the red solid line and dash-dotted
blue line refer to the simulation without and with the
manipulability optimization, respectively.
(a) Constraint on manipulability
active.
(b) Constraint on manipulability
not active.
Fig. 7: Final pose of the robot in the two simulations.
arm conﬁguration that maximizes the manipulability along
the z-axis.
In the second part of the movement, the hand closes. The
ﬁrst element of the synergy vector is brought from 0 to 1 in
10s, following a ramp; the three base angles, that are linearly
related to it, follow the same behaviour, as reported in Fig. 8.
Since the hand closing is not inﬂuenced by the presence of
the manipulability constraint, the executions are identical in
both experiments.
VI. CONCLUSION
This paper has shown how to employ iTaSC to describe
manipulation tasks. This paper focused on reaching move-
ment followed by a pinch grasp, but the same general criteria
discussed in the ﬁrst part can be applied to many other tasks.
We pointed out how a grasping task can be expressed in a
speciﬁcally chosen frame, as in [10], but the same concepts
can be extended from the task frame formalism to iTaSC.
 
 
?0.5
?0.5
?1
?1
?1.5
?1.5
0
0
10 12 14 16 18 6 8
Time [s]
m. off [rad] m. on [rad]
qhand(1)
qhand(3)
qhand(5)
Fig. 8: Hand closing motion. the positions of ﬁnger joints
positions are reported. While the value of the ﬁrst element
of the synergy vector is swept from 0 to 1, the base ﬁnger
joints changes from ?π/2 to 0. The other ﬁve joints, not
reported here, are constantly zero.
Moreover, we have illustrated how joint space constraints,
like synergies and manipulability indexes, can be easily
brought into the task speciﬁcation. In particular, we treated
in a different way constraints that fully describe the desired
pose, the synergy vector, and constraints that work in the null
space of other constraints, like the proposed manipulability
constraint.
In the discussion we omitted some details about the actual
implementation: we omitted to report, for example, velocity
and position joint’s limits. Moreover, we did not take into
account real physical interaction, limiting our investigation
on the positioning problem, and leaving these aspects for
future work.
REFERENCES
[1] C. C. Kemp, A. Edsinger, and E. Torres-Jara, “Challenges for Robot
Manipulation in Human Environments,” IEEE Robotics & Automation
Magazine, vol. 14, no. March, pp. 20–29, 2007.
[2] N. Mansard, O. Khatib, and A. Kheddar, “A uniﬁed approach to
integrate unilateral constraints in the stack of tasks,” Robotics, IEEE
Transactions on, vol. 25, no. 3, pp. 670–685, 2009.
[3] O. Khatib, “A uniﬁed approach for motion and force control of robot
manipulators: The operational space formulation,” IEEE Journal on
Robotics and Automation, vol. 3, no. 1, pp. 43–53, Feb. 1987.
[4] M. T. Mason, “Compliance and force control for computer controlled
manipulators,” Systems, Man and Cybernetics, IEEE Transactions on,
vol. 11, no. 6, pp. 418–432, 1981.
[5] T. Kr¨ oger, B. Finkemeyer, and F. M. Wahl, “A task frame formalism
for practical implementations,” in Proc. of the IEEE International
Conference on Robotics and Automation, New Orleans, LA, USA,
April 2004, pp. 5218–5223.
[6] J. De Schutter, T. De Laet, J. Rutgeerts, W. Decre, R. Smits, E. Aertbe-
lin, K. Claes, and H. Bruyninckx, “Constraint-based task speciﬁcation
and estimation for sensor-based robot systems in the presence of
geometric uncertainty,” International Journal of Robotic Research,
vol. 26, no. 5, pp. 433–455, 2007.
[7] D. Berenson, R. Diankov, K. Nishiwaki, S. Kagami, and J. Kuffner,
“Grasp planning in complex scenes,” in Humanoid Robots, 2007 7th
IEEE-RAS International Conference on, 2007, pp. 42–48.
[8] M. Santello, M. Flanders, and J. F. Soechting, “Postural Hand Syner-
gies for Tool Use,” The Journal of Neuroscience, vol. 18, no. 23, pp.
10 105–10 115, Dec. 1998.
[9] M. Ciocarlie and P. Allen, “Hand posture subspaces for
dexterous robotic grasping,” The International Journal of Robotics
Research, vol. 28, pp. 851–867, 07/2009 2009. [Online]. Available:
http://ijr.sagepub.com/cgi/reprint/28/7/851
[10] M. Prats, A. P. D. Pobil, and P. J. Sanz, Robot Physical Interaction
through the combination of Vision, Tactile and Force Feedback -
Applications to Assistive Robotics, ser. Springer Tracts in Advanced
Robotics. Springer, 2013, vol. 84.
[11] A. Zanchettin, P. Rocco, L. Bascetta, I. Symeonidis, and S. Peldschus,
“Kinematic analysis and synthesis of the human arm motion during a
manipulation task,” in Robotics and Automation (ICRA), 2011 IEEE
International Conference on, 2011, pp. 2692–2697.
402
