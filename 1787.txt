Forage RRT - An Efﬁcient Approach To Task-Space Goal Planning for High
Dimensional Systems
Leo Keselman
School of ECE
Georgia Institute of Technology
L.D.Keselman@gmail.com
Erik Verriest
School of ECE
Georgia Institute of Technology
erik.verriest@ece.gatech.edu
Patricio A. Vela
School of ECE
Georgia Institute of Technology
pvela@ece.gatech.edu
Abstract— Achieving efﬁcient end-effector planning for ma-
nipulators in real world workspaces is challenging due to the
fact that planning is performed in manipulator joint space,
while the planning goal is given in end-effector or tool space. For
manipulator planning, the problem becomes a joint path plan-
ning and inverse kinematics problem to be resolved efﬁciently,
in spite of the potentially inﬁnite number of inverse solutions
to the end-effector goal state and the nonlinear relationship
between joint conﬁgurations and world obstacles. The Forage-
RRT algorithm described in this paper attempts to efﬁciently
and quickly resolve the end-effector or tool planning problem.
Using ideas from foraging theory, Forage-RRT implements a
diffusion-based search strategy with two rates of diffusion, one
high and one low, which simulate both long jumps (coarse
search) and focused small area exploration (ﬁne search) in the
joint space, respectively. During coarse search, it is important
to keep track of past ﬁne searches, therefore the traditional
RRT algorithm is augmented with a goal heap that keeps
track of potential focused search regions and discards them
when they result in failure. By mixing between two search
distributions with different spreads, the search space is rapidly
covered and potentially fruitful avenues are ﬁnely explored.
The search coverage advantages of foraging identiﬁed in the
biological research literature are demonstrated here for end-
effector based, manipulator path planning.
I. INTRODUCTION
Task-based, manipulator motion planning algorithms seek
to automatically and quickly ﬁnd a collision-free path in a
general environment between any given initial joint conﬁg-
uration (usually modeled by R
m
where m is the degrees
of freedom of all the joints) and a goal point speciﬁed in
end-effector or task space (a subspace of SE(3)). Here, the
goal is speciﬁed in end-effector space because it is almost
always the end-effector (or tool) which interacts with the
object to be manipulated. The speciﬁc conﬁguration of the
ﬁnal joint conﬁguration is usually not important so long as
it is not in collision with workspace obstacles. Examples
of end effector tools which interact with objects include
hands, magnets, suction cups, paint sprayers, and welders.
Any practical manipulator planner has to convert the given
initial information into a trajectory fully residing in joint
space and meeting existing collision constraints.
The literature consists of two main approaches to solving
the task-space planning problem: solve for the end-effector
goal directly using inverse kinematics or incorporate the
search for the end-effector goal into planning. Solving for
a feasible inverse kinematics is difﬁcult due to the need
to identify a goal joint conﬁguration with collision-free
connectivity to the initial joint conﬁguration. To date, there
is not an inverse kinematics algorithm for general n-link
manipulators which is complete, fast, and returns a conﬁgura-
tion guaranteed to be reachable from the start conﬁguration.
Were it to exist, then the task-space planning problem would
be converted into a joint-space planning problem with task-
space obstacle constraints. An efﬁcient solution would then
be the bidirectional RRT [1], which is in the class of Rapidly-
Exploring Random Tree (RRT) algorithms, or any other
solution known to be fast (see xII).
a) Problem Statement: This paper tackles the second
approach to task-space planning. An initial state is given
in joint space with the goal state given as an end-effector
conﬁguration, either position only or position and orientation.
The only assumptions are that the manipulator model is
known (enough to calculate a Jacobian) and that the world
can be queried to see if a given manipulator conﬁguration
produces a collision. The task-space motion planner for
(redundant) manipulators should be complete, single-query,
and reliably fast for all reasonable problems posed.
b) Contribution: The proposed solution, Forage-RRT,
is an RRT algorithm with multiple diffusion rates and a
greedy, goal-directed phase. The main idea behind Forage-
RRT is to explore the manipulator space quickly with a
large step-size RRT (high diffusion rate) and then attempt
to connect to the goal using a small step-size RRT (low
diffusion rate) from promising nodes in the large step-
size RRT. The algorithm alternates between the high and
low diffusion rate modes. To enable sensible greedy, goal-
directed searches, the RRT is augmented with a task-space
goal heap (RRT+GH), which orders the RRT joint space
conﬁgurations via a heuristic score. The ordering determines
which node will be used to initiate the greedy search.
Promising coarse step-size tree nodes are selected, removed
from the goal heap, then used to initialize a small step-size
RRT search. Forage RRT lends itself to parallel (or multi-
core) implementation by running several low-diffusion rate
searches simultaneously. We show that Forage-RRT provides
competitive average planning times that are further improved
through parallelization. The result is a reliable planner which
is fast and consistent at solving a potentially wide range of
manipulation problems in environments with obstacles.
2014 IEEE International Conference on Robotics & Automation (ICRA)
Hong Kong Convention and Exhibition Center
May 31 - June 7, 2014. Hong Kong, China
978-1-4799-3684-7/14/$31.00 ©2014 IEEE 1572
c) Organization: The paper presents previous work we
extend as well as other approaches to the same problem
(xII), an analysis of the shortcomings of the RRT in bug-
trap problems (xIII), the implementation of the Forage-RRT
algorithm (xIV), experiments and results compared to other
planners having the same problem statement (xV), and ﬁnally
a discussion of possible improvements to Forage-RRT (xVI).
II. RELATED WORK
Achieving tractable, complete motion planning for high
dimensional systems such as (redundant) manipulators in
general work environments present several challenges. Al-
gorithms to resolve the high-dimensional aspect have been
the ﬁrst to arise. One of the most famous and most cited
approaches is the Artiﬁcial Potential Field Method [2].
Although fast enough to be used in a single query planner, it
depends on obstacles being of a simple geometry and suffers
from several fundamental issues such as getting stuck in
local minima, no passage between closely spaced obstacles,
and oscillations in certain conditions [3]. Attempts have
been made to solve these issues by the formulation of new
potential functions [4], [5], however, these functions either
take prohibitively long to compute or do not resolve all of
the aforementioned pitfalls.
Ariadne’s Clew Algorithm [6] approximates the feasible
joint space via sampling. It uses an explore-search ap-
proach to achieve resolution completeness and was shown
to be respectably fast for most problems. Algorithms based
on probabilistic roadmaps [7] use sampling to generate a
roadmap for multi-query problems which allows subsequent
path planning problems to be solved efﬁciently. Because
the roadmap pre-processing step has a baseline overhead,
it is not optimal for our stated goal of a single query
planner for general environments. Within the category of
efﬁcient resolution-complete sampling based algorithms, the
Rapidly-Exploring Random Tree (RRT) family is popular
and effective at solving many high dimensional planning
problems [1], [8]. For manipulation, standard RRTs depend
on start and goal states given in joint space. This bidirectional
version [1], which grows two trees (sometimes randomly,
sometimes toward each other), is effective in solving bug-
trap problems. Since goals are most often not speciﬁed in
joint space for manipulation problems, a method for ﬁnding
inverse kinematics algorithms to transform the goal state
into joint space is ﬁrst needed [9], [10], [11], [12]. None of
these inversion algorithms are complete and guaranteed to be
reachable from the start conﬁguration. An inverse kinemat-
ics approach that was guaranteed to return a conﬁguration
reachable from start was presented in [13].
When the planning problem also incorporates the inverse
kinematics problem as part of it, then the inverse kinematics
solution will be resolution complete (given that sampling is
uniform over the workspace) and guaranteed reachable from
the start. In [14], the RRT search is biased to be around the
existing nodes which were closest in end-effector space to
goal. Signiﬁcant speed improvements to the biased search
were achieved by using the Jacobian transpose or Jacobian
pseudo-inverse to take steps in the direction of the goal from
existing nodes [15], [16]. Including such a bias is susceptible
to getting stuck when the goal is occluded by an obstacle
(similar to a bug-trap). Other RRT modiﬁcations include
growing an additional end-effector space tree which is then
used to guide the growth of the joint space tree [17], [18].
The former, [17], grows the end-effector space tree from the
goal in a bidirectional-type approach whereas the latter, [18],
creates end-effector paths from start to goal. Both approaches
struggle to ﬁnd solutions quickly in bug-trap problems.
Like the proposed approach, multi-resolution planners
have the property of working at multiple spatial scales [19],
[20], [21], [22], [23], [24]. These approaches are typically
implemented for mobile robots and are part of a conﬁguration
space cell decomposition strategy, limiting their effectiveness
in high-dimensional planning problems where cell decompo-
sitions are infeasible. As far as we know, no multi-resolution
approach has yet been considered for the RRT.
Parallelization of motion planners is a common strategy
for improving execution times. Sampling based planners lend
themselves to improvement via parallelization. The fact that
the planning time from one run to the next can vary quite
dramatically means executing multiple runs simultaneously
can greatly improve performance by picking the fastest of
a number of runs. This idea has been applied to RRTs and
other motion planners [25], [26], [27], [28], [29], [30].
III. RRT AND THE BUG-TRAP PROBLEM
Figure 1 shows an example of a uni-directional RRT
attempting to solve a problem where the goal is occluded by
an object. The state of the RRT is shown after 12 iterations
of the extend operation (with the probability of taking a step
to goal being 35%). At this state of the tree, two problems
emerge in our quest to connect the tree to the goal node:
1) Future attempts to step to goal will be taken from
the red node since it is closest. All attempts will fail
because there is an obstacle in the way. They are a
waste of time.
2) To reach the goal, the RRT will have to reach the
semicircle around the goal only through random steps.
Nodes outside of this area will be either further
than the red node or obstructed by the obstacle. The
probability of this happening quickly is very low, as
doing so requires that random conﬁgurations to extend
to are consistenly in the bottom right corner of the
workspace.
  
Fig. 1. An RRT attempting a bug-trap problem.
1573
Fast RRTs tend to approach the goal in a directed fashion,
but are blocked by bug-trap type situations. RRTs rely on
diffusion through random walks to go around obstacles,
which is a slow process for low probability situations.
IV. FORAGE RRT IMPLEMENTATION
The Forage-RRT algorithm utilizes ideas from the biologi-
cal foraging literature where it is shown that a multi-diffusion
rate process lowers the mean time to passage for foraging
problems [31], [32]. The foraging problem is the problem
of ﬁnding a reward that has low probability of occurence
in a large space (with a penalty imposed on movement and
searching). The foraging process model is a search process
that has two diffusion rates (high and low), that result in two
modes of search, or at least two distinct movement types
1
(far and near, respectively). By alternating between the two,
search for an unknown goal state in a large search space is
faster than traditional diffusion-based search, and covers a
larger region versus greedy searches. Each movement mode
is also characterized as having a speciﬁc cost: low for the
high diffusion rate (far mode) and high for low diffusion
rate (near mode). These costs are typically associated to the
attention or energy given to search versus movement.
Forage-RRT replicates this idea within the context of our
problem statement. The high diffusion rate mode utilizes
a coarse step-size RRT algorithm, with low probability of
goal seeking, and is akin to an exploration phase. The low
diffusion rate mode attempts to connect a node from the
coarse tree to the goal via a ﬁne step-size RRT algorithm with
a high probability of greedy goal seeking. The two RRTs
have parameters chosen to replicate the low/high attention
characteristics found in foraging. The RRT in the ﬁne-
step/high-attention is more guided to the goal and will also
more often use the manipulator Jacobian to move. The effect
of this approach for bug-trap type problems is to solve the
problem presented in Section III by using the coarse step-
size tree to cover joint space in search of promising approach
directions to the goal, then using the ﬁne step-size tree to
avoid any small occlusions on the path to the goal.
A. Goal Heap
An inefﬁciency in the basic RRT algorithm is that unsuc-
cessful steps to goal may be taken consistently from the same
node because that node is the closest to goal, as illustrated
in xIII. Our solution is to implement a goal heap. When
new nodes are added to the RRT, they are also added to the
goal heap based on a score (some heuristic that evaluates the
ﬁtness of the joint state with regards to proximity to goal). In
our case, the score of a node is the inverse of its Euclidean
distance to goal position. The heap data structure orders the
nodes by value so that the top of the heap is the highest value
node. Once a step to goal is attempted from a node, that node
is removed from the goal heap because using it again for a
step to goal would be a fruitless endeavor. While the goal
heap can apply to any RRT implementation, it is essential
1
Some researchers prefer to use a single, heavy-tailed distribution to
generate the two movement types [33].
for the Forage RRT because the heap provides a node in the
coarse tree to use when attempting a ﬁne step-size J+RRT
to connect to goal.
B. RRT Extend Implementations
Both coarse and ﬁne RRT implementations use the J+RRT
algorithm [15] with the proposed goal heap augmentation
(J+RRT+GH). Random extensions of the search tree use the
standard extension procedure of picking a random point in
joint space and taking a step towards it from the nearest
neighbor already in the tree. Goal-directed extensions use
the Moore-Penrose pseudo-inverse Jacobian to take a step.
The overall extend implementation is shown in Algorithm 1.
d) Coarse versus ﬁne search: The coarse search should
focus more on rapidly exploring the space rather than seeking
the goal. This is done by lowering the probability of stepping
to goal in the coarse J+RRT+GH implementation, which also
lowers the exploration cost. Since the coarse J+RRT+GH
takes large step sizes, for each node extension, the link
between the new node and its parent must be checked for
validity by iterating through its length at an acceptable
resolution and making sure each smaller step is valid. In
contrast, the ﬁne search should focus on exploring a small
region with a greater intent to ﬁnd the ﬁnal goal state.
The ﬁne J+RRT implementation has a higher probability
of stepping to goal. For the ﬁne step-size J+RRT+GH, we
assume that if the new node is valid, then the path connecting
the parent node to the new node is also valid.
C. Foraging: Alternating Between Explore and Search
The Forage RRT algorithm is found in Algorithm 2. The
ﬁrst while loop initially explores the space and builds up
several promising nodes to initialize the ﬁne searches with.
The second while loop searches by attempting to connect
the promising nodes from the coarse step-size tree to the
goal with a ﬁne step-size tree. Once a ﬁne step-size RRT
experiences a certain number of collisions, it terminats and
start anew from the next most promising node. After a given
number of ﬁne step-size searches fail, grow the coarse step-
size tree (e.g., return to explore mode) to replenish the
heap with promising start nodes. The ﬁnite time search with
restarts from alternative promising nodes allows the ﬁne step-
size RRT to be greedy, making it fast in easy situations but
also robust to more challenging situations. A full list of the
parameters used is given in Section V.
Once the ﬁne step-size RRT has reached the goal, the
found path is obtained by tracing to the root of the ﬁne
step-size tree, which is a node in the coarse step-size tree,
then tracing to the root of the coarse step-size tree. Due to
the mixed step-size RRTs, the raw ﬁnal plan will not be
attractive, especially near the start. For this purpose, path
smoothing is required to make the path acceptable. This is
done in a quick manner by taking pairs of nodes, attempting
to connect them with a straight line, and deleting all nodes
in between if successful. Empirically, we have found that
picking a node from the coarse step-size plan and trying to
connect it to the ﬁne step-size plan works well. The second
1574
Data: RRT;goal;StepSize
Result: UpdatedRRT;StepResult
 random([0;100]);
if <randomExtendProbability then
x
rand
 RANDOM STATE();
xnear NEAREST NODE(x
rand
;RRT);
xnew TAKE STEP(x
rand
;xnear;StepSize);
if isLegalPath(xnear;xnew) then
RRT addVertex(xnew);
RRT addEdge(xnear;xnew;StepSize);
NodeValue value(xnew);
GoalHeap insert(xnew;NodeValue);
if xnew =x
randomConfig
then
returnSTEP REACHED;
else
returnSTEP PROGRESS;
end
else
returnSTEP COLLISION;
end
else
xnear GoalHeap!top;
xnew JAC STEP(xnear;goal;StepSize);
if isLegalPath(xnear;xnew) then
RRT addVertex(xnew);
RRT addEdge(xnear;xnew;StepSize);
if xnew =goal then
returnGOAL REACHED;
else
NodeValue value(xnew);
GoalHeap insert(xnew;NodeValue);
GoalHeap remove(xnear);
returnSTEP PROGRESS;
end
else
GoalHeap remove(xnear);
returnSTEP COLLISION;
end
end
Algorithm 1: J+RRT+GH Extend Operation
step is to go through remaining coarse steps and subdivide
them into the desired step size to match the rest of the path.
We have found that 15-20 successful smoothing steps result
in a smooth path. The computational cost for path smoothing
is low compared to the path planning procedure.
D. Parallel Implementation
The two search strategies in Forage-RRT are parelleliz-
able. For a Master-Worker parallel implementation, the steps
are:
 Initial Step: Grow coarse step-size tree to an initial
size greater than the number of threads to be used.
 Worker Threads: Grow a ﬁne step-size tree to goal
with a seeded start conﬁguration from the coarse step-
size tree. Terminate upon success or when a certain
number of collisions occur.
 Master Thread: 1) Grow coarse step-size RRT; 2)
Maintain worker threads by seeding them with the best
available node from coarse step-size RRT when they
terminate without success.
Data: start, goal
Result: path from start to goal
CoarseRRT INIT(largeStepSize;start;goal);
while CoarseRRT!size<initialSize do
CoarseRRT!EXTEND();
end
while result6=GOAL REACHED do
numFailures 0;
FineRRT INIT(fineStepSize;CoarseRRT!
GoalHeap!top);
while numCollisions<maxNumCollisions do
FineRRT!EXTEND();
end
increment numFailures ;
if numFailures = maxNumFailures then
for 1:percentIncrease*initialSize do
CoarseRRT!EXTEND();
end
end
end
Algorithm 2: Forage-RRT
V. EXPERIMENTS AND EVALUATION
A. Experiments
1) Sequential Implementation: Experiments were con-
ducted on a Schunk 7 DOF arm with the DART/GRIP
simulator (developed by the GOLEMS lab at Georgia Tech)
on a 2.27GHz, 8 core machine. We compared the following
algorithms to the path-smoothed Forage-RRT:
1) RRT-JT [16]
2) J+RRT with goal directed steps [15]
3) BiSpace RRT [17]
4) Kinematic Roadmap [13]. The paths produced from
this algorithm are too long to be used for most appli-
cations. Rather, the inverse kinematics solution, which
is guaranteed to be reachable from start, would be used.
The smoothing time was included in Forage RRT results
but not for the other results because the paths produced
did not strictly require it. Moreover, any RRT reaching
10,000 nodes was restarted to improve the average planning
time of all planners (empirically when an RRT grows too
large, it will have trouble connecting to the goal, so it
is better to restart). The Forage-RRT parameters used for
testing are given in Table I (with common parameters for
the other algorithms equaling those from the table). These
parameters were arrived at empirically and are not guaranteed
to be perfect. The largeStepSize and ﬁneStepSize deﬁne
the magnitude of a step in expanding the tree. For goal
directed moves it is a Euclidian distance whereas for random
expansion it is a magnitude in joint space.
Each algorithm was tested on an easy, medium, and hard
case. Figure (2) depicts the cases. The goal is the point
where the three shown faces of the gold and blue cube meet.
50 random collision-free start conﬁgurations were computed
for each case (easy, medium, and hard) and the same 50
start conﬁgurations were used for each algorithm. Each start
conﬁguration was the seed for 40 runs (totaling 2000 runs
per algorithm per case). In the interest of time, a run was
1575
(a) Easy case for testing. (b) Medium case for testing. (c) Hard case for testing.
Fig. 2. Depiction of different test cases. Easy has no obstacles, medium has obstacles, and hard has a goal directly under obstacle, near edge of workspace.
TABLE I
FORAGE RRT PARAMETERS.
initialSize 50 nodes
randomExtendProbability - coarse 90 %
randomExtendProbability - ﬁne 65 %
largeStepSize 1.3
ﬁneStepSize .02
maxNumCollisions 5 collisions
maxNumFailures 10 collisions
percentIncrease .25
TABLE III
PARALLEL (4 CORE) PLANNING RESULTS. ALL TIMES IN SECONDS.
Case: easy Medium Hard Average
Avg. Time: .69 1.00 2.59 1.43
considered a failure if the RRT had to be restarted 25 times
and no solution was found (such a run would have taken
400-600 seconds so it should be penalized).
2) Parallel Implementation: Experiments were conducted
on the same cases as the sequential Forage-RRT. The par-
allel implementations were tested for 10 precomputed start
conﬁgurations per case, at 40 runs per start conﬁguration (a
total of 400 runs). The implementation was tested with one
to six worker threads.
B. Evaluation
1) Sequential Implementation: The results of the sequen-
tial implementation simulation are shown in Table II. The
reported times are averaged over completed cases only.
For all cases, the Forage-RRT provided the lowest average
completion time and also maintained a 100% completion rate
for the tasks.
2) Parallel Implementation: The results of the parallel im-
plementation for the tested number worker threads are shown
in Figure 3. The decline in search time is sub-linear. Because
the solution is often found in the ﬁrst few attempts to connect
to goal from the coarse RRT, we hypothesize that additional
threads beyond a certain amount initiate ﬁne searches that
are not needed. For our experiments, the results imply that
improvements after four working threads would be minimal.
The best average planning times achieved with the parallel
implementation are summarized in Table III and apply to the
case when four worker threads were implemented.
  
0(Serial) 1 2 3 4 5 6
0
1
2
3
4
5
6
7
8
Forage RRT Parallel Results
Easy Case
Medium Case
Hard Case
Average
Number of Extra Cores
Av. Planning Time (s)
Fig. 3. Average planning times per number of extra cores used.
Fig. 4. End-effector positions for an initial coarse RRT.
VI. DISCUSSION
The beneﬁts of Forage-RRT arise from the two different
diffusion rates associated to the two RRT implementations.
For the purpose of visualization, the end-effector positions
of a sample, initial coarse RRT are shown in Figure 4.
The green node is the start and the red node is the goal.
The closest nodes to the goal come from many different
directions, making the ﬁne RRTs more likely to be effective.
a) Completeness: From [8], any RRT is resolution
complete because its coverage of the workspace converges
to the sampling distribution. Because the coarse RRT in the
Forage-RRT algorithm searches uniformly and indeﬁnitely,
the Forage-RRT is also resolution complete. Needless to say,
it is highly unlikely in practice that the coarse step-size tree
will be the one to come upon the goal.
1576
TABLE II
SEQUENTIAL EXPERIMENT RESULTS. ALL TIMES IN SECONDS.
Algorithm Easy Avg % Comp Med Avg % Comp Hard Avg % Comp
Forage RRT 2.92 100 3.01 100 7.52 100
RRT-JT 12.12 93.7 30.51 82.7 62.62 29.0
J+RRT 4.45 96.9 21.42 92.0 65.92 53.6
BiSpace RRT 4.57 100 21.94 99.96 36.87 80.6
ACA IK 5.22 100 4.72 100 22.21 100
b) Parameters: The Forage RRT parameters leading to
the results in Table II are given in Table I. These parameters
were arrived at empirically by running a few test cases,
and are not guaranteed optimal. It may be of interest to
investigate optimal values for these parameters, for instance
when to switch from ﬁne to coarse search. Perhaps there
should be a heuristic function rather than a hard constraint on
failures. Moreover, parameters such as initial coarse tree size
and the coarse step-size are good candidates for learning over
time. The ideal parameters values depend on environmental
factors such as obstacle density and obstacle geometry.
c) Narrow Passage Problem: Planning through nar-
row passages is a challenge for RRTs and sampling based
planners. The algorithm presented here inherits the same
weakness. The ﬁne step-size RRTs which attempt to reach
goal are biased in the goal’s direction. If the narrow passage
is in a different direction, it is highly unlikely that a path
will be found in a reasonable time.
VII. CONCLUSION
We have presented the Forage-RRT algorithm for mo-
tion planning. The premise behind the algorithm is that
a foraging-based search algorithm provides an excellent
compromise between diffusion-based searching (via random
samples) and greedy search (goal-directed movements) in
single-query, task-based, manipulator planning algorithms.
The effectiveness of the method has been shown through
randomized trials on scenarios with variable difﬁculty.
d) Acknowledgments: This work was supported in part
by the National Science Foundation (ECS-0238993).
REFERENCES
[1] S. LaValle and J. Kuffner Jr., “Rapidly-exploring random trees:
Progress and prospects,” 2000.
[2] O. Khatib, “Real-time obstacle avoidance for manipulators and mobile
robots,” IJRR, vol. 5, no. 1, pp. 90–98, 1986.
[3] Y . Koren and J. Borenstein, “Potential ﬁeld methods and their inherent
limitations for mobile robot navigation,” in ICRA, 1991, pp. 1398–
1404.
[4] C. Connolly, J. Burns, and R. Weiss, “Path planning using Laplace’s
equation,” in ICRA, 1990, pp. 2102–2106.
[5] S. Ge and Y . Cui, “New potential functions for mobile robot path
planning,” IEEE Trans. Rob. Aut., vol. 16, no. 5, pp. 615–620, 2000.
[6] P. Bessiere, J. Ahuactzin, and E. Talbi, E.G.and Mazer, “The Ariadne’s
clew algorithm: global planning with local methods,” in IEEE/RSJ
IROS, vol. 2, 1993, pp. 1373–1380.
[7] N. M. Amato and Y . Wu, “A randomized roadmap method for path
and manipulation planning,” in ICRA, vol. 1, 1996, pp. 113–120.
[8] S. LaValle, “Rapidly-exploring random trees a new tool for path
planning,” 1998.
[9] P. Chang, “A closed-form solution for inverse kinematics of robot
manipulators with redundancy,” IEEE J. Rob. Aut., vol. 3, no. 5, pp.
393–403, 1987.
[10] A. Goldenberg, B. Benhabib, and R. Fenton, “A complete generalized
solution to the inverse kinematics of robots,” IEEE J. Rob. Aut., vol. 1,
no. 1, pp. 14–20, 1985.
[11] A. Guez and Z. Ahmad, “Solution to the inverse kinematics problem
in robotics by neural networks,” in IEEE ICNN, 1988, pp. 617–624.
[12] J. Parker, A. Khoogar, and D. Goldberg, “Inverse kinematics of
redundant robots using genetic algorithms,” in ICRA, 1989, pp. 271–
276.
[13] J. Ahuactzin and K. Gupta, “The kinematic roadmap: A motion
planning based global approach for inverse kinematics of redundant
robots,” IEEE Trans. Rob. Aut., vol. 15, no. 4, pp. 653–669, 1999.
[14] D. Bertram, J. Kuffner, R. Dillmann, and T. Asfour, “An integrated
approach to inverse kinematics and path planning for redundant
manipulators,” in ICRA, 2006, pp. 1874–1879.
[15] N. Vahrenkamp, D. Berenson, T. Asfour, J. Kuffner, and R. Dill-
mann, “Humanoid motion planning for dual-arm manipulation and
re-grasping tasks,” in IEEE/RSJ IROS, 2009, pp. 2464–2470.
[16] M. Vande Weghe, D. Ferguson, and S. Srinivasa, “Randomized path
planning for redundant manipulators without inverse kinematics,” in
HUMANOIDS, 2007, pp. 477–482.
[17] R. Diankov, N. Ratliff, D. Ferguson, S. Srinivasa, and J. Kuffner,
“Bispace planning: Concurrent multi-space exploration,” in Proc. of
RSS, vol. 63, 2008.
[18] Z. Yao and K. Gupta, “Path planning with general end-effector
constraints: Using task space to guide conﬁguration space search,”
in IEEE/RSJ IROS, 2005, pp. 1875–1880.
[19] R. A. Brooks and T. Lozano-Perez, “A subdivision algorithm in
conﬁguration space for ﬁndpath with rotation,” IEEE Trans. SMC,
vol. 15, no. 2, pp. 224–33, 1982.
[20] D. Zhu and J.-C. Latombe, “New heuristic algorithms for efﬁcient
hierarchical path planning,” IEEE Trans. Rob. Aut., vol. 7, no. 1, pp.
9–20, 1991.
[21] D. K. Pai and L.-M. Reissell, “Multiresolution rough terrain motion
planning,” IEEE Trans. Rob. Aut., vol. 14, no. 1, pp. 19–33, 1998.
[22] S. Kambhampati and L. S. Davis, “Multiresolution path planning for
mobile robots,” IEEE J. Rob. Aut., vol. 2, no. 3, pp. 135–145, 1986.
[23] S. Behnke, “Local multiresolution path planning,” in Robocup 2003:
Robot Soccer World Cup VII. Springer, 2004, pp. 332–343.
[24] P. Tsiotras and E. Bakolas, “A hierarchical on-line path-planning
scheme using wavelets,” in ECC, 2007.
[25] E. Plaku, K. E. Bekris, B. Y . Chen, A. M. Ladd, and L. E. Kavraki,
“Sampling-based roadmap of trees for parallel motion planning,” IEEE
Trans. Rob., vol. 21, no. 4, pp. 597–608, 2005.
[26] I. Aguinaga, D. Borro, and L. Matey, “Parallel rrt-based path planning
for selective disassembly planning,” Int. J. of Adv. Man. Tech., vol. 36,
no. 11-12, pp. 1221–1233, 2008.
[27] S. Sengupta, “A parallel randomized path planner for robot naviga-
tion.” Int. J. of Adv. Rob. Sys., vol. 3, no. 3, 2006.
[28] J. Bialkowski, S. Karaman, and E. Frazzoli, “Massively parallelizing
the RRT and the RRT,” in IEEE/RSJ IROS. IEEE, 2011, pp. 3513–
3518.
[29] D. Devaurs, T. Sim´ eon, and J. Cort´ es, “Parallelizing RRT on
distributed-memory architectures,” in ICRA, 2011, pp. 2261–2266.
[30] S. Carpin and E. Pagello, “On parallel rrts for multi-robot systems,”
in Proc. Conf. Italian Assoc. Art. Int., 2002, pp. 834–841.
[31] K. M. Passino, Biomimicry for Optimization, Control, and Automation.
Springer, 2005.
[32] M. Moreau, O. B´ enichou, C. Loverdo, and R. V oituriez, “Chance and
strategy in search processes,” J. Stat. Mech., p. P12006, 2009.
[33] M. Plank and A. James, “Optimal foraging: L´ evy pattern or process?”
J. R. Soc. Interface, vol. 5, no. 26, pp. 1077–1086, 2008.
1577
