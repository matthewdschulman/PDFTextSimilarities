Timed Automata Based Motion Planning for a Self-assembly Robot
System*
Rui Wang
1
, Ping Luo
1
, Yong Guan
1
, Hongxing Wei
2
, Xiaojuan Li
1
Jie Zhang
3
, Xiaoyu Song
4
Abstract? Sambot is a module robot system, with the ad-
vantages of self-assembly. A target robotic conguration can
be organized by a group of Sambots. A novel motion planning
method for Sambot conguration using model checking is
presented in this paper. This hierarchical method contains
two layers. The abstract logic layer is responsible for the
discrete planning of Sambots conguration. The robot and
the environment are all modeled as timed automata. System
requirements are formalized as Computational Tree Logic
(CTL) formulas. Model checking is applied on the system
model. The verication result gives the optimal discrete plans
for the conguration of Sambot. In physical layer, a sample-
based planner generates the trajectory trace considering the
dynamics of Sambot and the suggested high level plans. The
experiment results illustrate the effectiveness of our approach.
I. INTRODUCTION
Distributed multi-robot systems have become an attrac-
tive eld of research in the robotics community. Sambot
[1], [2] is a multi-robot system developed by the Beihang
University of China. Sambot can organize a group of robot
modules into a target robotic conguration without human
intervention. Similar to the swarm behavior of social insects
[3], self-assembly is the process by which a group of smart
components autonomously organize into congurations or
structures [4]. Sambots have the advantages of both swarm
robots and modular robots.
The correctness of a system plays a critical role in high
dependability. Formal methods are an important means for
analyzing and ensuring the reliability of complex systems.
Model checking has proved to be a powerful automatic
verication technique [5]. It has been successfully applied
to hardware design and the verication of communication
protocols. In recent years, this technique has been used to
verify and synthesize the problem of motion planning in the
eld of robotics.
Many researchers have turned their attention to self-
assembly algorithms and simulations in multi-robot system-
s. Jones and Mataric proposed the concept of Intelligent
*This research was supported by the BJNSF (4122017),NS-
FC(61373034,61303014) ISTCP (2011DFG13000,2010DFB10930)
1
Rui Wang, Ping Luo, Yong Guan and Xiaojuan Li come from Beijing
Engineering Research Center of High Reliable Embedded System, Beijing
Key Laboratory of Electronic System Reliability Technology, College of In-
formation Engineering, Capital Normal University, Beijing, China, 100048.
rwang04@163.com
2
Hongxing Wei with the School of Mechanical Engineering and automa-
tion, Beihang University, Beijing, China.
3
Jie Zhang with College of Information Science and Technology, Beijing
University of Chemical Technology, Beijing, China
4
Xiaoyu Song with the ECE Dept, Portland State University, Portland,
USA
Self-assembly, where each module has limited and local
sensing capability and local rule-based control, which can
be employed to assemble the desired target [6]. Kelly and
Zhang developed a stochastic optimization algorithm to build
a structure by self-assembly [7]. Grady et al. establish a
distributed self-assembly control method for a given target
conguration called SWARMORPH [8].
Formal methods were adopted in the creation of control
for modular robotics [9]. Tasks were expressed in structured
English and then translated to LTL formulas to synthesize
the control plan, but real-time character cannot be modelled.
A geometry-based multilayered approach was proposed to
solve motion planning with temporal goals [10]. This method
combined the sample based planning and LTL synthesis.
Many researchers have adopted a formal method for multi-
robot coordination. A plan-merging paradigm was used to
guarantee the coherent behavior of robots in all situations
[11]. Hybrid automata were applied to model and verify the
coordinate control method [12]. Paper [13] presented Petri
Net Plans (PNP) based on a distributed execution algorithm
for high-level robot and multi-robot programming. [14] used
timed automata to model and verify the motion planning
problem. Robots and obstacles were modeled as a network
of timed automata. For the motion planning in this paper, we
do not know the exact allocated destination of every robot.
We only know whole conguration. Our planning method
can nd the optimal traces and corresponding destination of
each robot. The correctness of the results is guaranteed by
model checking.
In this paper, we present a multi-layer method for model-
ing and verifying the motion planning problems of a Sambot
system. In the abstract logic layer, the seed and Docking
Sambots (DSA) are all modeled by timed automata. The
components are synchronized by passing signals through
channels. The system requirements are specied and formal-
ized as CTL [15] properties. The shortest traces of cong-
urable property indicate the planning traces for multi-robots.
We demonstrate that the design model satises the required
properties, by using a symbolic model checkerUppaal [16],
[17]. The model used in Uppaal extends timed automata
with bounded integer variables, data structure, and location
urgency [18], [19]. In the physical layer, the trajectory trace
that considers the dynamic model of Sambot and suggested
high level plans is given by sample-based planning. This two
layer method can get a approximate discrete plan rapidly
and then generate a practical trace considering the dynamic
equation. An example is given to illustrate the strategies
that are employed. The experimental results demonstrate the
2014 IEEE International Conference on Robotics & Automation (ICRA)
Hong Kong Convention and Exhibition Center
May 31 - June 7, 2014. Hong Kong, China
978-1-4799-3684-7/14/$31.00 ©2014 IEEE 5624
  
II. THE SAMBOT ROBOT AND SIMULATION PLATFORM 
A.  Sambot Hardware Platform 
The Sambot is a self-assembly modular robot having the 
characteristics of both the chain-type and the mobile 
self-reconfigurable robots. Multiple Sambots can 
autonomously move and connect with one another through 
self-assembly to form robotic structures. Its overall size is 
80mm?80mm?102mm and its weight is 400 grams. 
    
(a)                                                    (b) 
Fig. 1.  The Sambot Platform. (a) a single Sambot robot ; (b) two 
docking Sambots and some representation on docking components 
Each Sambot has some infrared sensors, which detect the 
target and guide the process of self-assembly. As shown in Fig. 
1, on the upper side of the front and back face of the Sambot 
are installed two pairs of detecting infrared sensors each, 
which are used to detect obstacles in front of the robot. On the 
lower side of the front, back, left and right face of the Sambot 
are two pairs of approaching infrared sensors each. On the 
upper and lower side of the active docking interface of the 
Sambot are installed two pairs of docking infrared sensors, 
which can receive the signal of the approaching infrared 
sensors of other Sambots to decide whether to execute the 
docking behaviour. 
STM32
Controller
Accelerator
Gyroscope
AD
Atmega8 A
M M
PWM
Encode
Electricity
Speed and Pos.
For the whole-body locomotion
Atmega8 B
M
IR Sensors
PWM
AD
Atmega8 C
M
IR Sensors
PWM
AD
Speed and Pos.
Speed and Pos.
For docking
Atmega8 D
M
IR Sensors
PWM
AD
Speed and Pos.
For assembly
I2C
ZigBee 
module
Pos. Switch
GPIO
UART
CANH
CANL
CAN
Radio
 
Fig. 2.  The hardware architecture of Sambot system 
The control system of Sambot is shown in Fig. 2. It is 
composed of a 32-bit ARM processor (STM32) and four 8-bit 
MCU (ATMega8). The STM32 communicates with the four 
MCU via the I2C bus and mainly carries out the tasks of 
control, navigation, localization and decision making; 
whereas the ATMega8 modules principally drive the motors 
and collect signals from the encoders and sensors.  
B. The Sambot Simulation Platform 
We use Microsoft Robotics Studio (MSRS) to build our 
simulation platform for the Sambot. MSRS is a 
Windows-based environment for robot control and simulation. 
It is based on CCR (Concurrency and Coordination Runtime), 
a .net-based concurrent library implementation, for managing 
asynchronous, parallel tasks using message-passing and DSS 
(Decentralized Software Service), a lightweight 
service-oriented runtime, which allows the orchestration of 
multiple services to achieve complex behaviors. MSRS 3D 
simulation environment allows simulating the behavior of 
robots in a virtual world using NVIDIA PhysX technology 
(3D engine originally written by Ageia) that includes 
advances physics. 
The simulation platform of the Sambot is shown in Fig. 3. 
The Sambot simulation model has same kinetics 
characteristics and control parameters as real physical Sambot 
robot. The control strategy in Sambot simulation model is 
ported to real physical Sambot robot. 
     
Fig. 3.  The Sambot simulation platform 
C. The Sambot Control Model 
In our study, the Sambot has the following control 
characteristic: 
? Control. For each Sambot, the controller is identical. At 
the start, an identical controller is copied onto each of the 
Sambots. And each Sambot has no a priori knowledge of 
global environment. 
? Sensor. Each Sambot is equipped with same sensors. 
Besides the infrared sensors, the Sambot have a 
gyroscope and an accelerometer to get the information of 
its position, speed and orientation. There also is a 
photosensor to execute the phototaxis task. 
? Actuator. Each Sambot is equipped with five actuators. 
A motor is used to drive the docking mechanism; two 
motors are responsible for autonomous motion control of 
the Sambot; two motors constitute the dual drive 
structure to control the whole-body locomotion of the 
robotic structure self-assembled with multiple Sambots. 
? Computation/Communication. Each Sambot is capable 
of performing computations and decisions. In our study, 
there are not global communications; each Sambot is 
able to use the Infrared sensors to communicate with its 
Fig. 1. Photographs of Sambot
effectiveness of our approach.
The paper is organized as follows. Section II contains a
detailed description of the Sambot system and its system
requirements. The theory on timed automata is given in
Section III. In Section IV, the motion planning method and
formal models of the Sambot system are presented. The
validation result is shown in Section V. Section VI concludes
the paper.
II. SAMBOTS SYSTEM
The Sambot is a self-assembly modular robot system with
the advantages of self-recongurability and self-assembly.
It has an overall size of 80mm 80mm 102mm and
weighs 400 g. Every robot contains a power supply, micro-
controller, actuators, sensors, and a communication system.
Each Sambot has some infrared sensors that detect the target
and guide the process of self-assembly. As shown in Fig.1
the upper side and the front and back sides of Sambot are
equipped with infrared sensors. A hook-groove mechanism
is used to realize the docking. Once preparation for docking
is ready, two robots can connect together with the connector
structure. There is a pair of grooves on the front, back, left,
and right sides of Sambot. During docking, the hooks can
be completely inserted into the grooves of another Sambot
to nish the process of docking and locking. Each Sambot is
capable of performing computations and decisions. They can
communicate with each other and with the main computer
to get the control input through a wireless network.
A. Self-assembly of Sambots
A Sambot is an autonomous mobile robot that is realized
by wheels. A Sambot can form robotic organisms connected
with one another to carry out some tasks. In our previous
work [2], we explored the use of local communication and
simple nite state machine (FSM) to produce self-assembly
control algorithms.
On a Sambot platform, three types of Sambot coexist,
including Docking Sambots (DSA), SEED, and Connected
Sambots (CSA). First, SEED starts the self-assembly pro-
cess. Then, the DSA achieves self-assembly with SEED
under the command of the behavior-based controller that
is independent of the target conguration. SEED and CSA
execute a conguration comparison algorithm to control the
conguration growth of the robotic organisms. The process
of the experiment is shown in Fig.2. At rst, the seed is in
the middle of the workspace, four DSAs are in the corner.
754 IEEE/ASME TRANSACTIONS ON MECHATRONICS, VOL. 16, NO. 4, AUGUST 2011
TABLE III
EXPERIMENTAL DAT A OF DIRECTIONAL AUTONOMOUS DOCKING
random initial orientations are tried for the active-SA. There-
fore, 16 experiments have been done in total. Table III gives
all the experimental results and records the time for wandering,
navigation, and active docking in every case, respectively.
In all the 16 experiments, only one failed. In this failure case,
at the ﬁnal moment of docking, there was some misalignment
between active-SA and the target. The mechanical touch switch
on the active docking interface was not pressed down. Therefore,
the docking hooks did not execute the locking behavior, which
led to the failure.
From Table III, it is found that the wandering time varies re-
markably as the initial position and/or orientation of the active-
SA changes, and so does the navigation time. The longest wan-
dering time was 55.4 s (see the Experiment 7), while the shortest
was merely 2.8 s (see the Experiment 7). The longest time of
navigation was 88.4 s (see the Experiment 12), but the shortest
was only 0.7 s (see the Experiment 6). Here, the time variation
was really a random phenomenon. It took different time for the
active-SA to navigate from different start positions to the dock-
ing direction of the target. However, Table III also shows that the
time spent for docking only experienced relatively small varia-
tions as the initial position and/or orientation of the active-SA
changes. The average docking time was 18.1 s.
C. Self-Assembly for a Quadruped Conﬁguration
As shown in Fig. 16, we conducted the self-assembly ex-
periments for a quadruped conﬁguration on an experimental
platform of size 1000 mm? 1000 mm. The SEED is located at
the center of the platform and the docking robots are put ran-
domly at the four corners. For the quadruped conﬁguration, the
docking robots can dock with SEED from the front, left, right,
and back interfaces. The experiment is ﬁnished within 170 s.
In this self-assembly experiment, all the docking robots ex-
ecute the same control algorithm, which is independent of the
target conﬁguration and other Sambots.
D. Caterpillar Locomotion Experiment
A locomotion experiment was done on a caterpillar conﬁg-
uration composed of ﬁve Sambots. The rotation range of each
Fig. 16. Self-assembly experiments for a quadruped conﬁguration.
Fig. 17. Caterpillar locomotion of a robotic structure assembled by ﬁve
Sambots.
module was 30
?
, and the delay time was 300 ms. As shown in
Fig. 17, the wave was generated in Fig. 17(b). From Fig. 17(b) to
(f), the wave propagates to push the robot forward continuously.
From Fig. 17(b) to (h), the robot moved forward a distance of
about 3.4 modules (i.e., approximately 280 mm) in 9 s. There-
fore, the actual moving speed of the robotic structure was about
30 mm/s.
In conclusion, it is easy to realize the locomotion control of
caterpillar or other conﬁgurations composed of multiple mod-
ules by the distributed CAN bus method, as long as the gait
control table for the conﬁguration is established.
VI. DISCUSSIONS
This section discusses the features of structural design, self-
assembly, self-reconﬁguration, and locomotion of Sambot.
A. Structural Design
For a self-reconﬁgurable robot, the structural design is one
of the biggest challenges, especially the design of the docking
and locomotion mechanisms. Autonomous motion and limited
perception ability are the two main features of the swarm robots.
The structural design of Sambot utmostly combined the features
of swarm and self-reconﬁgurable robots. On one hand, it has the
Fig. 2. The assembling process of Sambot
After the assembling process, a cross is obtained at last. The
main disadvantage of previous method is that these DSAs
search the SEED randomly and aimlessly. If a DSA goes to
a opposite direction, it may cost a lot in terms of time.
In this paper, we rst plan the shortest traces of all DSAs
with the model checking method. Then, under the constraint
of dynamic functions, we design the control input of DSAs
so that the DSAs can move along the predesigned trajectory
and lock to the SEED without collision. Before planning, we
need to know the locations of the DSAs and the SEED.
B. System Requirements
In this system, safety is of the utmost importance. The
DSAs move within a restricted space. It is necessary to
ensure that these DSAs do not crash into each other. The
DSAs can initially be located in any place. In the original
version, the DSA searches randomly by itself to nd possible
ways of achieving aim conguration. However, this process
takes a long time. In addition, DSAs might crash into each
other. Our intention was therefore to develop a planning
method to rst get the traces rapidly, and then avoid collision.
The system requirements are listed below.
1) Collision avoidance: DSAs should not crash into each
other.
2) Congurable: all DSAs should reach the destination
and complete the conguration.
III. THE THEORY OF TIMED AUTOMATA
Timed automata [20], [21] are nite automata with ex-
tension of time variables. Let V be a nite set of variables
including clock variablesC and data variablesX,V =C[X
and C\X = ; . We use (V ) to denote invariant and
guard formulas. We have ::= e j ^ , e takes
the form like c  n or x  n, c 2 C;x 2 X , 2
f;; =;<;>g and n2 N. The assignment operation is
dened as v := expresion, v2 V . Let U denote all the
assignment formulas.
Denition 1 Timed automaton is a tuple
A(L;l
0
;A;V;I;E)
 L: a nite set of locations
 l
0
: initial locations
 A: a nite set of actions
5625
 V : a nite set of variables
 I :L (V ) a location constraint function
 E: a nite set of edges
E L (V )AUL. Each edge has a source
locationl, a target locationl
0
. When guardg2 is satised,
the transition happens and a subset of variables in V are
updated by formula r2 U. An edge ehl;g;a;r;l
0
i can be
written as l
g;a;r
 ! l
0
.
The automaton starts at the initial state l
0
with all clocks
initialized 0. With time passing by, the clock variables
increase at the same rate satisfying the invariant constraints
I(l
0
). The system can remain still in this location or transit
to l
1
if the variables satisfy an edge enabling guard g. With
the transition, actiona is taken and variables are updated by
formula r.
Denition 2 The semantics of a timed automaton
A(L;l
0
;A;V;I;E) is dened as a labeled transition system
S(A) =hS;s
0
;i. SLmathbbR is a set of states, s
0
is the initial state,S(U[A)S is the set of relations,
divided into the following two cases.
 Elapses of time transitions: for d 2 R
+
, (l;u)
d
 !
(l;u +d), if for8d
0
 d, u and u +d
0
satisfy I(l),
and
 Location switch transitions: (l;u)
a
 ! (l
0
;u
0
),
if9e (l;a;g;r;l
0
)2 E, u
0
= r(u), u satises guard
g, r2U and u
0
satises I(l
0
).
A complex is composed of components. The controller
communicates with the environment concurrently. We intro-
duce timed automata networksA = A
1
k ::: k A
n
, and
A
i
= (L
i
;l
0
i
;A
i
;V
i
;I
i
;E
i
), n is the automata number in
the network. These automata share a common set of action
variables. Vector l = (l
1
;:::;l
n
) is the location vector of
timed automata networkA. The invariant function I(l) is
the conjunctions of the constraints of allA
i
,I(l) =^
i
I
i
(l
i
).
l[l
0
i
=l
i
] denotes that l
i
of L is replaced by l
0
i
.
IV. MOTION PLANNING METHOD
In this paper, we try to nd a solution to the following
problem:
Problem: Given a conguration task and a seed, nd a
global trajectory plan for all robots with the least amount
of moving time, and at the same time, avoids collisions.
The proposed hierarchical planning method is shown in
Fig.3. The prior knowledge of this method is the location
of seed and the location of the DSAs. The hierarchical
method consists of two layers. The highly abstract logic layer
constructs the timed automata representing the workspace
through a partition of the environment and the discrete
behavior of robots. Collision avoidance, time bound, and
congurable properties are formulated as CTL formulas.
The model checker tools can generate high-level motion
commands of moving to an adjacent region based on the
optimal time constraint. These discrete plans are sent to
a low-level physical layer, which generates the trajectory
based on the dynamic equations of Sambot. The control
input drives the Sambots through cells and forms the target
Environment
Timed
robot
Timed 
automata
Discrete
planning
Logical 
layer
Specification CTL
pg
Dynamic 
equation
Sample 
based search
Physical
layer
solution
Fig. 3. Hierarchical planning method
conguration. The hierarchical method reduces the scale of
model checking to avoid state space explosion, and also
considers the physical features of Sambots.
A. Problem Formulation
1) Prior knowledge: We assume that the workspace is
rectangular with the size of M. SEED and DSAs can be
located at any place in the workspace. Given the target
congurationG =< g
0
;:::;g
N
>, where N is the number
of DSAs, and the initial position of SEED and DSAs, our
method can generate the optimal trajectories for all DSAs.
2) Partitioning the environment: The workspace is a
continuous space. In order to use a logical method based
on an atomic proposition, we have to divide the space into
discrete areas. Given a robot workspace mathbbRWR
2
,
the partition divides the workspace into adjacent and disjoint
cells. D =
S
Dn
i=1
D
i
and D
i
\ D
j
= , where i;j 2
[1;Dn] and i 6= j. Therefore the partition is a mapping
 : mathbbRW!D. The cells can be convex polygons. In
this paper, we adopt a square partition, because the Sambot,
and the docking side are all square. The workspace is divided
intoDn =LXHY cells.LX andHY are constants that
denote the horizontal and vertical length ofD. The size of
each square is xed as 200mm 200mm, so as to make
enough room for one Sambot.
Dn =f(x;y)2Z
2
jx = [
m
200
];y = [
n
200
]; (m;n)2RWg;
and [ ] denotes the Rounding Function. As a result, the
continuous working space is mapped into a discrete two-
dimensional space, with the size of LXHY .
A group of robots are moving through the cells. The
boolean proposition 0
1
; 0
2
;:::; 0
Dn
is introduced to indicate
whether or not the cell is occupied by a robot. One position
may not be occupied by two robots at the same time.
0
i
=

1 if R2D
i
0 if R = 2D
i
3) Conguration: For each Sambot, ve docking inter-
faces are available, including one active interface and four
passive ones in its front, left, back, and right side. In order
5626
1122 Wei H X, et al.   Sci China Tech Sci   April (2012) Vol.55 No.4 
Sambots. A configuration connection state table is used to 
represent the configuration of composite robotic organisms 
formed by multiple Sambots. For a given configuration, we 
explore the use of local communication and finite-state ma-
chine (FSM) to produce self-assembly control strategies.  
4.1  Configuration representation 
Currently, some graph theory methods have been used to 
describe the configurations of self-reconfigurable robots, 
such as the incidence matrix [34], the adjacency matrix [35] 
and the configuration string [36]. Because the Sambot only 
has limited computing power and memories, a method of 
configuration description with efficient and low computa-
tional load is needed. 
Figure 5 shows the docking interfaces of a Sambot. 
There is one active docking interface and four passive 
docking interfaces in its front, left, back and right sides, 
which are numbered by 1, 2, 3 and 4, respectively.  
Each docking interface may be in one of the following 
three connection states:  
(1) Active connection. This state is denoted by “1” in the 
system. It means that the interface actively connects itself to 
another Sambot. Generally, only the active docking inter-
face can execute the active docking task from the front or 
back side of the main body (see Figure 5).   
(2) Passive connection. This state is denoted by “?1”, 
which means that the interface is connected passively with 
another Sambot. Any one of the four sides of the Sambot 
may have such a state.  
(3) No connection. This means that the interface does not 
connect with other Sambots actively or passively. 
The connection state of each Sambot can be described by 
an array CS[i]. The index i may be 1, 2, 3 or 4, which rep-
resents the front, left, back or right side of the Sambot.  
Since each Sambot has only one active docking interface, 
the connection relations between multiple Sambots are di-
rectional. Thus, we can also use a tree structure in the graph 
theory to represent the connection relations. For example, 
the tree structure for the quadruped configuration is shown 
in Figure 6, where node 1 is root node and all other nodes 
are child nodes. 
Because the root node of each configuration is unique, 
we can begin from it to specify the node sequence. A DFS 
(depth-first search) algorithm is used to traverse the tree 
structure. For a given configuration, we can combine its 
node sequence and the connection states to establish a Con-
figuration Connection State Table (CCST). As shown in 
Figure 6, a quadruped configuration is used as an example. 
There node 1 is the root node, and its connection state may 
be described by CS[1]=[?1 ?1 ?1 ?1], which means that 
there are 4 child nodes (i.e., node 2, 4, 6 and 8) connected 
with it from its four sides, respectively. In such a way, the 
CCST for the quadruped configuration can be created (see 
Table 2).  
 
Figure 5  Description of docking interfaces for the Sambot. 
 
Figure 6  The tree representation for a quadruped configuration. 
Table 2  CCST of the cross quadruped configuration 
Node No. Node’s connection state 
1 (?1 ?1 ?1 ?1) 
2 (1 0 ?1 0) 
3 (1 0 0 0) 
4 (1 0 ?1 0) 
5 (1 0 0 0) 
6 (1 0 ?1 0) 
7 (1 0 0 0) 
8 (1 0 ?1 0) 
9 (1 0 0 0) 
 
For the convenience of computer representation and 
storage, the CCST can be written as an array CCST[j], 
where j stands for the node number. For example, the CCST 
of the quadruped configuration can be represented as an 
array [(?1 ?1 ?1 ?1), (1 0 ?1 0), (1 0 0 0), (1 0 ?1 0), (1 0 0 
0), (1 0 ?1 0), (1 0 0 0), (1 0 ?1 0), (1 0 0 0)]. Some typical 
configurations and corresponding CCSTs are shown in Fig-
ure A1 and Table A1 in Appendix A. 
4.2  Self-assembly control model 
For a target configuration, the self-assembly process is 
started by a Sambot named the SEED, which will randomly 
be selected in the swarm of Sambots. The SEED does not 
dock with other Sambots actively. It only allows itself to be 
docked by others. Once the SEED is chosen, we send the 
CCST of the target configuration to it. By comparing the 
current configuration with the target one, the SEED opens 
one of its docking interfaces and then waits for another 
Sambot to dock with it. Here, we denote such an opened 
Fig. 4. The cross conguration
to successfully accomplish the process of self-assembly, it
is necessary to have a proper method of describing the
conguration. In [2], integers of -1, 1, 0 are adopted to
represent the three kinds of connection states in which
a docking interface may stay: active connection, passive
connection, and no connection. The connection state of a
Sambot is described by a quaternion g = (a
1
;a
2
;a
3
;a
4
),
where a
i
2f1; 1; 0g and represent the connection state of
its front, left, back and right interfaces. Thus, with the Seed
as the rst quaternion, all of theN DSAs of robots consist of
a two-dimensional array named a Conguration Connection
State Table,G[N + 1][4], which describes the conguration
of the Sambots. For example, the conguration of Sambot
from number 1 to number 9 in g.4 will be
G = (( 1  1  1  1); (1 0  1 0); (1 0 0 0); (1 0  1 0);
(1 0 0 0); (1 0  1 0); (1 0 0 0); (1 0  1 0); (1 0 0 0))
With a target conguration and the position of the Seed,
we can gure out the destinations of the DSAs.
B. Sambot Model
Given a team of robots R
i
, i = 0; 1;:::;N  1, N2 I
+
is the number of robots. They are separated into two types:
SEED and DSA. The SEED is responsible for starting
the self-assembly process while the latter docks actively.
We mark SEED as R
0
, while the DSAs range from R
1
to R
N 1
. Each robot has its own location, expressed as
(xx;yy)2D.
In the following we establish the timed automata models
for SEED and DSAs in Uppaal. In order to reduce the
communication signal and avoid state space explosion, we
compress the model of the robot and controller into one
model. Therefore, the robot model contains the control
command and strategy.
1) Seed model: The central Sambot, sponsors the self-
assembly process. The timed automaton of the SEED is
presented in Fig. 5. There are two states for the SEED:
Init state and Wait state, where the SEED is waiting for
self-assembly to be accomplished. In the Init state, it starts
the process via a broadcast signal assemble!, which will be
responded to by all of the DSAs via ans[j]?. The integer
ii is dened to count the number of responses. According
to the expected congurationG and its own position, the
goal locations will be calculated via the dened function
Assemble() and be distributed randomly over all of the
DSAs, through the function setGoal(). Thus, the SEED
enters the location Wait.
Fig. 5. The formal model of seed
2) DSA model: DSAs are restricted to moving horizon-
tally and vertically in a Cartesian grid. In other words, a
DSA can freely choose to move in the direction of east,
west, south, and north. If the robot crosses one square, this
is called one step. The time taken for that one step is denoted
by a constant t m = 1.
Fig.6 shows the timed automaton of DSA. clock t
is dened in the local declaration of the DSA template.
We also declare the process template with the parameters:
int[1;N] i;int[0;LX] xx;int[0;HY ] yy, where i denotes
the ID number of the DSA and (xx;yy) are the coordinates
of the robot in the workspaceRW. There are four locations
in this modelL =fInit; Ready; Moving; Doneg, where
Init is the initial location.
Each DSA starts to move after receiving the signal
assemble! from the SEED model and gives a response
along with its position uploaded. When DSA enters the
location Moving, the DSA can move around freely and
randomly as long as the cell is not occupied. Four self-loop
transition edges in the location Moving describe the four
possible moving directions. Each edge is labeled with a
common condition (t >= t m;Loc[i]! = myGoalLoc[i]),
which indicates that DSA does not reach the
destination. The distinct condition guarantees that the
movement is legal. For example, the guard(Loc[i]:x <
LX  1; !notEmpty[Loc[i]:x + 1][Loc[i]:y]) ensures the
DSA can move east.Loc[i], a dened structure that includes
members of int x;int y, denotes the current position of
the i
th
DSA, while myGoalLoc[i] is the target. When the
transition takes place, the function of moveEast() shall
5627
Fig. 6. The formal model of DSA
be invoked to update the current coordinates. As soon as
the DSA approaches the goal position, the model enters the
location Done, where the task of docking is accomplished.
V. MODEL CHECKING AND PATH PLANNING
The property specication used in Uppaal is a sim-
plied version of CTL. The path quantiers are the
same as those in CTL, but the temporal operators are
just F (<>) and G([]). The proposition logic has the
operator negation (not; :), conjuction (and; &),
disjunction (or; jj), and implication (imply; !). The
reachability property, safety property, and liveness property
can be checked.
Moreover, a property of the forminffexpressiong :list
is added in the latest version of Uppaal, which returns
the inma of the expression in the list, whereas
supfexpressiong : list evaluates the suprema.
A. Verication of Properties
The following properties are specied based on the system
requirements in section II. They are veried byUppaal, and
run on a computer with a Quad 2.66 GHz CPU with 2.0 GB
of memory.
The experimental work-space is 2000mm2000mm. The
workspace is divided into 10 10 grid, so, the grid size is
200mm 200mm. The whole system contains one seed and
four DSAs. The initial position is shown in Fig.7. In this
experiment the goal conguration is a cross. Therefore, the
destinations of DSA are (6; 4), (5; 3), (6; 2), and (7; 3) by
the translation algorithm.
1) Congurable property:All DSAs can arrive at the desti-
nation, which means completing the conguration with
the shortest path.
E <> DSA1:Done and DSA2:Done and
DSA3:Done and DSA4:Done
This property is satised. We do not assign the
destination to DSAs. The best distribution plan will
be found by completing the search algorithm for
model checking. From the shortest trace provided
by Uppaal, we can get the shortest path and their
destination allocation for all DSAs. The trace of
DSA4 is as follows:
(Init)
assemble?
      !(Ready)
ans[4]!
    !(Moving)
;mEast()
       !
(Moving)
;mEast()
       !(Moving)
;mEast()
       !(Moving)
;moveSouth()
         !(Moving)
;moveSouth()
         !(Moving)
;moveSouth()
         !(Done)
2) Collision avoidance property: For the planning trajec-
tories, DSAs will never crash into each other.
A[ ] not((Loc[1] ==Loc[2] or Loc[2] ==Loc[3] or
Loc[3] ==Loc[4] or Loc[1] ==Loc[3] or
Loc[1] ==Loc[4] or Loc[4] ==Loc[2]) and t> 0)
This property is satised because before the DSA
moves, the DSA rst asks if the approaching cell is
occupied. Only if the cell is empty will the DSA move
ahead.
3) Execution timed property:What is the moving time for
nishing the following conguration?
inff DSA1:Done and DSA2:Done and
DSA3:Done and DSA4:Doneg : t
The result is seven time units. This means that the
target conguration will nish within six time units,
which is the short possible time.
9
8
7
6
5
4
3
2
1
0
0 1 2 3 4 5 6 7 8 9
Y
X
DSA1
DSA4
DSA3
DSA2
SEED DSA2
DSA1
DSA4
DSA3
Fig. 7. Path given by Uppaal
5628
B. Planning Trajectory Traces
As illustrated in Fig.7, a trajectory trace is generated by
Uppaal, which satises both the above mentioned CTL for-
mula of Congurable property and Execution timed property.
The two properties demonstrate that all of the DSAs have
nally arrived at the destination and that the shortest time
has turned out to be seven time units, respectively. We can
easily learn that one of the best assignment plans is the one
in which DSA1 achieves the goal location (6, 4), DSA2 the
location (5, 3), DSA3 the location (6 ,2), and DSA4 the
location(7, 3). With this allocation, the overall time taken
will be the least. This is just a high-level discrete planning.
Guided by high-level planning and considering the phys-
ical constraints of robots, the trajectory is obtained by a
sampling-based algorithm. With the dynamics equation of
robots, the Rapidly-Exploring Random Tree (RRT) algorithm
[22] generates a tree of possible traces T = (V;E). The
initial position v
init
is the root of the tree. After a time
step t, the next vertex v
new
is computed by the dynamics
equation. Then, we see whether v
new
is in the space of
high level discrete traces. This step will be repeated until
v
new
is legal. In Fig.8 the random computed vertexesv
new1
,
and v
new2
are outside the discrete plans generated in high
level. So they are abandoned. Vertex v
new3
is legal and
selected as the next vertex. The computed trajectory follows
the dynamics features of robots and also satises the veried
properties.
Y
X
0 1 2 ... ...   LX
LY   
.
.
.
.
.
.
2
1
0
200mm
200mm
Fig. 8. The exploration step in sample-based algorithm
VI. CONCLUSION
In this paper, a multi-layer method was presented for
the motion planning of a self-assembly module system. We
discussed the creation of timed automata model from any
possible conguration and get the optimal allocation by
model checking. An example illustrated the effectiveness
of our approach. This method can nd the optional plan
within short time, compared with the random and aimless
wandering of DSAs in our previous work. We will establish
the experimental platform and test our method in the future.
REFERENCES
[1] H. X. Wei, and Y . Chen, and J.Tan and T. Wang. ?Sambot: A self-
assembly modular robot system?, IEEE/ASME Transactions Mechatron-
ics, vol.14, no.4, pp745-757, 2011
[2] H. X. Wei,H. Li, J. Tan, and T. Wang. ?Self-assembly control and
experiments in swarm modular robots?, Science China, vol.55, no.4,
pp1118-1131, 2012
[3] C. Anderson, G. Theraulaz, J. L. Deneubourg. ?Self-assemblages in
insect societies?. Insectes Soc, 2002, 49(2): 99C110
[4] R. Grob, M. Dorigo. ?Self-Assembly at the macroscopic scale?. Pro-
ceedings of the IEEE, 2008, 96(9): 1490C1508
[5] E. M. Clarke, O. Grumberg, D Peled. ?Model Checking?, The MIT
Press, 1999
[6] C. V . Jones , M. J. Mataric. ?From local to global behavior in intelligent
self-assembly?. In: Proceedings of IEEE International Conference on
Robotics and Automation, Taibei, 2003. 721C726
[7] J. Kelly, H.Zhang. ?Combinatorial optimization of sensing for rule-
based planar distributed assembly?. In: Proceedings of IEEE/RSJ Inter-
national Conference on Intelligence Robots and Systems, Beijing, 2006.
3728C3734
[8] R. OGrady, A. L. Christensen, M. Dorigo. ?SWARMORPH: multirobot
morphogenesis using directional self-assembly?. IEEE Trans Robot,
2009, 25(3): 738C743
[9] S. Castro, S. Koehler, H. K. Gazit. ?High-level control of modular
robots?. In proceeding of: 2011 IEEE/RSJ International Conference on
Intelligent Robots and Systems , IROS 2011, San Francisco, CA, USA,
September 25-30, 2011, 3120 - 3125
[10] A. Bhatia, L. E. Kavraki, M. Y . Vardi. ?Sampling-based motion plan-
ning with temporal goals?. IEEE International Conference on Robotics
and Automation (ICRA) , 3-7 May, 2010, 2689 - 2696
[11] R. Alami, S. Fleury, M. Herrb, F. Ingrand, F. Robert. ?Multi-robot
cooperation in the MARTHA project?, IEEE Robotics & Automation
Magazine, vol.5, pp.36-47, 1998
[12] R. Alur, J. Esposito, M. Kim, V . Kumar, and I. Lee. ?Formal
modeling and analysis of hybrid systems: A case study in multi-robot
coordination?, Formal Methods, pp212-323, 1999
[13] V . A. Ziparo, L. Iocchi, D. Nardi, P. F. Palamara, and H. Costelha.
?Petri net plans: a formal model for representation and execution of
multi-robot plans?, Proceedings of the 7th international joint conference
on Autonomous agents and multiagent systemsV ol 1, pp79-86, 2008
[14] M. M. Quottrup and T. Bak, and R. I. Zamanabadi. ?Multi-robot
planning: A timed automata approach?, IEEE International Conference
on Robotics and Automation, pp4417-4422, 2004.
[15] E. Emerson, ?temporal ans modal logic,? in Handbook of Theoretical
Computer Science, J.van Leeuwen, Ed. MIT press, 1990, vol.B ch. 16,
pp.995-1072
[16] G. Behrmann, A. David, and Kim G. Larsen. ?A tutorial on Uppaal?. In
4th International School on Formal Methods for the Design of Computer,
Communication, and Software Systems, 2004, LNCS 3185
[17] http://www.uppaal.com
[18] G. Behrmann, J. Bengtsson, A. David, K. G. Larsen, P. Pettersson,
and W. Yi. ?Uppaal Implementation Secrets?. In Proceedings of the 7th
International Symposium on Formal Techniques in Real-Time and Fault
Tolerant Systems, 2002
[19] J. Bengtsson and Y . Wang. ?Timed Automata: Semantics, Algorithms
and Tools?. In Lecture Notes on Concurrency and Petri Nets. LNCS
3098, Springer-Verlag, 2004
[20] R. Alur and D. L. Dill. ?A theory of timed automata?. In Theoret.
Comput. Sci., V ol. 126, No.2, 1994, pp. 183-235
[21] R. Alur. ?Timed automata?. In Proceedings of Computer Aided Veri-
cation, Trento, IT, LNCS 1633, Springer-Verlag, Jul. 1999, pp. 8-22
[22] S. M. LaValle. ?Rapidly-exploring random trees: A new tool for path
planning?. TR 98-11, Computer Science Dept., Iowa State University,
1998.
5629
