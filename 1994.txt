An End-to-End System for Designing Mechanical Structures for
Print-and-fold Robots
Ankur M. Mehta and Daniela Rus
1
Abstract— This work presents a script-based develop-
ment environment aimed at allowing users to easily design
and create mechanical bodies for folded plastic robots.
The origami-inspired fabrication process is inexpensive
and widely accessible, and the tools developed in this
work allow for open source design sharing and modular
reuse. Designs are generated by recursively combining
mechanical components – from primitive building blocks,
through mechanisms and assemblies, to full robots – in a
ﬂexible yet well-deﬁned manner. This process was used
to design robotic elements of increasing complexity up
to a multi-degree-of-freedom compliant manipulator arm,
demonstrating the power of this system. The developed
system is extensible, opening avenues for further research
ultimately leading to the development of a complete robot
compiler.
I. INTRODUCTION
Robots can come in a variety of form factors with
a number of uses, displaying potential to become in-
dispensable for purposes such as academic research,
educational outreach, or general household use [1]–
[3]. However, the power of robotics comes from cus-
tomizability in the system design. To enable the general
public to personally design and create individualized
robots, non-specialized users must be able to go from
problem speciﬁcation to device fabrication rapidly and
repeatedly.
Though there are many computer aided design
(CAD) packages focusing on various stages of this
process, the creation of a robotic system still requires
a multitude of such tools, along with the specialized
skills needed to navigate each one. This currently
leaves robotics within a domain of experts. To bring
personalized robots into the homes of the general pub-
lic, the complete design process needs to be reworked.
This paper presents a toolbox-like system to simplify
and streamline the design and manufacture of printable
robot bodies. Mechanical structures are fabricated in an
origami-inspired process wherein precision patterned
and cut 2D sheets of plastic are folded into 3D ele-
ments. Designs for these structures are generated by
a collection of Python scripts which allow a user to
deﬁne complex geometries by hierarchically composing
simpler building blocks, starting from a library of basic
primitives. These designs are then fabricated using an
inexpensive desktop paper/vinyl cutter. The resulting
1
A. Mehta and D. Rus are with the Computer Science and Artiﬁcial
Intelligence Laboratory, Massachusetts Institute of Technology, Cam-
bridge, MA 02139, USA. email: fmehtank, rusg@csail.mit.edu
process is intuitive, versatile, and extensible, allowing
quick and easy design of sophisticated robot bodies. It
uses cheap and easily available software and hardware
tools and raw materials, making it accessible to a casual
hobbyist.
The contributions presented in this paper include:
 a method of abstracting 2D fold patterns via
scripted objects,
 a composition paradigm to generate hierarchical
print-and-fold mechanical designs,
 a collection of mechanical elements forming a li-
brary of building blocks, and
 complex multi-degree-of-freedom robot bodies de-
signed using the aforementioned system.
II. ORIGAMI INSPIRED FOLDING
There are many tools and processes available to
be used in the fabrication of mechanical structures,
optimized for a variety of applications. When con-
sidering the task of creating custom designed robot
bodies, several concerns take precedence. The design
of mechanical structures often involves trial-and-error
or successive reﬁnement. In order to facilitate such
a process, the fabrication method must be relatively
fast and cheap, while still versatile enough to produce
the variety of structures necessary for arbitrary robot
bodies.
A common rapid prototyping method is 3D printing,
made accessible to home users by products such as the
MakerBot [4] and popularized through user communi-
ties like Thingiverse [5]. Structures are designed by cre-
ating solid models, which are then fabricated through
an additive manufacturing process using polymer stock
material. Though this process can often take hours to
build a complete model, current 3D printers can make
a wide variety of solid bodies. However, existing tech-
nologies are limited in permitting mechanical degrees
of freedom.
Kinematic structures are typically created using stan-
dard mechanical fasteners such as axles, pin joints, and
sliding surfaces. Such constructions, though functional,
were found to have a number of limitations including
unwanted degrees of freedom due to minimum dimen-
sions, inefﬁciency due to surface roughness, and lack
of robustness due to the fabrication process [6], [7]. 3D
printing with soft materials to make compliant mech-
anisms share similar robustness concerns [8], though
2014 IEEE International Conference on Robotics & Automation (ICRA)
Hong Kong Convention and Exhibition Center
May 31 - June 7, 2014. Hong Kong, China
978-1-4799-3684-7/14/$31.00 ©2014 IEEE 1460
that can be tempered by increasing the size of the joints
and reducing the range of motion [9].
Instead, this work focuses primarily on an origami-
inspired process for creating 3D structures by folding
2D patterned sheets, similar to e.g. [10]–[12]. Such
patterns can be quickly printed in plastic using an inex-
pensive desktop paper/vinyl cutter, with raw material
cheaply and readily available. This process inherently
allows for constrained motion by using patterned folds
as hinges. Similar to the diversity displayed by origami
creations, the print-and-fold process allows for a wide
range of mechanical designs. This particular process
has already been used to manually design a number
of successful standalone robots [12]–[14].
There have been a number of tools designed to
automatically decompose 3D geometries into their 2D
unfoldings [15]–[17]. These algorithms focus mainly on
solid objects, using heuristics constrained by design
rules to generate unfoldings of complex polyhedra.
However, kinematic or compliant structures have not
yet been addressed.
III. DESIGN PRINCIPLES
To enable personal robotics to gain widespread trac-
tion, the process by which desired devices are designed
must be greatly simpliﬁed. With a potential target
audience of school children or the general public, the
system must be usable by those without a background
in engineering design. In particular, there are a number
of guiding principles to help translate users’ visions
into mechanical structures as easily and directly as
possible.
Most importantly, the system environment should be
intuitive, allowing an inexperienced user to easily un-
derstand and implement the design process. A “what
you see is what you get” (WYSIWYG) model is ideal,
wherein the starting state and all operations directly
correlate to their real-world implementation. Generated
designs should be easy to share, modify, adapt, and
extend using free and open source tools.
Earlier work on origami inspired robotics [12], [13],
[18] were lacking in one or more of those goals. Designs
are often manually drawn from scratch in sophisticated
2D CAD programs, and can be difﬁcult to visualize as
3D objects. Most robots are created as monolithic inte-
grated designs, and so these issues are compounded as
designs grow in size and complexity.
The design package presented in this paper consists
of a collection of Python scripts that automate the
end-to-end process of designing and fabricating the
mechanical body of a folded plastic robot. The sim-
ple text-based representation of these designs enables
many of the same beneﬁts of the Open Source Software
movement such as incremental modiﬁcation, modular
reuse, and community based sharing of designs. Expert
users can generate new modules and edit the scripts
directly, while novice users need only be concerned
Fig. 1. When creating a new print-and-fold design in the proposed
system, a designer needs only to be responsible for specifying the
blocks highlighted in orange: which subcomponents are required and
how their parameters are set, and what parameters and connections
to expose to higher designs.
with designed modules as building blocks, connecting
them through a simple interface that hides the details
of the underlying software.
IV. DESIGN ENVIRONMENT IMPLEMENTATION
The system presented in this paper is outlined in
ﬁgure 1.
A. Software abstraction
3D folded plastic geometries are deﬁned by their fold
patterns – the 2D drawings specifying edges to either
cut or fold. However, because of the non-intuitive
mapping between the fold pattern and its resulting 3D
geometry, mechanical elements are ﬁrst abstracted into
their constituent components, hiding the underlying
2D fold pattern in favor of a building-block repre-
sentation as in ﬁgure 2. These components are self-
contained software abstractions of speciﬁc mechanical
parts represented in the system by Python objects, and
are responsible for generating their own fold patterns.
While expert users can edit the code directly to ﬁne-
tune the resulting geometry, the typical user can instead
treat each component atomically as the physical entity
it generates, combining them in a modular fashion
similar to Lego or Tinkertoys.
This system enables the rapid design and fabrication
of robot bodies such as the one diagrammed in ﬁgure 2
and shown in ﬁgure 10. Given an initial component li-
brary populated with some expert-designed primitives,
a typical user need only assemble the components as
per a speciﬁed hierarchy graph in order to design the
complete mechanical structure.
B. Component library
The hierarchical design paradigm of the system pre-
sented in this work is meant to recursively build up
to the desired 3D geometry. The lowest level building
blocks of these designs are primitive components repre-
senting mechanical structures directly deﬁned by their
1461
Fig. 2. A robotic manipulator arm can be hierarchically decomposed
into modular building blocks; each block in the diagram represents
a component in the Python-based design system and can generate
the required design ﬁles for fabrication. Only the leaf nodes must
be coded by an expert designer – the rest can be implemented by
simply combining their constituent subcomponents.
2D unfolding. Derived components are then formed
by combining primitive or other derived components.
Because primitives must be designed in their entirety,
their creation falls under the expert user domain.
Each component implements a common set of meth-
ods deﬁned in the parent class, providing a structured
implementation for parametrization and composition.
These methods can then be called from the casual
user domain to enable customization and extensibility
within the expert-deﬁned bounds. The parameters of
a component are deﬁned by the expert designer to
enumerate user-conﬁgurable degrees of freedom in
the geometric speciﬁcation of a design, an example
of which is shown in lines 6-10 of listing 2. Typical
parameters include size, shape, or repetition counts.
The component designer is responsible for ensuring
that the assigned parameter values are then reﬂected
in the ﬁnal design of the component. Each component
also speciﬁes a list of connections – locations identiﬁed
by the designer to which other components can safely
be attached. This can be seen in lines 12-15 of listing 2.
C. Composition
A design implemented in this system is a constrained
combination of components (and is itself another com-
ponent); specifying a design in this system consists of
recursively composing the right collection of compo-
nents to generate the desired robot body. Composing
a new design requires the user to follow a prescribed
set of steps to generate the Python class representing
the new component. These steps could be carried out
by manually generating the required Python script, or
an automated user interface could generate the code
directly from user input.
The required subcomponents must ﬁrst be identiﬁed
and collected, as in line 4 of listing 2. If any do not
yet exist in the library, they must be created either by
drawing a new primitive component or by composing
a new derived component in the same manner being
presented here.
By default, the parameter set of the new derived
component begins as simply a union of the parameters
of all its subcomponents. However, an assembled de-
sign often imposes constraints between related param-
eters of its constituent parts, and so these constraints
must be speciﬁed relative to the desired parameters of
the assembly. The ﬁnal set of parameters must exactly
cover the available geometric degrees of freedom of
the composite design, and specify all the parameters
of the subcomponents. The parameters in listing 2 are
declared in lines 6-10, and set in lines 17-20.
Finally, the subcomponents must be attached to each
other along allowable connections to generate the ﬁnal
geometry, as accomplished by lines 22-40 of listing 2.
As each subcomponent is actualized as a 2D unfolding
of the desired 3D structure, attaching two unfoldings
must result in a new planar unfolding of the composite
structure. With careful design, this can sometimes be
achieved by simply concatenating the two unfoldings
along a shared edge. Other times, however, a more
rigorous algorithm such as that presented in [19] must
be used to generate the composition.
D. Fabrication
Each component in this system is an instance of a
common parent class, stored as an executable Python
script. When run, this class calls a method to generate
the ﬁnal 2D design ﬁle to be sent directly to the cutting
machine, thus providing the fabrication path for the
printable robot. The class also has methods to gener-
ate 3D representations to aid in the design process,
demonstrating the static and dynamic appearance and
behavior of the resulting structure. Instantiating the
ﬁnal design consists of setting the required parameters,
generating a 2D design ﬁle, sending it to a cutter to
pattern a sheet of plastic, then folding it to the ﬁnal 3D
geometry, using generated models for guidance.
V. RESULTS
The proposed system was used to design and fabri-
cate a variety of mechanical structures.
A. Primitive components
There are many possible primitives, a subset of
which are presented below. They are typically simple
structures; more complex structures can often be sub-
divided into compositions of these simpler designs.
1) Basic shapes: The simplest non-trivial geometries
required to build 3D structures are convex polyhedra.
Building blocks such as cubes (shown in ﬁgure 3,
from the code in listing 1) and beams (shown in
ﬁgure 4) form the structural elements of most folded
plastic robots. The unfolded geometries are speciﬁed
by Python scripts as ﬁrst presented in [14]: and encap-
sulated in the component framework presented above.
They are parametrized to allow for user speciﬁed ge-
ometries. For example, the length, diameter, number
of sides, and face angles can all be adjusted for a
1462
Fig. 3. The code to generate a cube creates the 2D fold pattern on
the left with cut edges in blue and folded edges in red. The resulting
folded structure is shown on the right.
Fig. 4. The fold pattern of a beam with an angled face is shown
with available connections at either end of the beam highlighted in
green.
beam component. The components also publish their
available connections – edges along which other com-
ponents are allowed to connect.
1 class Cube(Drawing):
2 def __init__(self, edge, top=True, bot=True):
3 Drawing.__init__(self)
4
5 r = Rectangle(edge, edge)
6 self.append(r, 'rm')
7 if top:
8 self.attach('rm.e0', r, 'e2', 'rt', Fold(90))
9 if bot:
10 self.attach('rm.e2', r, 'e0', 'rb', Fold(90))
11
12 self.renameedge('rm.e1', 'e1')
13 for i in range(4):
14 self.attach('e1', r, 'e3', 'r%d' % i, Fold(90))
15 self.renameedge('r%d.e1' % i, 'e1')
Listing 1. A cube is formed by joining square faces at right angles.
2) Joints: Solid components such as the above shapes
can then be combined in a number of ways to generate
the desired motion proﬁles for robot bodies. The sim-
plest joint does not require additional components at
all. Instead, two solids can simply be connected along
an unconstrained folded edge, thus allowing 1 degree
of freedom (DOF) rotational motion. A 2 DOF pivot
can be formed by combining solid components along
two orthogonal edges, or with a dedicated primitive
component as seen in ﬁgure 5. A more compliant
ﬂexure can be created to allow for both rotational and
translational motion, as shown in ﬁgure 6.
A special type of joint can also be used to combine
components without permitting motion. Typically this
would be done by combining adjacent faces into a sin-
Fig. 5. A robust two DOF pivot allows arbitrary angular motion by
forming two orthogonal pivots. Note the tabs and slots added on to
the component to join adjacent edges in the folded structure.
Fig. 6. This ﬂexural element permits longitudinal compression as
well as in-plane and out-of-plane rotations.
Fig. 7. A basic robotic ﬁnger element is simply composed of multiple
beams joined with simple folds along their available connections.
Again, tabs and slots are used to hold the structure together.
gle continuous sheet, but there are many cases where
the geometry does not permit that. Instead, a tab and
slot can be used to ﬁx two disjoint faces relative to each
other. This can be used on a single component as well,
as seen in ﬁgures 5 and 7, allowing a folded structure
to rigidly hold its shape.
B. Derived components
1) Compound structures: The primitives from above
can be combined to make more complex mechanisms.
Joining two beams along an edge creates a hinge,
permitting the relative rotation of the two solids, akin
to a knuckle. A ﬁnger can be generated from a number
of these knuckles, as seen in ﬁgure 7, generated by the
code in listing 2.
1 class Finger(Component):
2 def defComponents(self):
3 ### Identify subcomponents
4 self.components.setdefault("knuckle", Beam())
5
6 def defParameters(self):
7 ### Declare parameters
8 # knuckle parameters inherited by default
9 self.parameters.setdefault("cnt", 2) #no. of knuckles
10 self.parameters.setdefault("len") #length of finger
11
12 def defConnections(self):
13 ### Define edges for connections
14 self.connections.setdefault("top")
15 self.connections.setdefault("bot")
16
17 def setSubParameters(self):
18 ### Impose constraints on parameters
19 self.components["knuckle"].parameters["len"] = 1.0
*
20 self.parameters["len"] / self.parameters["cnt"]
21
22 def assemble(self):
23 ### Assemble the object
24 # Insert the first knuckle
25 self.append("knuckle", "k0")
26 for i in range(1, self.parameters["cnt"]):
27 # Attach the next knuckle bottom to top
28 self.attach(("knuckle", "k%d" % (i-1), "top"),
29 ("knuckle", "k%d" % i, "bot"), Flex())
Listing 2. A simple ﬁnger is composed of a number of beam
components joined end-to-end along ﬂexible hinges.
1463
Fig. 8. Joining sequential cube faces with ﬂexural joints allows 3
DOF motion between each pair of cubes, creating a soft robot arm.
Additional components, namely the tendons and their slots, were
also added into the design to allow for actuation of the arm.
Fig. 9. A number of ﬁngers joined to the edges of a cube forms a
gripping hand. A 3D printed model of the central cube, generated
alongside the 2D fold pattern and assembled into the structure during
the folding process as shown here, can provide rigidity to the device.
Hybrid structures can also be designed from a collec-
tion of different primitives. By alternating cubes with
ﬂexural joints, a compliant multi-DOF soft arm can be
quickly designed, as shown in ﬁgure 8.
2) Robots bodies: These derived mechanisms can be
further reﬁned and combined into complete robot bod-
ies. By attaching a number of ﬁngers onto the edges of a
solid, a gripper is created as shown in ﬁgure 9. Variants
of the tabs, cube, and ﬁnger components were designed
to produce this more sophisticated hand structure.
Attaching this gripper onto the end of the compliant
arm from above then yields a highly controllable ma-
nipulator arm as shown in ﬁgure 10.
Designing this ﬁnal complex robot took no more than
combining the relevant building blocks into structures
of ever increasing complexity, each step of the way
combining only a small number of previously designed
components to make the next mechanism. It is here that
the power of this system is evident. The ﬁrst pass for
each derivative component took less than an hour to
design, code, print, and fold, with subsequent design
iterations happening much quicker. A full robot body
like the manipulator arm could be assembled from a
component library of only primitives in a small handful
of hours. If the library included any of the derivative
elements along the way, perhaps obtained through an
Fig. 10. Putting a gripper at the end of a ﬂexible arm yields a true
robot body, a multi-degree of freedom manipulator arm, shown here
being manually actuated.
open source sharing community, the ﬁnal design could
have been reached even faster. For an expert designer
familiar with the system, the primitives themselves are
similarly quick to implement.
C. Current component database
Over the course of creating bending, crawling,
rolling, and ﬂying robots, a number of components
were designed and added to the component library
to form an ever expanding database of designs. Most
components in the library are quite simple, containing
only a few subcomponents. However, many contain
several levels of hierarchy, recursively building up from
set of primitives. In the current library, there are fewer
than 10 primitives deﬁning solid objects, joints and
hinges, connectors, and specialized geometries such
as mounts and wings. However, simple mechanisms
form the ﬁrst tier of compositional hierarchy, and full
featured robot bodies are already beginning to appear
at the second tier. More complex robots, such as that
as diagrammed in ﬁgure 2 and shown in ﬁgure 10,
may take more levels of nonetheless similarly simple
components.
VI. CONCLUSIONS
A. Contributions
The primary contribution of this work is a new
end-to-end rapid design and fabrication paradigm
that speciﬁes mechanical robot bodies by hierarchi-
cally composing simpler components. An abstraction
was developed allowing for mechanical components
to be described by scripts; a few designed primitive
components plus rules and algorithms for composi-
tion were then sufﬁcient to generate a wide array of
1464
robot mechanisms and bodies. This system was imple-
mented in Python and used to generate design ﬁles
for an origami-inspired plastic print-and-fold process.
A database of primitive components was generated and
used by the system to design and fabricate a number
of robot mechanisms of increasing sophistication and
complexity. The scripts used to create these devices
follow a prescribed format; a graphical frontend atop
this infrastructure would transform this system into a
true WYSIWYG design tool for print-and-fold robots.
B. Future work
In addition to creating robot designs of ever increas-
ing functionality and complexity, there are additional
avenues for research opened up by the work initiated
herein.
1) Design decomposition: The basis for this system
is the hierarchical modular design of robots by non-
experts. However, there are many robot experts that
can and do design custom robots (see for example
[12]–[14]) to a much higher precision than achievable
by a general multi-purpose system. It then becomes
interesting to see whether it is possible to decompose
experts’ designs into parametrizable modules for use
in this system. Big data techniques could potentially be
applied to extract useful reusable design components
from complete designs, thus increasing the depth of
the component library and expanding the scope of
designable robots.
2) Functional speciﬁcation: The current system pro-
duces designs based on geometric speciﬁcations of
the structural elements. These elements can be an-
alyzed for mechanical properties, and reduced-order
parametrized models could be incorporated into the
component deﬁnitions. This could allow a designer
to verify a structure before fabrication. By inverting
the model to calculate structural parameters from me-
chanical requirements, the system could then generate
designs directly from functional speciﬁcations.
3) Automated recommendations: Further analysis of
generated robot designs could also reveal details of
engineering principles. By evaluating existing robot
structures, it might be possible to build a recommen-
dation engine into the design system, further reducing
the burden on a robot designer. As the corpus of
designed robots grows, so too does the engineering
knowledge contained in those designs, and the system
could evolve from a tool to realize conceptual designs
to a tool to propose new designs. Eventually, this leads
us down a path to a full ﬂedged robot compiler, able
to produce complete robot designs from a speciﬁcation
of the problem to be solved.
ACKNOWLEDGMENTS
The authors would like to acknowledge the contri-
butions of Roger Lo and Ian Trase, whose assistance in
this project was invaluable.
This work was supported by the National Science
Foundation, grant numbers 1240383 and 1138967, for
which the authors express thanks.
REFERENCES
[1] J. Forlizzi and C. DiSalvo, “Service robots in the domestic
environment: a study of the roomba vacuum in the home,” in
Proc. ACM SIGCHI/SIGART conf. on HRI, 2006, pp. 258–265.
[2] G. V . Lauder, “Flight of the roboﬂy,” Nature, vol. 412, no. 16, pp.
688–689, 2001.
[3] “AFRON design challenges - african robotics network
(AFRON),” http://robotics-africa.org/afron-design-challenges.
html, [Online; accessed 01-Feb-2014].
[4] “MakerBot — 3D Printers — 3D printing,” http://www.
makerbot.com/, [Online; accessed 01-Feb-2014].
[5] “Thingiverse - digital design for physical objects,” http://www.
thingiverse.com/, [Online; accessed 01-Feb-2014].
[6] C. Mavroidis, K. J. DeLaurentis, J. Won, and M. Alam, “Fabri-
cation of non-assembly mechanisms and robotic systems using
rapid prototyping,” Journal of Mechanical Design, vol. 123, no. 4,
pp. 516–524, 2001.
[7] H. Lipson, F. C. Moon, J. Hai, and C. Paventi, “3-d printing the
history of mechanisms,” Journal of Mechanical Design, vol. 127,
no. 5, pp. 1029–1033, 2005.
[8] C. Richter and H. Lipson, “Untethered hovering ﬂapping ﬂight
of a 3d-printed mechanical insect,” Artiﬁcial life, vol. 17, no. 2,
pp. 73–86, 2011.
[9] J. Rossiter, P . Walters, and B. Stoimenov, “Printing 3d dielectric
elastomer actuators for soft robotics,” in SPIE Smart Structures
and Materials+ Nondestructive Evaluation and Health Monitor-
ing. International Society for Optics and Photonics, 2009, pp.
72 870H–72 870H.
[10] I. Shimoyama, H. Miura, K. Suzuki, and Y. Ezura, “Insect-
like microrobots with external skeletons,” Control Systems, IEEE,
vol. 13, no. 1, pp. 37–41, 1993.
[11] A. M. Hoover and R. S. Fearing, “Fast scale prototyping for
folded millirobots,” in Robotics and Automation (ICRA), 2008.
IEEE, 2008, pp. 886–892.
[12] C. Onal, R. Wood, and D. Rus, “An origami-inspired approach
to worm robots,” Mechatronics, IEEE/ASME Transactions on,
vol. 18, no. 2, pp. 430–438, April 2013.
[13] D. E. Soltero, B. J. Julian, C. D. Onal, and D. Rus, “A lightweight
modular 12-DOF print-and-fold hexapod,” in Intelligent Robots
and Systems (IROS), 2013. IEEE, 2013, pp. 1465–1471.
[14] A. Mehta, D. Rus, K. Mohta, Y. Mulgaonkar, M. Piccoli, and
V . Kumar, “A scripted printable quadrotor: Rapid design and
fabrication of a folded MAV,” in International Symposium on
Robotics Research (ISRR), 2013., 2013.
[15] E. D. Demaine and T. Tachi, “Origamizer: A practical algorithm
for folding any polyhedron,” 2009.
[16] R. Lang, Origami design secrets : mathematical methods for an
ancient art. A K Peters/CRC Press, 2012.
[17] “Pepakura designer,” http://www.tamasoft.co.jp/
pepakura-en/, [Online; accessed 01-Feb-2014].
[18] S. M. Felton, M. T. Tolley, C. D. Onal, D. Rus, and R. J. Wood,
“Robot self-assembly by folding: A printed inchworm robot,”
in Robotics and Automation (ICRA), 2013 IEEE International Con-
ference on. IEEE, 2013, pp. 277–282.
[19] C. Sung, E. D. Demaine, M. L. Demaine, and D. Rus, “Joining
unfoldings of 3-D surfaces,” in Proceedings of ASME 2013 Inter-
national Design Engineering Technical Conferences and Computers
and Information in Engineering Conference (IDETC/CIE), 2013.
1465
