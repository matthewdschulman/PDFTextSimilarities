Modeling and Reusing Robotic Software Architectures:
the HyperFlex Toolchain
Luca Gherardi and Davide Brugali
Abstract— During the last years robotic researchers have
been able of developing extremely complex applications. The
complexity of these applications is reﬂected by the variety of
functionalities involved, which are provided by a signiﬁcant
number of components. Although the reuse of software com-
ponents is becoming a best-practice, the reuse of reference ar-
chitectures, which model sub-systems providing functionalities
common to a great number of applications, is still uncommon.
This paper provides two contributions to this topic: (a) a
development process that deﬁnes how reference architectures
can be exploited for building robotic applications, (b) the
HyperFlex software toolchain, which has been developed for
supporting the design and the reuse of reference architectures.
The idea presented in this paper is simple yet powerful: instead
of building complex applications by reusing single components,
even more complex applications can be developed by reusing
reference architectures of mature sub-systems.
I. INTRODUCTION
Robot software systems are typically concurrent, dis-
tributed, embedded, real-time and data intensive. Compu-
tation performance has always been a major requirement,
especially for autonomous robots that process sensory in-
formation and have to react in a timely fashion to events
occurring in the environment. Nowadays however, due the
increasing complexity of robotic applications, modularity,
reusability and composability are also considered important
factors. In order to satisfy these conﬂicting requirements,
robotic control systems have evolved from monolithic ap-
plications, which ran on a single processor, to distributed
component-based architectures [1].
These software systems are characterized by complex in-
teractions between components. Managing concurrent access
to shared resources by multiple activities while guaranteeing
real-time performance is one of the main issues. For this rea-
son research teams developed robotics-speciﬁc component-
based frameworks, which offer mechanisms for real-time ex-
ecution, synchronous and asynchronous communication, data
ﬂow and control ﬂow management, and system conﬁguration
(see [2] for a survey).
Thanks to these software frameworks, robotic researchers
have developed hundreds of open source components and
designed extremely complex applications, such as robots
that cooperate to make pancakes [3] or that can fetch a
drink from the fridge and deliver it to a human [4]. The
complexity of these applications is reﬂected by the variety of
functionalities involved, which are provided by a signiﬁcant
L. Gherardi is with the Institute for Dynamic Systems and Control, ETH
Z¨ urich, Switzerland. lucagh@ethz.ch. D. Brugali is with the Dept.
of Engineering, University of Bergamo, Italy brugali@unibg.it
number of components. Designing these components in such
a way that they can be reused in different applications is a
difﬁcult task, and even more challenging is designing the
system architecture. The reason is that these tasks require
advanced software engineering techniques, which are not
always mastered by robotic software developers.
In the last years few research teams have tried to ad-
dress this problem by developing robotics-speciﬁc software
toolchains. These tools are designed according to the Model
Driven Engineering (MDE) paradigm and facilitate the de-
sign of robotic component-based applications. An example
is BRIDE, which has been developed in the context of
the European Project BRICS [5] and allows the users to
graphically design models of new (or legacy) software com-
ponents. These models describe the components’ interfaces
and are decoupled from their implementations. Software
engineers design these models and robotic developers can
compose them for designing their applications and generating
a conﬁguration ﬁle for the system deployment [6].
These toolchains provide the users with the possibility
of reusing the model of the same component for designing
different applications. However the same operation is not
possible with models of larger portions of a system. This
strong limitation prevents software engineers to deﬁne ref-
erence architectures for mature functional sub-systems (e.g.
robot navigation and robot manipulation) and distribute them
as conﬁgurable units that can be composed for building
complex applications.
A reference architecture for a speciﬁc domain is an archi-
tecture template for all the software systems in that domain.
It deﬁnes the fundamental components of the domain and
the relations between them. The architecture for a particular
sub-system is the result of the conﬁguration of the reference
architecture [7]. For example, according to this deﬁnition,
a 3D perception expert can deﬁne a reference architecture
for a sub-system providing perception functionalities (i.e.
image acquisition, ﬁltering, feature extraction, registration,
segmentation, etc.). This reference architecture can be sub-
sequently conﬁgured by robotic developers and integrated
with other components and/or sub-systems for developing
complex mobile manipulation applications.
The deﬁnition of reference architectures is already a best
practice in other domains (for example the automotive com-
munity has deﬁned the AUTOSAR standard [8]). Their adop-
tion provides two major beneﬁts. First, they can be designed
by developers with a software engineering background and
reused by other developers that do not master software
engineering techniques. Second, researchers can focus on the
2014 IEEE International Conference on Robotics & Automation (ICRA)
Hong Kong Convention and Exhibition Center
May 31 - June 7, 2014. Hong Kong, China
978-1-4799-3684-7/14/$31.00 ©2014 IEEE 6414
development of algorithms related to their speciﬁc domain
and exploit reference architectures for other functionalities,
which are required by the applications but are not part of
the developers’ competencies. Based on these arguments we
claim that the deﬁnition of reference architectures would
boost the development, the testing and the benchmark of
new components, sub-systems and entire applications.
This paper provides two main contributions: (a) a de-
velopment process that deﬁnes how reference architectures
can be conﬁgured and integrated in order to build complex
robotic applications; and (b) a meta-model and a graphical
editor that support the users during the development process
and are integrated with the HyperFlex toolchain [9][10]. The
two contributions are the natural extension of what has been
developed in BRICS: a set of principles and tools that support
the software engineers and the robotic developers in the task
of designing, reusing and composing robotic systems. The
idea presented in the paper is simple yet powerful: instead of
building complex applications by reusing single components,
we want to provide the capability of building even more
complex applications by reusing and composing reference
architectures of entire sub-systems.
The rest of the paper is organized as follows. Sec. II
introduces the development process. Sec. III describes the
meta-model and the graphical editor. Sec. IV exempliﬁes
by means of a case study the concepts previously deﬁned.
Finally Sec. VI and Sec. V present related works and draw
relevant conclusions.
II. THE DEVELOPMENT PROCESS
This section introduces the guidelines that describes how
reference architectures can be used for boosting the develop-
ment of new applications. Two possible processes, which can
be complementary (as presented in Sec. IV), are described
below.
A. Integrating customer-speciﬁc components
The ﬁrst process that exploits reference architectures is
depicted in Fig. 1. The reference architecture deﬁnes a
functional sub-system template in terms of: (a) interfaces of
customer-speciﬁc and customer-independent components, (b)
connections between them and (c) components’ conﬁguration
properties. Customer-independent components are general
components that can be downloaded and reused in several
applications (e.g. path planning). Customer-speciﬁc compo-
nents are instead components the implementation of which
has to be developed from scratch because is strongly coupled
with the developer’s requirements (e.g. hardware drivers).
The development process is made of two activities. During
the ﬁrst one (Customer speciﬁc components development) the
reference architecture is used as interface speciﬁcation for the
implementation of the customer-speciﬁc components. During
the second activity (Integration) the information provided
by the reference architecture is used for the deﬁnition of
the connections between customer-speciﬁc and customer-
independent components and for the conﬁguration of the
components’ parameters. These two activities customize the
Reference 
Architecture
Model
Customer 
Speciﬁc 
Component 
Development
Document
Document
Customer 
Speciﬁc 
Components
Integration
Reference 
Architecture
Conﬁgured Model
Human 
activity
Models and 
source code
Information
ﬂow
Document
Document
Customer 
Independent 
Components
Fig. 1: Customer-speciﬁc components customize the refer-
ence architecture of a functional sub-system.
template provided by the reference architecture and produce
the concrete architectural model of the functional sub-system
(Reference Architecture Conﬁgured Model). Note that these
models must conform to a software framework speciﬁc meta-
model, such as the Orocos component meta-model presented
in Sec. III or a ROS component meta-model.
This process can be exempliﬁed as follows. A reference
architecture for controlling a robotic arm deﬁnes the inter-
faces of the components providing all the required function-
alities (e.g. inverse kinematics and trajectory following) and
the interfaces of the component needed for interfacing the
robot. This component, being customer-speciﬁc, has to be
developed and integrated in the reference architecture. The
result is a concrete sub-system for controlling a manipulator,
which can be deployed or alternatively reused as reference
architecture for building more complex systems.
B. Reusing reference architectures in complex applications
The second process that exploits reference architectures is
depicted in Fig 2. In this case a reference architectures is a
reusable building block, which is composed with other sub-
systems to develop complex applications. We assume that all
the components of the reference architecture are available.
They parameters can be conﬁgured but they need not to be
implemented (the reference architecture can be the result of
the previous process). For example an application developer
can design a sub-systems providing high-level functionalities
(e.g. trajectory generation) and integrate it with the reference
architecture designed for controlling the arm.
The development process is made of two activities. During
the ﬁrst one (New Functionalities Development) the ap-
plication developer implements new sub-systems providing
functionalities that are application-speciﬁc and are not yet
available. These sub-systems leverage on and coordinate the
functionalities provided by the reference architectures. Dur-
ing the second activity (Integration) the architecture of the
ﬁnal application is designed by integrating the application-
speciﬁc sub-systems with the conﬁgured reference archi-
tectures. Note that when several reference architectures are
composed, they typically provide different capabilities that
do not overlap (e.g. manipulation and perception). This
ensures that two sub-systems designed by different parties
do not rely on the same components.
The main difference with respect to the development pro-
cess presented in Sec. II-A is that in this case the reference
6415
New 
Functionalities 
Development
Document
Document
Sub-system
Architecture
Models
Integration
Document
Document
Reference 
Architecture
Conﬁgured Models
Application 
Architecture
Model
Fig. 2: Conﬁgured reference architectures can be composed
with custom sub-systems for building complex applications.
architecture is just a reusable black-box. It does not provide
speciﬁcations about the architecture of the ﬁnal application.
This approach allows the developers to (a) focus on the
implementation of the application-speciﬁc components that
provide the functionalities for which they are expert; and
(b) leverage on existing solutions for other functionalities
required by the application.
III. META-MODEL AND TOOLS
A component-meta model describes the architectural ele-
ments that can be used for modeling software architectures
and how they can be composed. This section brieﬂy intro-
duces the main concepts of Orocos and presents the meta-
model and the editor developed for supporting the design
and the reuse of reference architectures. Due to limited
space we focus only on Orocos, however the meta-models
and the tools are available also for ROS. Note that, in
order to be deployable, an architectural model must conform
to a speciﬁc software framework. The transformation of a
framework-independent model into an framework-speciﬁc
model is an action that cannot be fully automated, due to
the architectural mismatches that exist between the different
robotic software frameworks (communication mechanisms,
behavioral models, etc.). This is the main reason for which
architectural models cannot be completely modeled by means
of a framework-independent meta-model. The use of a
framework-speciﬁc meta-models is instead required.
A. Orocos
Orocos is a software framework particularly suited for the
design of hard real-time robotic systems. An Orocos system
is a ﬂat graph made of several task contexts (i.e. compo-
nents). Task contexts interact according to two paradigms:
(a) by exchanging data and events asynchronously through
input/output data ports (data ﬂow communication paradigm),
and/or (b) by synchronously or asynchronously calling opera-
tions provided by other task contexts (client/server communi-
cation paradigm). Finally properties allows the conﬁguration
of the Task Context’s execution behavior.
Orocos applications are deployed by means of a tool called
Deployer, which is in charge of (a) loading the binary ﬁles
containing the implementation of the various components,
(b) instantiating them, (c) setting the desired values for
the components’ properties, (d) connecting the components’
interfaces, and (e) starting the application. The information
required by the deployer for executing these operations is
encoded in a ﬁle (script or XML), which is called deployment
ﬁle and describes the application architecture.
B. Orocos Component Meta-model
The Orocos meta-model allows developers to model the
architecture of Orocos systems. Although a meta-model of
Orocos is provided with BRIDE, we have redeﬁned it in
order to overcome the following limitations: (a) the absence
of composition mechanisms, which makes hard the deﬁni-
tion and the reuse of reference architectures, and (b) the
impossibility of modeling service-based communications. In
this section, in order to avoid ambiguities, we call our meta-
model the HyperFlex Orocos component meta-model.
Figure 3 depicts the HyperFlex Orocos component meta-
model, which is organized in three parts for sake of read-
ability. White classes were deﬁned for BRIDE, gray classes
have been designed for the HyperFlex meta-model. An Oro-
cos System contains a Composite, which hierarchically
aggregates TaskContexts according to the Composite
design pattern. In the rest of the paper we use the word com-
ponent (i.e. AbstractComponent) when we introduce
concepts that apply to both task contexts and composites.
Note that a composite is only a modeling entity. It does not
map to any implementation entity deﬁned in Orocos. Orocos
allows the service composition, but not the composition of
components. The composite is a powerful mechanism that
allows us to introduce the hierarchical composition at model
level and to design and distribute reference architectures.
Figure 3a depicts the entities used to model the mech-
anism for the data-ﬂow and event-ﬂow communication.
Task contexts may have several input and output data
ports (TCInputDataPorts and TCOutputDataPorts
respectively), which are typed by aDataType and are con-
nected by means of ConnectionPolicies. Input port
also deﬁnes the boolean attribute eventPort. If true the
component computation is triggered by new events received
by this port, if false the component computation is triggered
periodically according to the component’s period.
A Connection Policy deﬁnes the communication channel
between two ports and is characterized by a name, a type
(data, buffer, or circular buffer), a lock policy (unsync, locked
or lock free), a buffer size (which is always 1 when the type is
data), and a transport (Orocos, MQueue, ROS), which deﬁnes
the middleware used for the communication. A Connection
Policy holds a reference to the two ports when it is used for
connecting two Orocos task contexts, while it speciﬁes only
the source (output port) or the target (input port) when it is
used for connecting an Orocos task context to a component
than runs under a different software framework, e.g. ROS.
In this case the ﬁeld note is used for specifying the name
of the topic on which the data has to be published (or read).
A composite may expose a subset of the ports of its
components in order to provide/require data to/from com-
ponents deﬁned in other composites. For this purpose, a
composite deﬁne a set of CompInputDataPorts and/or
CompOutputDataPorts, which hold a reference to the
exposed ports. OCL constraints ensure that connections are
6416
namespace : EString
className : EString
Period : EDouble
Priority : EDouble
TaskContext
Composite
type : DataType
value : EString
TCProperty
0…*
name : EString
System
1
0…* name : EString
AbstractComponent
name : EString
Property CompProperty
0…*
1 exposedProperty
namespace : EString
className : EString
Period : EDouble
Priority : EDouble
TaskContext
Composite
CompOperationCaller
name : EString
PeersConnection
CompOperation
name : EString
Operation
srvName : EString
type : Service
bool : ownThread
TCOperation
name : EString
OperationCaller
srvName: EString
type : Service
TCOperationCaller
1
1 target
source
1
exposedOp
exposedOpCaller
1
0…* 0…*
0…* 0…* 0…*
name : EString
System
1
0…*
name : EString
AbstractComponent
(b)
(c)
(a)
namespace : EString
className : EString
Period : EDouble
Priority : EDouble
TaskContext
Composite
CompOutputDataPort
name : EString
type : ConnectionType
policy : LockPolicy
size : EInt
transport : ConnectionTransport
note : EString
ConnectionPolicy
CompInputDataPort InputDataPort
type : DataType
eventPort : EBoolean
TCInputDataPort
OutputDataPort
type : DataType
TCOutputDataPort
0...1
0...1 target
source
1 exposedPort
exposedPort 1
0…* 0…*
0…* 0…* 0…*
name : EString
System
1
name : EString
AbstractComponent
name : EString
DataPort
- DATA
- BUFFER
- CIRCULAR_BUFFER
<<enumeration>> 
ConnectionType
- UNSYNC
- LOCKED
- LOCK_FREE
<<enumeration>> 
LockPolicy
- OROCOS
- MQUEUE
- ROS
<<enumeration>> 
ConnectionTransport
0…*
0…*
Fig. 3: The Orocos component meta-model (data-ﬂow interfaces (a), service interfaces (b), component properties (c))
deﬁned between ports that are typed by the same data type
and belong to components deﬁned in the same composite.
Figure 3b depicts the entities used to model the
mechanisms for service-based communication. Task con-
texts can deﬁne provided and required service inter-
faces (TCOperation andTCOperationCaller respec-
tively). They are typed by a Service (operation signature)
and can be promoted at the level of the composite interfaces
(CompOperation andCompOperationCaller respec-
tively). Operations and operation callers can be connected
by means ofPeersConnection entities. OCL constraints
ensure that peers connections are created between operations
and operation callers that conform to the same service and
belong to components deﬁned in the same composite.
Figure 3c depicts the mechanisms for the deﬁnition of
properties. A Property provides an interface for setting
the value of a parameter deﬁned in the implementation of a
task context (e.g. the PID parameters). Properties, as well as
the other interfaces, can be promoted at the composite level.
C. Tool support
On the top of the component meta-model presented above
we have developed an Eclipse plugin that allows the design
and the reuse of reference architectures (some screenshots are
depicted in Fig. 4). This tool provides the means for model-
ing software components, connecting their ports/services and
wrapping them into a composite, which promotes some of
the components’ interfaces. Note that, being the composite
a modeling entity, a call to a promoted interface is the
equivalent of a call to the associated component interface.
When this is not the desired behavior, it is useful to deﬁne an
additional component inside the composite (i.e. coordinator),
which exposes its interfaces to the composite level and
coordinates the execution of the other components deﬁned
in the composite (the interfaces of these components have to
be connected to the coordinator and not anymore exposed).
The editor provides a mechanism for importing an existing
composite in a higher-level composite, allowing in this way
the hierarchical composition.
Once the application architecture has been designed, a
model-to-text transformation provided by the editor generates
the deployment ﬁle, which can be used by the Orocos
deployer for launching the application.
IV. CASE STUDY
In this section we illustrate by means of a case study
how reference architectures can boost the development of
different systems. We have analyzed the architectures of two
existing real applications and we have refactored them in
order to decouple the commonalities from the variabilities.
The two applications were developed by researchers of the
IDSC group at ETH Zurich. In the ﬁrst one a KUKA
Lightweight Arm (LWR) is used for drawing Japanese char-
acters [11], while in second the same arm is used for opening
6417
(a) The reference architecture of the Arm Trajectory Follower
(b) The Calligraphy architecture (c) The Learning architecture
Fig. 4: The case study architectures: white rectangles depicts components (grey header) and composites (blue header), yellow
rectangles input ports, cyan squares output ports, green squares operations, and red squares operation callers.
a cabinet door and learning its kinematic model [12]. These
applications have been chosen because they are based on a
set of common functionalities but execute two signiﬁcantly
different tasks. This characteristic allows us to emphasis the
advantages of deﬁning and reusing reference architectures.
The result of their refactoring consists of a new design for
the two applications. They are now built on the top of a
reference architecture, which encodes the commonalities and
provides functionalities for controlling a robotic arm.
Sections IV-A and IV-B describe how the activities of the
development processes presented respectively in Sec. II-A
and II-B have been applied to the case study.
A. Integrating customer-speciﬁc components
Figure 4a depicts a reference architecture providing low-
level functionalities for controlling a robotic arm and follow-
ing cartesian space and joint space trajectories (the ﬁgure
is a screenshot of HyperFlex). The components deﬁned
in this architecture can be interfaced with a general arm,
provided that there is a driver for controlling it and that this
driver offers the same interfaces described in the architecture
(being the driver an hardware abstraction, the cartesian
position/impedance control and the joint control can be im-
plemented in a software component, or in a composite, when
not provided by the hardware). The reference architecture is
a composite made of the following components:
 Arm Driver: implements the joint and cartesian control
of the arm. It deﬁnes a property for setting the control
mode (joint or cartesian space) and provides ports for
reading set points and publishing measured data (both in
joint and cartesian space). Finally it has an output port
for sending event notiﬁcations when a new command is
required (e.g. previous command completed).
 Joint Space Trajectory Iterator (JS Trj Iter): re-
ceives as input a continuous (polynomial function) or
discrete joint trajectory (vector of joint conﬁgurations)
and interacts with the Arm Driver for following it. It
reads the current joint conﬁguration and sends back the
next desired conﬁguration upon request (triggered by
the event New Cmd Event).
 Cartesian Space Trajectory Iterator (CS Trj Iter):
receives as input a continuous (polynomial function or
spline) or discrete cartesian trajectory (vector of poses)
and interacts with the Arm Driver for following it. It
provides a service for setting the control mode, which
can be either position or impedance. This component
reads the current end effector pose and produces as
output, upon request (event New Cmd Event), the
next pose. In compliant mode the position is sent
directly to the Arm Driver while in position mode it
is sent to the Inverse Kinematics component.
 Inverse Kinematics (Inv Kin): implements the veloc-
ity and position inverse kinematics and is conﬁgured
according to an XML ﬁle that describes the kinematic
model of the arm. It receives as input a desired cartesian
pose and using the data produced by the Arm Driver
computes the corresponding joint conﬁguration.
The Arm Trajectory Follower composite exposes a subset
of the data ports provided by its components, in particular the
6418
output regarding the measured data, the events for notifying
the completion of a trajectory (Ack Crt Trj and Ack
Jnt Trj), and the continuous and discrete trajectories
inputs. Moreover it promotes the operation for setting the
cartesian control mode.
We assume that this reference architecture is designed
by a software expert, who makes it available to robotic
developers. The ﬁrst step that leads to the implementation of
the applications described above consists of conﬁguring the
reference architecture according to the process presented in
Sec. II-A. During the ﬁrst activity the Arm Driver interfaces
deﬁned in the reference architecture are used as speciﬁcation
for implementing a component that provides a driver for
the KUKA LWR (customer-speciﬁc component). During the
second activity this component is integrated with the other
components of the reference architecture, providing in this
way a reusable composite.
The process described in Sec. II-A allows the development
of a trajectory follower for a general arm, in this speciﬁc case
the KUKA LWR. The only task required to the developer
is the implementation of the arm driver. The reference
architecture relieves the developers from the tasks of (a)
deﬁning the driver interface, (b) implementing the other
components and (c) deﬁning the sub-system architecture.
B. Reusing reference architectures in complex applications
The process described in Sec. II-B allows the development
of different applications, which are built on the top of
the Arm Trajectory Follower. This subsection presents the
architecture of the two applications described above.
Figure 4b depicts the architecture of the ﬁrst application.
Two new components, the Calligraphy and the Joint Space
Trajectory Generator (JS Trj Gen), use the functional-
ities provided by the Arm Trajectory Follower composite.
The Calligraphy component reads a set of XML ﬁles, which
contains the instructions for drawing Japanese characters, and
generates for each of them a set of discrete trajectories, which
deﬁnes how the strokes that compose a character have to
be drawn. The Calligraphy component sends to the JS Trj
Generator the joint conﬁguration corresponding to the pose in
which the brush has to be moved for drawing the ﬁrst stroke.
The generator computes a continuous joint trajectory and
sends it to the Arm Trajectory Follower, which executes it
and notiﬁes the Calligraphy component when the brush is in
the desired pose. When the Calligraphy component receives
this event, it sends the stroke discrete trajectory to the Arm
Trajectory Follower and waits until the stroke is completed.
Figure 4c depicts the architecture of the second appli-
cation. The functionalities provided by the reference archi-
tecture are used by two components, the Cartesian Space
Trajectory Generator (CS Trj Gen) and the Learner. In
the initial conﬁguration the arm is attached to the handle of
a cabinet door (whose kinematic model is unknown) and is
controlled in compliant mode. The CS Trj Generator sends to
the Arm Trajectory Follower a discrete cartesian trajectory
consisting of a straight line. Due to the single degree of
freedom of the door, which is on the Z axis, the arm will
not follow the desired trajectory. The Learner component
reads the intermediate poses of the arm and use them for
estimating the kinematic model of the door, which is sent to
the CS Trj Generator. Using this model the CS Trj Generator
is able to compute a more appropriate trajectory, which takes
into account the degree of freedom of the door.
The two applications have been designed by reusing the
Arm Trajectory Follower as a black box. Thanks to this
approach developers can focus on the design of application-
speciﬁc functionalities and are relieved from the task of
developing low-level components. Note that the architecture
of the two applications are not meant to represent reference
architectures. In fact they share only the Arm Trajectory
Follower and for the rest are signiﬁcantly different.
V. RELATED WORKS
During the last decade advanced software engineering
techniques have been progressively exploited for the develop-
ment of reusable robotic systems [13], including component-
based architectures [14] and Model Driven Engineering [15].
The European Project BRICS adopted these techniques
and produced some interesting results. Two of them are the
BRICS Component Model (BCM) [16] and BRIDE.
The BCM is a software framework-independent compo-
nent model, which provides a set of guidelines for reason-
ing about the design of component-based robotic systems.
However, being the BCM software framework independent, it
cannot be used for modeling real systems. For this reason it is
necessary to deﬁne software framework speciﬁc component
meta-models, similar to the one presented in Sec III. Note
that the BCM provides an elementary composition mecha-
nism, which simply speciﬁes that component can encapsulate
sub-components. This mechanism is not enough for model-
ing reference architectures. We extended it by applying the
Composite Pattern and the concept of interface promotion.
BRIDE is an Eclipse plugin that supports the robotic
developers during the process of designing component based
systems. It provides the users with the possibility of: (a)
loading a set of previously modeled components and/or
designing new components; (b) connecting the components
interfaces in order to deﬁne their interactions; (c) generating
the conﬁguration ﬁle that describes the architecture and
can be used for the deployment. The HyperFlex toolchain
presented in this paper is the natural extension of BRIDE and
improves it in two directions. First, it provides a powerful
composition mechanism that allows the reuse of models
with a larger level of granularity. Second, it supports all
the communications paradigms provided by Orocos (the
client/server paradigm is not supported in BRIDE).
The Proteus project [17] is another model-driven robotics
initiative that provides a component meta-model and a soft-
ware toolchain. Similar to BCM, the Proteus component-
model contains a very basic composition mechanism, which
is not enough for modeling reference architectures. Indeed
the relationship between the interfaces of a composite and
the interfaces of its components is not clearly presented in
the paper.
6419
Another model-driven approach from the robotics domain
is OpenRTM, a robotic software framework that implements
the RT-Middleware [18] speciﬁcation. Differently from ROS
and Orocos, which do not provide an explicit meta-model,
the OpenRTM meta-model is explicitly deﬁned and in-
tegrated with a software toolchain that provides features
similar to the ones provided by HyperFlex. As well as
the component model presented in this paper, OpenRTM
provides the primitives for hierarchical composition. How-
ever in OpenRTM the composite is used for coordinating
the execution of its components. In our case instead, the
composite is a modeling and packaging entity, which allows
the design and the distribution of reference architectures.
A development process for designing robotic applications
is presented in a SmartSoft paper [19]. However according to
this process the SmartSoft System Integrator is in charge of
connecting and conﬁguring existing components according to
the requirements of a speciﬁc application, and for this reason
his work “is rarely reusable by others” [19]. In contrast, in
our approach we promote the deﬁnition of sub-system refer-
ence architectures that are conﬁgurable and easily reusable
in several applications.
Finally MoveIt! [20] is a Motion Planning Framework
recently developed in the context of the ROS community. It
deﬁnes a plugin-based architecture, which allows the users
to easily change and conﬁgure the implementation of the
different functionalities (e.g. kinematics, collision detection,
etc.). In this direction MoveIt! provides a reference architec-
ture for motion planning systems. However, differently from
the work proposed in this paper, MoveIt! does not follow
a model-based approach. This makes harder the integration
with other model-based techniques, such as the ones related
to software variability management [9].
VI. CONCLUSIONS AND FUTURE WORKS
The aim of this paper was promoting the deﬁnition of ref-
erence architectures that model mature robotic sub-systems
and provide functionalities common to a great number of ap-
plications. We presented a development process that deﬁnes
the guidelines for exploiting reference architectures, and the
open source HyperFlex toolchain, which provides the tools
that support the development process.
The case study demonstrated how reference architectures
can be used and composed for building complex applications.
In our opinion, the design of component-based reference
architectures for robotics functional sub-systems and their
distribution by means of remote repositories similar to the
Ubuntu Advanced Packaging Tool (APT) can signiﬁcantly
boost the development of new applications and bring great
beneﬁts to the robotics community.
In the future we plan to integrate Orocos and ROS meta-
models and editors with the tools designed for modeling
and resolving robotic software variability [9][21][22], which
were previously integrated with BRIDE.
ACKNOWLEDGMENTS
The authors would like to thank Nico Huebel and Gajamo-
han Mohanarajah for the valuable comments. The research
accomplished at the University of Bergamo received found-
ing from the European Project FP7 BRICS.
REFERENCES
[1] D. Brugali and P. Scandurra. Component-based robotic engineering
(part I). Robotics & Automation Magazine, IEEE, 2009.
[2] D. Brugali and A. Shakhimardanov. Component-based robotic engi-
neering (part II). Robotics & Automation Magazine, IEEE, 2010.
[3] M. Beetz, U. Klank, I. Kresse, A. Maldonado, L. Mosenlechner,
D. Pangercic, T. Ruhr, and M. Tenorth. Robotic Roommates Making
Pancakes. In International Conference on Humanoid Robots (Hu-
manoids), 2011.
[4] J. Bohren, R. B. Rusu, E. G. Jones, E. Marder-Eppstein, C. Pantofaru,
M. Wise, L. Mosenlechner, W. Meeussen, and S. Holzer. Towards
Autonomous Robotic Butlers: Lessons Learned with the PR2. In
International Conference on Robotics and Automation (ICRA), 2011.
[5] BRICS. http://www.best-of-robotics.org.
[6] N. Hochgeschwender, L. Gherardi, A. Shakhirmardanov, G. Kraet-
zschmar, D. Brugali, and H. Bruyninckx. A Model-based Approach
to Software Deployment in Robotics. In International Conference on
Intelligent Robots and Systems (IROS), Tokyo, Japan, 2013.
[7] A. E. Hassan and R. C. Holt. A Reference Architecture for Web
Servers. In Working Conference on Reverse Engineering, 2000.
[8] S. F¨ urst, J. M¨ ossinger, S. Bunzel, T. Weber, F. Kirschke-Biller,
P. Heitk¨ amper, G. Kinkelin, K. Nishikawa, and K. Lange. Autosar–
a worldwide standard is on the road. In International Congress on
Electronic Systems for Vehicles, 2009.
[9] L. Gherardi. Variability Modeling and Resolution in Component-based
Robotics Systems. PhD thesis, Universit` a degli Studi di Bergamo,
2013.
[10] L. Gherardi and D. Brugali. The HyperFlex Toolchain. http://
robotics.unibg.it/hyperflex.
[11] S. Mueller, N. Huebel, M. Waibel, and R. D’Andrea. Robotic
Calligraphy - Learning How to Write Single Strokes of Chinese and
Japanese Characters. In International Conference on Intelligent Robots
and Systems, 2013.
[12] M. Waibel, M. Beetz, J. Civera, R. D’Andrea, J. Elfring, D. Galvez-
Lopez, K. Haussermann, R. Janssen, J.M.M. Montiel, A. Perzylo,
B. Schiessle, M. Tenorth, O. Zweigle, and R. van de Molengraft.
Robotics Automation Magazine, IEEE, 2011.
[13] D. Brugali and E. Prassler. Software Engineering for Robotics.
Robotics & Automation Magazine, IEEE, 2009.
[14] D. Kortenkamp, R. Simmons, and D. Brugali. Robotic Systems
Architectures and Programming. Springer Handbook of Robotics -
Second Edition, 2013, in press.
[15] C. Schlegel, A. Steck, D. Brugali, and A. Knoll. Design Abstraction
and Processes in Robotics: from Code-driven to Model-driven Engi-
neering. In International Conference on Simulation, Modeling and
Programming for Autonomous Robots (SIMPAR). 2010.
[16] H. Bruyninckx, N. Hochgeschwender, L. Gherardi, M. Klotzb¨ ucher,
G. Kraetzschmar, and D. Brugali. The BRICS Component Model: a
Model-based Development Paradigm for Complex Robotics Software
Systems. In Annual ACM Symposium on Applied Computing (SAC).
[17] S. Dhouib, S. Kchir, S. Stinckwich, T. Ziadi, and M. Ziane. RobotML,
a Domain-Speciﬁc Language to Design, Simulate and Deploy Robotic
Applications. In International Conference on Simulation, Modeling
and Programming for Autonomous Robots (SIMPAR). 2012.
[18] N. Ando, S. Kurihara, G. Biggs, T. Sakamoto, H. Nakamoto, and
T. Kotoku. Software Deployment Infrastructure for Component Based
RT-Systems. Journal of Robotics and Mechatronics, 2011.
[19] C. Schlegel, A. Steck, and A. Lotz. Robotic Software Systems:
From Code-Driven to Model-Driven Software Development. Robotic
Systems - Applications, Control and Programming, 2012.
[20] MoveIt! http://moveit.ros.org.
[21] L. Gherardi and D. Brugali. An Eclipse-based Feature Models
Toolchain. In Italian Workshop on Eclipse Technologies (EclipseIT),
2011.
[22] D. Brugali, L. Gherardi, A. Biziak, A. Luzzana, and A. Zakharov. A
Reuse-Oriented Development Process for Component-based Robotic
Systems. In International Conference on Simulation, Modeling and
Programming for Autonomous Robots (SIMPAR), 2012.
6420
