Reactive Sampling-Based Temporal Logic Path Planning
Cristian Ioan Vasile and Calin Belta
Abstract— We develop a sampling-based motion plan-
ning algorithm that combines long-term temporal logic
goals with short-term reactive requirements. The mission
speciﬁcation has two parts: (1) a global speciﬁcation given
as a Linear Temporal Logic (LTL) formula over a set
of static service requests that occur at the regions of
a known environment, and (2) a local speciﬁcation that
requires servicing a set of dynamic requests that can be
sensed locally during the execution. Our method consists
of two main ingredients: (a) an off-line sampling-based
algorithm for the construction of a global transition system
that contains a path satisfying the LTL formula, and (b)
an on-line sampling-based algorithm to generate paths
that service the local requests, while making sure that
the satisfaction of the global speciﬁcation is not affected.
Building on our previous work [1], the focus of this paper
is on the on-line part of the overall method.
I. INTRODUCTION
A central problem in motion planning is to generate
a path for a robot from an initial to a ﬁnal desired
position in an environment with obstacles. The most
used algorithms are based on cell decompositions, poten-
tial ﬁelds, and navigation functions [2]. These methods,
however, suffer from poor scalability with respect to
the dimension of the conﬁguration space. In order to
overcome these limitations, probabilistically complete
approaches based on randomized sampling, such as
probabilistic roadmaps (PRM) [3] and rapidly exploring
random trees (RRT) [4], and their asymptotically optimal
counterparts, PRM* and RRT* [5], were proposed.
A recent trend in robot motion planning is the de-
velopment of computational frameworks that allow for
automatic deployment from rich, high-level, temporal
logic speciﬁcations, e.g., “Visit A and then B or C
inﬁnitely often. Always avoid D. Never go to E unless
F was reached before.” It has been shown that temporal
logics, such as Linear Temporal Logic (LTL), Compu-
tational Tree Logic (CTL), and -calculus, and their
probabilistically versions (PLTL, PCTL), can be used as
formal languages for motion planning [6], [7], [8], [9],
[10]. Adapted model checking algorithms and automata
game techniques [6], [11] were used to generate plans
and control policies for ﬁnite models of robot motion.
Such models were obtained through abstractions, which
This work was partially supported by the ONR under grants MURI
N00014-09-1051 and MURI N00014-10-10952 and by the NSF under
grant NSF CNS-1035588.
The authors are with the Division of Systems Engineering, Boston
University, Boston MA,fcvasile, cbeltag@bu.edu).
are essentially partitions of the robot conﬁguration space
that capture the ability of the robot to steer among
the regions in the partition [12]. As a result, they
suffer from the same scalability issues as the cell-based
decomposition methods.
To generate motion plans and control strategies from
rich task speciﬁcations for robots with large conﬁgura-
tion spaces, a natural approach is to combine sampling-
based motion planning with automata-based synthesis
methods. The existing works in this area show that
synthesis algorithms from speciﬁcations given in -
calculus [9], [13] and LTL [1] can be adapted to scale
incrementally with the graph constructed during the
sampling process. However, these off-line algorithms
assume that the robot moves in a static environment with
a known, global map, and cannot react to events sensed
locally during the deployment.
In this paper, we address the problem of generating
a path for a robot required to satisfy a (global) LTL
speciﬁcation over some known, static service requests,
while at the same time servicing a set of locally
sensed requests ordered according to their priorities.
We propose a random sampling approach that builds
on our work from [1]. Our framework consists of two
components: (1) an off-line algorithm that generates a
ﬁnite transition system that contains a run satisfying
the global speciﬁcation, and (2) an on-line algorithm
that ﬁnds local paths that satisfy both the local and the
global speciﬁcations. The focus in this paper is on the
on-line part of the problem, i.e., we assume that the ﬁnite
transition system is available [1].
The main contribution of this work is a sampling-
based, formal framework that combines inﬁnite-time
satisfaction of temporal logic global speciﬁcations with
reactivity to requests sensed locally. Closely related
works include [14], [15], [16], [17]. In [14], the authors
consider global speciﬁcations given in the more restric-
tive scLTL fragment of LTL. To deal with the state-
space explosion problem, they propose a layered path
planning approach which uses a cell decomposition of
the conﬁguration space for high-level temporal planning
and expansive space trees (EST) for kino-dynamic plan-
ning of the low-level, cell-to-cell motion. The on-line
algorithm from [17] ﬁnds minimum violating paths for a
robot when the global speciﬁcation can not be enforced
completely. In [15], [16], the global speciﬁcations are
given in the GR(1) fragment of LTL, and on-line local
2014 IEEE International Conference on Robotics & Automation (ICRA)
Hong Kong Convention and Exhibition Center
May 31 - June 7, 2014. Hong Kong, China
978-1-4799-3684-7/14/$31.00 ©2014 IEEE 4310
re-planning is done through patching invalidated paths
based on -calculus speciﬁcations. Finally, the idea of
using a potential function to enforce the satisfaction of
an inﬁnite-time speciﬁcation through local decisions is
inspired from [18].
II. PROBLEM FORMULATION
Consider a robot moving in an environment
(workspace)D containing a set of disjoint regions of
interestR
G
. We assume that the robot can precisely
localize itself in the environment. There is a set of
service requests 
G
at the regions in R
G
and their
location is given by a map L
G
: R
G
! 2

G
. We
assume that these regions as well as the labeling map are
static and a priori known to the robot. We will refer to
these as global regions and requests, because these are
used to deﬁne the long-term goal of the robot’s mission.
An example of an environment with global regions and
requests is shown in Fig. 1.
While the robot moves in the environment, it can
locally sense a set of dynamic service requests denoted
by 
L
and a particular type of avoidance request denoted
by 
O
, which captures moving obstacles, unsafe areas,
etc. We assume 
G
\ (
L
[f
O
g) =;. A dynamic
request from 
L
occurs at a point in the environment
and has an associated servicing radius, which speciﬁes
the maximum distance from which the robot can service
it. The servicing radius of a request is determined by its
type (
L
) and all servicing radii are known a priori.
The robot may service a dynamic request by moving
inside the request’s servicing radius and performing
an appropriate action. We assume that once a request
is serviced, it disappears from the environment. The
region around the robot in which the robot can sense
a dynamic request, including 
O
, is called the sensing
area of the corresponding sensor. For simplicity, we
assume that all sensors have the same sensing area. The
sensing area may be of any shape and size provided that
it is connected and full-dimensional (see Fig. 1). We
assume that the avoidance request
O
is associated with
whole regions, parts of which can be detected when they
intersect with the robot’s sensing area. For simplicity, we
refer to regions satisfying
O
as local obstacles. The set
of regions corresponding to local obstacles present in the
environment at time t 0 is denoted byR
L
(t).
The mission speciﬁcation is composed of two parts:
a global mission speciﬁcation, which is deﬁned over the
set of global properties 
G
, and a local mission spec-
iﬁcation, which speciﬁes how on-line detected requests

L
must be handled. The global mission speciﬁcation,
which deﬁnes the long-term motion of the robot, is given
as an LTL
 X
(i.e., LTL without the “next” operator)
x
y
Region A
Region B
Region C
unsafe
ﬁre
survivor
Fig. 1: Simpliﬁed representation of a disaster scenario con-
sidered in Example. 2.2. The environment contains three
global regions A, B and C colored in green, blue and
red, respectively. Three dynamic requests are also shown as
colored points: a survivor (yellow), a fire (orange), and a
local obstacle (black). The circles around them delimit the
corresponding servicing areas. The initial position of the robot
is shown in magenta and the cyan rectangle corresponds to
its sensing area. In this ﬁgure the robot does not detect any
dynamic request or local obstacles.
formula 
G
.
1
. When a robot passes over a global
region, it is assumed that the robot services the requests
associated with the region. Therefore, a path traveled
by the robot generates a word over 
G
. A path is
said to satisfy the global mission speciﬁcation 
G
if
the corresponding word satisﬁes 
G
. The local mission
speciﬁcation is given as a priority functionprio : 
L
!
N. We assume that prio is an injective function that
assigns lower values to higher priority requests.If the
robot detects dynamic requests, it must go and service
the request with the highest priority. If multiple requests
have the same (highest) priority, then the robot can
choose any one of them. Also, the robot must avoid
all local obstacles marked by 
O
.
LetC be the compact conﬁguration space of the robot
and H : C ! D be a submersion that maps each
conﬁguration x to a position y =H(x)2D. Formally,
the problem can be formulated as follows:
Problem 2.1: Given a partially known environment
described by (D;R
G
; 
G
;L
G
; 
L
), an initial conﬁgu-
ration x
0
2C, an LTL
 X
formula 
G
over the set of
properties 
G
, and a priority function prio : 
L
!
N, ﬁnd an (inﬁnite) path in the conﬁguration spaceC
originating at x
0
such that the path y =H(x) in the
environment satisﬁes 
G
and on-line detected dynamic
1
Throughout the paper, we assume that the reader is familiar with
LTL syntax and semantics and concepts from automata-based model
checking, such as Buchi automata and product automata (see [19]).
4311
requests, while avoiding local obstacles.
Example 2.2: Fig. 1 shows a simpliﬁed disaster re-
sponse scenario, in which a point fully actuated robot is
deployed in an environment where three global regions
of interest A, B and C are deﬁned. The set of dynamic
requests is 
L
=ffire;survivorg and the local obsta-
cle is 
O
=unsafe. If the robot detects requests fire
or survivor, it must service them by going within the
corresponding servicing radii and initiating appropriate
actions (i.e., extinguishing the ﬁre and providing med-
ical relief, respectively). If the robot detects the local
obstacle unsafe (shown in black in Fig. 1), the robot
must avoid that region. The limited sensing area of the
robot’s sensors is depicted in Fig. 1 by a cyan rectangle.
The global mission speciﬁcation is: “Go to region A
and then go to regions B or C inﬁnitely often”. This
speciﬁcation can be expressed in LTL
 X
as:
G :=GFA^G(AU (:AU (B_C))) (1)
The local mission speciﬁcation is to “Extinguish
ﬁres and provide medical assistance to survivors, with
priority given to survivors, while avoiding unsafe ar-
eas. ”. Thus the priority function is deﬁned such that
prio(survivor) = 0 and prio(fire) = 1.
The proposed computational framework to solve
Prob. 2.1 consists of two parts: (a) an off-line sampling-
based algorithm to compute a global transition system
T
G
in the conﬁguration spaceC of the robot that contains
a path whose image in the workspaceD satisﬁes the
global mission speciﬁcation 
G
, and (b) an on-line
sampling-based algorithm that computes at every time
step a local control strategy that takes into account
dynamic requests such that both local and global mission
speciﬁcations are met. In our previous work [1], we
developed an algorithm for the construction ofT
G
. In
short, this method builds on RRG [5] and provides a
probabilistically complete algorithm that incrementally
checks for the existence of satisfying paths when new
samples are generated. In this paper, we only focus on
the on-line part of the framework.
III. PROBLEM SOLUTION
The approach taken in this paper is based on the RRT
algorithm, a probabilistically complete sampling-based
path planning method. We modify the standard RRT in
order to ﬁnd local paths which preserve the satisfaction
of the global speciﬁcation 
G
, while servicing on-line
requests and avoiding locally sensed obstacles.
To keep track of validity of samples (random con-
ﬁgurations) with respect to the global speciﬁcation 
G
,
we propose a method that combines the ideas presented
in [20] on monitors for LTL formulae and [18] on
potential functions. The problem considered in [20] is to
decide as soon as possible if a given (inﬁnite) word w
satisﬁes a LTL formula. The main idea is to keep track
of B¨ uchi states corresponding to a ﬁnite preﬁx ofw with
respect to both and: concurrently. If one of the two
sets of B¨ uchi states corresponding to  or: becomes
empty, then we can conclude that the speciﬁcation is
either violated or satisﬁed. If both sets are non-empty
then nothing can be said about wj =. In our case, we
just use half of a monitor, since we are interested only
in checking if steering the robot to new samples violates

G
. The potentials functions approach described in [18]
is used to address the problem of connecting the locally
generated path to states in the global transition system
such that 
G
is satisﬁed.
In the following, we will denote by B the B¨ uchi
automaton encoding the LTL
 X
formula 
G
. We use
P
G
=T
G
B for the product automaton andT
L
to
denote the local transition system which is generated
at each time step. An element ofD will be called a
position. The states of theT
G
andT
L
are conﬁgurations
inC. The weight of a transition ofT
G
orT
L
is given by
the distance between its endpoints inC.
We make the following additional assumptions that
are necessary in the technical treatment below. For a set
RD that is connected and has full dimension inD,
we assume that the inverse setH
 1
(R) also has full
dimension inC. The global regions and local obstacles
are connected sets with non-empty interior, (i.e. they
have full dimension in D). Also, all the connected
regions in the free space, between global regions and
obstacles, respectively, are full dimensional. This implies
that all global regions, local obstacles, service areas for
dynamic requests, and connected free space regions (all
subsets ofD) have corresponding inverse sets (through
H
 1
) of non-zero Lebesgue measure inC. Note that
these are just technical assumptions, which are normally
made in sampling-based approaches, and we do not need
to construct the inverse mapH
 1
. In the sampling-based
algorithms described below, we only need to check how
the environment image of a conﬁguration satisﬁes fea-
tures of interest in the environment. Finally, we assume
that the robot knows its conﬁguration precisely and it
can follow trajectories in the conﬁguration space made
of connected line segments. A path x inC is said to
satisfy the speciﬁcation 
G
if the corresponding path
y =H(x) inD satisﬁes 
G
. The initial conﬁguration
x
0
of the robot is known andH(x
0
) =y
0
.
A. Potential functions
In [18] the authors deﬁne a potential function over
the states of the product automaton between a transition
system and a B¨ uchi automaton. The potential function
captures the distance from each state of the product to
the closest ﬁnal state. It can be thought of as a distance to
satisfaction and resembles a Lyapunov function. We ex-
4312
tend this notion to deﬁne potential functions on the states
of the global transition system. This extension allows us
to reason about the change of potential between nodes
ofT
G
connected through local paths instead of a direct
transition. The local paths are generated as branches
of a tree by the proposed RRT-based algorithm. The
deﬁnitions of self-reachable set and potential function
for product automaton states are adapted from [18].
LetP
G
=T
G
B = (S
P
G
;S
P
G0
; 
P
G
;!
P
G
;F
P
G
)
be a product automaton between a transition system
T
G
and B¨ uchi automaton B. We denote by D(p;p
0
)
the set of all ﬁnite trajectories between states p;p
0
2
S
P
G
,D(p;p
0
) =fp
1
:::p
n
jp
1
= p;p
n
= p
0
;p
k
!
P
G
p
k+1
;8k = 1;:::;n  1;8n 2g. A state p2 S
P
G
is said to reach a state p
0
2 S
P
G
if D(p;p
0
) 6= ;.
The length of a path is deﬁned as the sum of the
weights corresponding to the transitions it is composed
of: L(p) =
P
n 1
k=1
!
P
G
(p
k
;p
k+1
). For p;p
0
2S
P
G
, the
distance between p and p
0
is deﬁned as follows:
d(p;p
0
) =
(
min
p2D(p;p
0
)
(L(p)) ifD(p;p
0
)6=;
1 ifD(p;p
0
) =;
(2)
The weight function !
P
G
is positive, because it is
induced by the distance of the underlying (metric) space.
This implies [18] that d(p;p
0
)> 0 for all p;p
0
2S
P
G
.
A set A S
P
G
is self-reachable if and only if all
states in A can reach a state in A, i.e. for all p2 A
there is a state p
0
such thatD(p;p
0
)6=;.
Deﬁnition 3.1 (Potential function of states inP
G
):
The potential function V
P
G
(p), p2S
P
G
is deﬁned as:
VP
G
(p) =
(
min
p2F

P
G
d(p;p
0
) if p2F

P
G
0 if p2F

P
G
(3)
where F

P
G
F
P
G
is the maximal self-reachable set of
ﬁnal states ofP
G
. The potential function is non-negative
for all states ofP
G
. It is zero forp2S
P
G
if and only if
p is a ﬁnal state andp can reach itself. Also, ifV
P
G
(p) =
1, thenp does not reach any self-reachable ﬁnal states.
Deﬁnition 3.2 (Potential function of states inT
G
):
Let x 2 X and B  
P
G
(x). The potential
function of x with respect to B is deﬁned as:
V
T
G
(x;B) = min
s2B
V
P
G
((x;s)) Also, the minimum
potential of x is deﬁned as V

T
G
(x) =V
T
G
(x;
P
G
(x)).
The minimum potential of a state x of T
G
is the
minimum potential of all states inP
G
which correspond
to x. The actual potential is deﬁned to capture the fact
that not all B¨ uchi states may be available in order to
achieve the minimum potential.
B. Satisfying local paths with respect to 
G
Local paths in our RRT based algorithm connect states
of the global transition system. Let x;x
0
2 T
G
and
x = x
1
:::x
n
be a local path connecting x
1
= x and
x
n
= x
0
and o = o
1
:::o
n
be the output trajectory
corresponding tox with respect to the global proprieties
(o
k
2 2

G
;8k = 1:::n). We need to ensure that there
is a satisfying run inT
G
starting at x
0
after traversing
x. Thus, we need to consider two problems: (1) how to
keep track of available B¨ uchi states as local samples are
generated and (2) how to connect a local path’s endpoint
(tree leaf) to the global transition systemT
G
.
The ﬁrst problem is solved by Alg. 1, which deter-
mines the set of B¨ uchi states given a wordw over 2

G
.
Alg. 1 solves this problem by repeatedly computing the
set of outgoing neighboring states ofB for all states
in the previous iteration. To check if a local path can
be connected to the state x
n
= x
0
2 X, we just need
to verify that it has ﬁnite potential, i.e. V
T
G
(x
0
;B) <
1, where B is the set of available B¨ uchi states after
traversingx, in this casew =o. The second problem has
a simple solution in this setting. We choose the state in
T
G
which has (ﬁnite) minimum potential after traversing
a branch of the RRT tree. Also, the line segment between
the leaf state from the tree and the state inT
G
must be
collision free (see Sec. III-C).
Algorithm 1: Tracking B¨ uchi states of local samples
Input:B B¨ uchi automaton for G, w =1:::n ﬁnite
word over 2

G
, B set of start B¨ uchi states
Output: B
f
set of ﬁnal B¨ uchi states after processing w
1 B
f
 B
2 for k 1:::n do
3 B
0
 ;
4 foreach s2B
f
do
5 B
0
 B
0
[fs
0
2SBj(s;s
0
;
k
)2 Bg
6 B
f
 B
0
7 return B
f
C. On-line planning algorithm
The on-line planning algorithm, outlined in Alg. 2, is
composed of an off-line preprocessing step of computing
the potential function forP
G
and the on-line loop. At
each step of the loop, the robot scans for requests and
local obstacles and checks if it needs to compute a new
local path. Re-planning is performed in four cases: (1) if
the current path is empty; (2) a higher priority request
was detected; (3) the chosen request disappeared; and
(4) the local path collides with a local obstacle. B¨ uchi
states are tracked starting from the initial conﬁguration
of the robot, corresponding to the initial state ofT
G
.
Map B is used to store the tracked B¨ uchi states.
The local path planning algorithm is show in Alg. 3
and is based on RRT. The procedure incrementally
constructs the local transition system T
L
. The initial
(root) state ofT
L
is the current conﬁguration of the robot
x
c
. The mapserv indicates whether a state or any of its
ancestors serviced the on-line request with the highest
4313
Algorithm 2: Planning algorithm
Input:TG global transition system,B B¨ uchi automaton
for G,PG =TGB, prio priority function for
on-line requests, x0 initial conﬁguration
1 Compute potential function VP
G
()
2 path emptyList()
3 xc x0; B(xc) P
G
(xc)
4 while True do
5 I getLocalRequests()
6 if checkPath(I;path)_:path:hasNext() then
7 path planLocally(xc;PG;B;prior;I)
8 xn path:next()
9 enforce(xc!xn)
10 xc xn
priority. If there are no requests thenserv is true for all
states ofT
L
.
The construction of the RRT proceeds by generating
a new random sample (line 4) inside the sensing area
of the robot, steer the system towards it (lines 5–6) and
checking if it is a valid state (lines 8–9). Samples are
generated such that their images in D belong to the
sensing area of the robot. The nearest function (line
5) is a standard RRT primitive which returns the nearest
state inT
L
based on the distance function associated
with C. We assume that we have access to a steer
function (see Sec. II) which drives the system to a
conﬁguration x2C. x is the closest conﬁguration to
the new sample x
s
which is at most  distance away
from x
n
, [4], [5]. The label primitive function (line 7)
is used to anotatex with the global properties it satisﬁes.
x is valid if its corresponding set of B¨ uchi states is non-
empty and the line segment from its parent x
n
to itself
is a simple collision free line segment. Alg. 1 is used
to compute the set of available B¨ uchi states for x. The
primitive function isSimpleSegment is used to ensure
that the set of global properties along the potential
new transition (x
n
;x) changes at most once. For more
details, about this primitive see [1]. The collisionFree
primitive is used to check if the image in the workspace
of the line segment (x
n
;x)2C collides with a local
obstacle inD. If these tests are passed, the procedure
adds the state x and the transition (x
n
;x) toT
L
(line
11). Also theserv map is updated by checking if either
the parent state x
n
(or some ancestor) or the state itself
x has serviced the selected on-line request.
Also, we require that the statex
G
ofT
G
have a lower
(actual) potential than the last visited state x
0
G
ofT
G
.
This condition is not enforced, if the potential of x
0
G
is
zero, but we still require x
G
6=x
0
G
.
Theorem 3.3: Letx =x
1
;::: be an inﬁnite path inC
generated by Alg. 2 ando =o
1
;::: be the corresponding
(inﬁnite) output word generated by traversingx. If every
Algorithm 3: Local path planning
Input: xc current conﬁguration of the robot,
PG =TGB,B B¨ uchi automaton for G,
prior – on-line requests priority function, I
sensed requests and local obstacles
Output: path computed local control strategy
1 ConstructTL = (XL;xc; L;!L; L[fOg;hL) with
xc as initial state
2 serv(xc) :I:hasRequest()
3 while @ xc!

T
L
xT!xG w/ VT
G
(xG;B(xG))<1_
:serv(xT ) do
4 xs generateSample(xc;I:area)
5 xn nearest(TL;xs)
6 x steer(xn;xs;)
7 x label(x;I)
8 B(x) trackBuchiStates(B;hL(xn);B(xn))
9 if B(x)6=;^ isSimpleSegmnent(xn;x)^
collisionFree(xn;x) then
10 serv(x) serv(xn)_I:serviced(x;prior)
11 XL XL[fxg; L L[f(xn;x)g
12 return xc!

T
L
xT!xG
call of Alg. 3 ﬁnishes in ﬁnite time, then o satisﬁes the
global speciﬁcation 
G
, oj = 
G
.
Remark 3.4: The complexity of the local path plan-
ning algorithm (Alg. 3) is the same as for the
standard RRT. The functions generateSample, steer
and nearest are stardard primitives [4], [5]. label,
isSimpleSegment and collisionFree primitives and
checking if an on-line request was serviced, can be
reduced to collision detection in the lower dimensional
workspace. Tracking B¨ uchi states takes constant time
(O(1)), because the global speciﬁcation 
G
is ﬁxed.
IV. CASE STUDY
The algorithms presented in this paper were imple-
mented in Python2.7. The case study presented below
was run on an Ubuntu 13.04 with 2GHz Intel Core2
Duo processor and 2GB of memory. For simplicity, we
present a case study in which the robot is a fully actuated
point in plane. Note that, since both the off-line and
on-line algorithms are based on random sampling, the
method can be used for systems with large conﬁguration
spaces. In fact, in [1], where we presented the off-line
part of the method, we included a case study in a 20-
dimensional conﬁguration space.
Here we consider the conﬁguration space depicted in
Fig. 2(a). The initial conﬁguration is x
0
= ( 9; 9).
The global speciﬁcation is to visit regions r1, r2, r3
andr4 inﬁnitely many times while avoiding regionso1,
o2, o3, o4 and o5. The corresponding LTL
 X
formula
is 
G
= G(Fr1^Fr2^Fr3^Fr4^:(o1_o2_
o3_o4_o5)). There are four local obstacles labeled
uo and three dynamic requests: two survivor requests
4314
and a fire request. The three dynamic requests have a
cyclic motion at a lower speed than that of the robot. The
maximum distance traveled by the robot in one discrete
time step is  = 1 (see the steer primitive in Alg. 3,
line 6). The priority function prior is deﬁned such that
survivor request have higher priority thanfire request.
A solution to this problem is shown in Fig. 2. The
product automaton has a single accepting state, which
corresponds tox
accept
= ( 7; 0) inT
G
. The robot must
visit x
accept
inﬁnitely many times. In each surveillance
cycle, the three dynamic requests described above are
created. We ran the path planning algorithm in order to
complete 100 surveillance cycles. During the simulation,
the local path planning algorithm (Alg. 3) was executed
5947 times. The overall execution time dedicated to local
planning (lines 7–8 of Alg. 2) for a single surveillance
cycle was on average 0.743 seconds (std. 0.216). The
mean size of the generated local transition systemT
L
was 7.6 (std. 13.15). The path planning algorithm com-
puted local paths which serviced 292 on-line requests
from a total of 296 detected.
REFERENCES
[1] C. Vasile and C. Belta, “Sampling-Based Temporal Logic Path
Planning,” in IEEE/RSJ International Conference on Intelligent
Robots and Systems, 2013.
[2] H. Choset, K. Lynch, S. Hutchinson, G. Kantor, W. Burgard,
L. Kavraki, and S. Thrun, Principles of Robot Motion: Theory,
Algorithms, and Implementations. Boston: MIT Press, 2005.
[3] L. Kavraki, P. Svestka, J. Latombe, and M. Overmars, “Proba-
bilistic roadmaps for path planning in high-dimensional conﬁgu-
ration spaces,” IEEE Transactions on Robotics and Automation,
vol. 12, no. 4, pp. 566–580, 1996.
[4] S. M. LaValle and J. J. Kuffner, “Randomized kinodynamic
planning,” in IEEE International Conference on Robotics and
Automation, 1999, pp. 473–479.
[5] S. Karaman and E. Frazzoli, “Sampling-based Algorithms for
Optimal Motion Planning,” International Journal of Robotics
Research, vol. 30, no. 7, pp. 846–894, June 2011.
[6] H. Kress-Gazit, G. E. Fainekos, and G. J. Pappas, “Where’s
Waldo? Sensor-based temporal logic motion planning,” in IEEE
International Conference on Robotics and Automation, 2007.
[7] T. Wongpiromsarn, U. Topcu, and R. M. Murray, “Receding
Horizon Temporal Logic Planning for Dynamical Systems,” in
Conference on Decision and Control, 2009, pp. 5997 –6004.
[8] A. Bhatia, L. Kavraki, and M. Vardi, “Sampling-based motion
planning with temporal goals,” in IEEE International Conference
on Robotics and Automation. IEEE, 2010, pp. 2689–2696.
[9] S. Karaman and E. Frazzoli, “Sampling-based Motion Planning
with Deterministic -Calculus Speciﬁcations,” in IEEE Confer-
ence on Decision and Control, Shanghai, China, 2009.
[10] X. C. Ding, M. Kloetzer, Y . Chen, and C. Belta, “Formal
Methods for Automatic Deployment of Robotic Teams,” IEEE
Robotics and Automation Magazine, vol. 18, pp. 75–86, 2011.
[11] Y . Chen, J. Tumova, and C. Belta, “LTL Robot Motion Control
based on Automata Learning of Environmental Dynamics,” in
IEEE International Conference on Robotics and Automation,
Saint Paul, MN, USA, 2012.
[12] C. Belta, V . Isler, and G. J. Pappas, “Discrete abstractions for
robot planning and control in polygonal environments,” IEEE
Trans. on Robotics, vol. 21, no. 5, pp. 864–874, 2005.
[13] S. Karaman and E. Frazzoli, “Sampling-based Optimal Motion
Planning with Deterministic-Calculus Speciﬁcations,” in Amer-
ican Control Conference, 2012.
(a) At the start of the mission (b) After a few steps
(c) Sensing area with local
RRT tree
(d) After completing one
surveillance cycle
Fig. 2: The environment contains four global regions of
interest r1 (red), r2 (green), r3 (blue) and r4 (magenta),
ﬁve global obstacles o1;:::;o5 (dark grey) and four local a
priori unknown obstacles labeled uo (light grey). There are
also three dynamic requests, twosurvivor (green) and afire
(yellow). The circles around the on-line requests delimit their
corresponding service area. The sensing range of the robot is
shown as a light blue rectangle (length of its side is 5) around
the current position of the robot (blue dot), Fig. 2(b). The black
arrows and dots represent the global transition systemTG. The
trajectory of the robot is shown as a sequence of red arrows.
Fig. 2(d) shows the trajectory of the robot after completing a
surveillance cycle. Fig. 2(c) is a close up view of the sensing
area of the robot at position (4:9; 7:3) where an RRT tree is
generated. The red arrows mark the trajectory of the robot, and
the black ones belong toTG.
[14] M. Maly, M. Lahijanian, L. E. Kavraki, H. Kress-Gazit, and
M. Y . Vardi, “Iterative Temporal Motion Planning for Hybrid
Systems in Partially Unknown Environments,” in ACM Interna-
tional Conference on Hybrid Systems: Computation and Control,
ACM. Philadelphia, PA, USA: ACM, March 2013, pp. 353–362.
[15] S. C. Livingston and R. M. Murray, “Just-in-time synthesis for
motion planning with temporal logic,” in International Confer-
ence on Robotics and Automation, 2013.
[16] S. C. Livingston, P. Prabhakar, A. B. Jose, and R. M. Murray,
“Patching task-level robot controllers based on a local-calculus
formula,” in International Conference on Robotics and Automa-
tion, 2013.
[17] J. Tumova, L. Reyes-Castro, S. Karaman, E. Frazzoli, and
D. Rus, “Minimum-violating planning with conﬂicting speciﬁ-
cations,” in American Control Conference, 2013.
[18] X. C. Ding, M. Lazar, and C. Belta, “Receding Horizon Temporal
Logic Control for Finite Deterministic Systems,” in American
Control Conference, Montreal, Canada, 2012.
[19] C. Baier and J.-P. Katoen, Principles of model checking. MIT
Press, 2008.
[20] A. Bauer, M. Leucker, and C. Schallhart, “Runtime Veriﬁcation
for LTL and TLTL,” Institut f¨ ur Informatik, Technische Univer-
sit¨ at M¨ unchen, Tech. Rep. TUM-I0724, December 2007.
4315
