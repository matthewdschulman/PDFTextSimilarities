Predictive Path-Accurate Scaling of a Sensor-Based Deﬁned Trajectory
Friedrich Lange and Michael Suppa
Abstract— The paper considers an a priori given robot
trajectory which has to be recomputed when online sensed
information on the environment is available. Then the original
trajectory is adapted in order to continue the so far commanded
motion by the sensed geometric shape. The adapted trajectory
has to comply with restrictions on velocity, acceleration and
jerk. Furthermore it is desired to converge to the original
trajectory. At least if the robot is in contact with the envi-
ronment it is further essential that the geometrical path is not
left when modifying the trajectory. This means that preferably
only the temporal proﬁle is changed by scaling or rescaling the
velocity. In order to inhibit overshooting, future restrictions are
predicted and backtracked in the case of a violation. All this
computation is done within a single sampling step, i.e. within
4 ms for a standard KUKA industrial robot. This precludes
accurate optimization algorithms. When applied without an a
priori given trajectory the method results in an near time-
optimal solution.
I. INTRODUCTION
Trajectory generation of ﬁxed robot paths can be done
ofﬂine, considering sophisticated optimization criteria. In
contrast, trajectories from paths which are computed or
adapted online from sensor data have to be computed in a
time efﬁcient manner. Thus optimization methods as e.g. [1],
[2], [3] are too slow. Instead, the computation time should be
below 1 ms, even if this results in a sub-optimal trajectory.
This is important for fast motion with high accuracy
requirements, e.g. when approaching an object, where the
sensed desired path abruptly changes when a contact force is
measured. Then, in order to avoid excessive forces as well as
a loss of contact after the ﬁrst overshooting, the robot should
decelerate as fast as possible and then perform the desired
contact motion, e.g. polishing with the desired pressure.
Another critical task for trajectory generation is stopping
during constrained motion, without exerting undesired forces,
i.e. without leaving the previously deﬁned path.
Sudden changes of the desired trajectory can also be
present before sensing a contact, e.g. in pick-and-place
operations or during assembly, when the exact gripping pose
is not known until it is sensed (e.g. by an eye-in-hand
camera of limited ﬁeld of view). Then, a signiﬁcant change
of orientation may be needed in a very short time. And this
path correction should be executed without colliding with the
object to be gripped.
A general formulation of the problem is, ﬁrst, the deﬁni-
tion of desired trajectories q
d
(k+) from each sampling step
k, representing the sampled positions of the next 100 ms or
so, incorporating the current information on the environment.
The authors are with the German Aerospace Center (DLR),
Robotics and Mechatronics Center (RMC), 82234 Wessling, Germany
friedrich.lange@dlr.de
For this paper, the desired trajectories are assumed to be
given. Second, there are restrictions, usually given by the
robot manufacturer, limiting the velocity, the acceleration
and the jerk of the individual axes. In addition, there may
be restrictions on Cartesian level. If the desired trajectory
does not comply with the restrictions, the task of trajectory
generation is to modify the trajectory such that:
 The restrictions are met.
 The desired trajectory is reached as soon as possible.
 The modiﬁed path, i.e. the geometrical shape of the
trajectory, complies with the desired path.
The latter requirement is called path-accuracy
1
. The re-
sulting executable trajectory is called limited desired trajec-
tory, with the ﬁrst value denoted as the commanded position
q
c
(k) which provides the desired values for the servo loops.
Typical interpolation methods as e.g. [4], [5] generate
a trajectory from the current position to a goal position,
assuming that the robot stands still at both places. Other
algorithms generate a trajectory through several points in the
axis space, as e.g. [3], [6], [7], [8]. All this is not applicable,
when the robot is in motion and the desired path suddenly
changes because of unexpected sensor signals.
The Reﬂexxes Motion Library [9] provides a useful trajec-
tory generator to limit the velocity, the acceleration, and the
jerk, considering the full current state. However, the goal is
to reach the target pose with given velocity and acceleration
in minimum time. So there are two drawbacks for the task
on hand: First, when using the algorithm, q
d
(k), q
d
(k + 1),
q
d
(k + 2) and the appropriate derivatives have to be
tested as goal, until the algorithm conﬁrms that a solution is
possible within the given number of sampling steps. In this
way, the experiments are done in Section IV. The second
drawback is even worse. Since the only criterium is time-
optimality, there is no desired trajectory processed. Therefore
the limited desired trajectory may be quite far from the
desired trajectory, not considering a possible collision.
Scanning other methods it turns out that time optimality
is predominantly used as cost function. Also with methods
that explicitly consider the tracking of a desired path (as e.g.
[10], [11], [12], [13], [14], [15]), minimum execution time is
aimed instead of synchronization with a given trajectory. The
latter however, is desired with given robot programs. This is
the motivation for the method of this paper.
1
In this paper the termpath-accurate is understood that the currentlimited
desired position is on the straight line between the previous commanded
position and the current desired position. So, if the desired path is not
continuous or a commanded position is not on the desired path, path-
accuracy does not guarantee that subsequent sampling steps will ﬁt the
path.
2014 IEEE International Conference on Robotics & Automation (ICRA)
Hong Kong Convention and Exhibition Center
May 31 - June 7, 2014. Hong Kong, China
978-1-4799-3684-7/14/$31.00 ©2014 IEEE 754
If a velocity proﬁle for a given path is computed, the path
is represented with the arc length s as parameter. Then the
task is to compute the velocity _ s(s) in the phase space, that
complies with the restrictions. Early papers as [10], [11], [12]
did not consider constraints on the jerk. In contrast, [13] uses
forward and backward computation and smoothing at the
meeting point to account for these limits as well. [14] only
computes from the beginning of the trajectory, but switches
before entering a trapped area, since otherwise the path will
be lost later.
While in most papers (as [4], [9], [12], [13], [14], [16]) the
motion is divided into a limited number of phases with given
characteristics, as a constant jerk or a constant acceleration,
the consideration of the path-accuracy affords the generation
of a continuous trajectory. Therefore the number of phases
can be up to the number of sampling steps until the desired
trajectory is reached. As mentioned before, the optimization
of so many degrees of freedom (dof) is not possible within
the given computing time.
It should be noted that in contrast to the ofﬂine generation
of a whole trajectory it is not always possible to generate
a path-accurate trajectory from a given state, that meets
all restrictions. For example, in the above mentioned task
of approaching an object it may be impossible to inhibit
overshooting. In contrast to acceleration phases, the path-
accuracy is always at risk if the desired deceleration
2
exceeds
the limits, even more if some axes are decelerated while
others are accelerated. This is discussed in more detail in
[9], [14].
This problem might be relieved if not only the current
time step is considered but also future restrictions, similar
to a whole trajectory. [15] locally restricts the given velocity
limits in order to comply with the limits on the acceleration
and the jerk. Instead, in this paper it is proposed to predict
future restrictions and then to modify the trajectory at
previous time steps. This is outlined in Section III.
The paper is organized as follows: The next section tries
to modify a desired position in order to comply with the
robot restrictions, given the so far commanded trajectory.
Since this may result in overshooting, Section III considers
several future sampling steps. Both approaches are shown in
experiments in Section IV.
II. PATH-ACCURATE SCALING OF THE CURRENT
TIME-STEP
In this section the desired axis positions q
d
(k) are mod-
iﬁed to commands q
c
(k), in order to comply with the
restrictions. This is explained in three steps, considering the
limitations on velocity, acceleration, and jerk.
For convenience, in the following equations we omit the
sampling time T
0
= 1, which means that the time is ex-
pressed in steps instead of seconds. Furthermore, we denote
q
c
(k) as the output of each step, which then becomes the
input of the next step, i.e. q
d
(k). The same applies if there is
2
Acceleration against the current direction of motion is similar to decel-
eration.
t
q
desired trajectory
limited desired 
trajectory
+ + +
+
+ + + +
Fig. 1. Modiﬁcation of a 1 dof path by scaling the velocity at the
discontinuity of the desired path in order to comply with a velocity limit.
an iteration within a step. Past values q
c
(k ) = q
d
(k )
are identical anyway.
A. Scaling of the Velocity
For each axis the restriction
jv
c
(k)j =jq
c
(k)  q
c
(k  1)j  v (1)
applies. If the desired position violates the restriction in at
least one axis i, i.e.jv
di
(k)j =jq
di
(k) q
di
(k  1)j >  v
i
,
the velocity has to be scaled. Scaling of the velocity between
time step (k  1) and k always results in a path-accurate
trajectory since not the path is modiﬁed but the time proﬁle
of its execution.
The modiﬁcation is executed in two steps. First, the scaling
factor  is computed as
 = max
i
(jv
di
(k)j= v
i
): (2)
This computation is always possible and results in> 1.
Then the velocity of all axes is scaled
q
c
(k) = q
d
(k  1) + v
d
(k)=: (3)
For one degree of freedom (dof) this is displayed in Fig. 1.
In addition, if  exceeds a value  
v
, e.g. 2, the motion is
stopped by q
c
(k) = q
d
(k  1), since then probably a sensor
failure or another fault has occurred.
B. Path-Accurate Scaling of the Acceleration
For each axis the restriction
ja
c
(k)j =jq
c
(k)  2q
c
(k  1) + q
c
(k  2)j  a (4)
applies. If the desired position violates the restriction in at
least one axisi, i.e.ja
di
(k)j =jq
di
(k) 2q
di
(k 1)+q
di
(k 
2)j>  a
i
, the velocity is scaled (see Fig. 2). (3) gives
jq
d
(k  1) + v
d
(k)=  2q
d
(k  1) + q
d
(k  2)j  a (5)
and hence the scaling factor
1

= min
i
(
 a
i
+v
di
(k  1)
v
di
(k)
): (6)
t
q
desired trajectory
limited desired 
trajectory
+ + +
+
+
+
+
+
Fig. 2. Modiﬁcation of a 1 dof path by scaling the velocity at the vertex
of the desired path in order to comply with an acceleration limit.
755
q
q
desired trajectory
limited desired 
trajectory
1
2
+ + +
+
+
+
+
+
+
+
+
Fig. 3. Modiﬁcation of a 2 dof path by scaling the acceleration at the
vertex of the desired path in order to comply with acceleration limits (not
path-accurate).
The sign of  a
i
is positive if a
di
(k)>  a
i
, it is negative if
a
di
(k) <  a
i
. Otherwise axis i does not contribute to the
computation of  since the component i of (4) is met.
If the result is > 1, (3) meets (4) in all axes. Then the
modiﬁcation is path-accurate. But the condition on  is not
always met.
Unfortunately, a scaling in axis i
1
may cause a limitation
in another axisi
2
, since the value of q
c
(k) which is modiﬁed
according to (3) has to be used in (4). Simply speaking,
if the velocity has to be reduced because of a big desired
acceleration in axisi
1
, the reduction of the velocity of axisi
2
may exceed the maximum deceleration. Therefore all scaling
is repeated iteratively, until a solution is found that meets
all restrictions. The number of steps of this iteration is not
greater than the number of axes. If such a solution cannot
be found, the modiﬁcation of the desired trajectory will not
be path-accurate.
As well for the acceleration a fault detection is imple-
mented which stops the motion if  >  
a
, where  
a
for
the scaling of the acceleration can be bigger than  
v
, e.g.
 
a
= 30, depending on the sampling time.
C. Other Scaling of the Acceleration
If no path-accurate scaling is possible, the acceleration is
scaled directly, since the robot controller inhibits the motion
if the restrictions are not met.
The scaling factor is computed by
 = max
i
(ja
di
(k)j= a
i
): (7)
Then the scaling is done by
q
c
(k) = q
d
(k  1) + v
d
(k  1) + a
d
(k)=: (8)
This modiﬁcation of the desired trajectory is always possi-
ble, since> 1 if the acceleration limits are violated without
scaling. Fig. 3 shows the geometrical interpretation. The
scaling is done between the position which would be reached
without acceleration and the desired position which is not
reachable with the given restrictions on the acceleration.
D. Path-Accurate Scaling of the Jerk
The restriction of the jerk is
jj
c
(k)j =jq
c
(k) 3q
c
(k 1)+3q
c
(k 2) q
c
(k 3)j

j:
(9)
Scaling is required if the limit is exceeded by at
least a single axis. As with the acceleration it is
ﬁrst tried to modify the desired trajectory in a path-
accurate way, i.e. by scaling the velocity. (3) gives
jq
d
(k  1) + v
d
(k)=
 3q
d
(k  1) + 3q
d
(k  2)  q
d
(k  3)j

j:
(10)
Thus the scaling factor
1

= min
i
(


j
i
+v
di
(k  1) +a
di
(k  1)
v
di
(k)
) (11)
can be computed and inserted in (3). As with the acceleration
this has to be repeated until a solution is found that meets
all restrictions. Still it is possible that no solution exists.
E. Other Scaling of the Jerk
If the scaling of the velocity is not possible, as well here
it is required to modify the desired trajectory in order to
comply with the restrictions. This can be done by scaling
the accelerations or directly the jerk. Since the scaling of the
accelerations between the current and the previous time step
is not always successful in order to meet the jerk limitations,
it is not explained here. Instead, the jerk is scaled by
 = max
i
(jj
di
(k)j=

j
i
): (12)
This results in> 1 if the jerk limits are violated without
scaling. Thus this scaling always gives a valid modiﬁcation
of the desired trajectory
q
c
(k) = q
d
(k 1)+v
d
(k 1)+a
d
(k 1)+j
d
(k)=: (13)
F. Limitations of Scaling
In this way a valid scaling is possible for the restrictions in
each level, but this does not always result in a path-accurate
modiﬁcation of the desired trajectory.
Even worse, there are desired trajectories for which no
valid modiﬁcation is possible at all. This may happen if
the robot has accelerated until the maximum velocity is
reached. But then the robot continues to accelerate because
the restrictions on the jerk do not allow zero acceleration in
the next step. This is called a forbidden point in [13].
Besides the kinematic restrictions, as in this paper, it is
possible to provide for dynamic restrictions as a limited
motor torque. In this case  a is a time variant function of
the allowed motor torques, considering couplings from other
axes as e.g. velocity dependent terms. (see e.g. [11], [14] for
other methods accounting for torques)
III. PREDICTIVE SCALING BY BACKTRACKING
In the same way as q
d
(k) is modiﬁed, future time steps
q
d
(k +) can be modiﬁed. If the desired trajectory is not
only given for the current time step k, the knowledge of its
future limitations gives the chance to avoid deviations from
the desired path, i.e. modiﬁcations of the desired trajectory
which cannot be done path-accurately. For example, a strong
deceleration at time step k + will produce overshooting if
this is not inhibited by starting the deceleration before. Then
the speed reduction can be executed path-accurately.
Another application for predictive scaling is the execution
of a desired step, e.g. during sensor controlled motion when
756
the desired position differs from the actual one because of a
changed model of the environment. If the desired trajectory
(the step) is scaled according to Section II, the speed of
the limited desired trajectory will increase until the step is
executed. But then it is too late for deceleration. This is
shown in Section IV (see Fig. 5).
But the algorithm which is explained in the sequel is not
restricted to these examples. It is applicable as well, e.g. to a
desired trajectory which offers a high curvature in time step
k + 20.
The procedure is as follows.
1) Beginning from the current time step k the desired
positions are checked for limitations and modiﬁed
according to Sections II-A, II-B, and II-D.
2) If a path-accurate modiﬁcation of the desired trajectory
is not possible, the previous time steps are scaled
according to Section III-A or III-B. This is called
backtracking.
3) Then the iteration continues with step k  1 or k  2,
respectively, checking the time steps which are just
modiﬁed.
The procedure ends when
 no more predictions on q
d
(k +) are available (then
no unsolved contradictions to a path-accurate execution
have been found),
 a maximum number of iteration steps is reached, or
 the procedure tries to modify past values, as q
c
(k  1).
A. Restriction on the Acceleration
By a path-accurate modiﬁcation of q
d
(k +) and q
d
(k +
  1) it is always possible to meet the limits of the acceler-
ation a
c
(k+) = q
c
(k+) 2q
c
(k+ 1)+q
c
(k+ 2).
For brevity, in the sequel we denotek + ask
0
. Then the
modiﬁcation is done by two scalings of the velocity
q
c
(k
0
) = q
d
(k
0
  1) + v
d
(k
0
)=
k
0 (14)
q
c
(k
0
  1) = q
d
(k
0
  2) + v
d
(k
0
  1)=
k
0
 1
: (15)
In order to limit the computing time, we concatenate these
scalings by selecting
k
0 = and
1

k
0
 1
= (1 +
1

)=2. Then
q
c
(k
0
) = q
d
(k
0
  1) + v
d
(k
0
)= (16)
q
c
(k
0
 1) = q
d
(k
0
 2) + v
d
(k
0
 1) (1 + 1=)=2 (17)
which results in  from (7), with k
0
instead of k.
For !1 this converges to
q
c
(k
0
) = q
d
(k
0
  1) (18)
q
c
(k
0
  1) = (q
d
(k
0
  2) + q
d
(k
0
  1))=2 (19)
and thus results in an acceleration q
c
(k
0
)  2q
c
(k
0
  1) +
q
c
(k
0
  2) of zero.
For the critical axis from which has been computed, we
get
q
ci
(k
0
) =q
di
(k
0
  1) +v
di
(k
0
)  a
i
=ja
di
(k
0
)j (20)
q
ci
(k
0
 1) =q
di
(k
0
 2) +
v
di
(k
0
 1)
2

1 +
 a
i
ja
di
(k
0
)j

(21)
and thus
q
ci
(k
0
)  2q
ci
(k
0
  1) +q
ci
(k
0
  2) = a
i
: (22)
B. Restriction on the Jerk
Similarly the path-accurate modiﬁcation of q
d
(k + ),
q
d
(k +  1), and q
d
(k +  2) is always possible to
meet the jerk limits j
c
(k +) = q
c
(k +)  3q
c
(k + 
1) + 3q
c
(k +  2)  q
c
(k +  3). Here, as well, k +
is denoted as k
0
.
Analogously to (16) and (17) the modiﬁcation is done by
q
c
(k
0
) = q
d
(k
0
  1) + v
d
(k
0
)= (23)
q
c
(k
0
  1) = q
d
(k
0
  2) + v
d
(k
0
  1) (1 + 2=)=3 (24)
q
c
(k
0
  2) = q
d
(k
0
  3) + v
d
(k
0
  2) (2 + 1=)=3 (25)
which results in  from (12), with k
0
instead of k.
For !1 this converges to
q
c
(k
0
) = q
d
(k
0
  1) (26)
q
c
(k
0
  1) = (2q
d
(k
0
  2) + q
d
(k
0
  1))=3 (27)
q
c
(k
0
  2) = (q
d
(k
0
  3) + 2q
d
(k
0
  2))=3 (28)
which corresponds to a jerk q
c
(k
0
) 3q
c
(k
0
 1)+3q
c
(k
0
 
2)  q
c
(k
0
  3) of zero.
For the critical axis from which has been computed, we
get
q
ci
(k
0
) =q
di
(k
0
  1) +v
di
(k
0
)

j
i
=jj
di
(k
0
)j (29)
q
ci
(k
0
 1) =q
di
(k
0
 2)+
v
di
(k
0
 1)
3

1 + 2

j
i
jj
di
(k
0
)j

(30)
q
ci
(k
0
 2) =q
ci
(k
0
 3)+
(v
di
(k
0
 2)
3

2 +

j
i
jj
di
(k
0
)j

(31)
and thus
q
ci
(k
0
) 3q
ci
(k
0
 1)+3q
ci
(k
0
 2) q
ci
(k
0
 3) =

j
i
: (32)
C. Limitations of Backtracking
In this way backtracking will ﬁnd a path-accurate solution
in most cases. If the iteration is aborted, e.g. because already
time stepk + with = 0 cannot be scaled path-accurately,
the restrictions can be met by a scaling according to Section
II-C or II-E. Thus, besides the exception
3
mentioned in
Section II-F, the modiﬁed trajectory will comply with the
restrictions.
By scaling and by backtracking the trajectory is always
slowed down, because the positions are shifted towards
positions at previous time steps. Thus the restrictions are
probably met. But it will not be path-accurate if the back-
tracking exceeds the current time stepk. Therefore with this
conservative procedure it is not ensured that a possible path-
accurate solution is found. On the other side it has been stated
in the Introduction that a full optimization is not feasible.
The required number of future time steps that can be used
for backtracking depends on the velocity and on how close
the desired trajectory is from the limits. In the experiments
we use 0<   = 20 which is usually sufﬁcient.
3
If sufﬁcient backtracking is possible, the exception will be solved as
well.
757
Fig. 4. KUKA robot with force sensor and pin which is in contact.
IV. EXPERIMENTS
In this section we ﬁrst consider the case of a vertical
motion of the tcp (see setup in Fig. 4), until a reaction force
is measured. This happens in time step 2801 in Figs. 5 to 7,
much earlier than expected. Then the future desired trajectory
is recomputed as that position, at which the desired force will
be executed. This approach is explained in detail in [17]. It
results in a step since the actual position at which the force is
sensed is delayed with respect to the so far desired trajectory.
The desired trajectory is recalculated as well in further time
steps. Then the desired position slightly changes because the
assumptions on the robot compliance are disturbed. In theory
there is no feedback from the robot motion to the desired
motion. Therefore the latter is assumed to be given in this
paper irrespective of the type of sensor.
Figures 5 to 7 show the experimental results in Cartesian
space, using a KUKA KR16 robot which is controlled at
250 Hz via RSI Ethernet from an external computer. In Fig. 6
the path error is displayed, i.e. the motion perpendicular to
the desired path. Fig. 7 displays the computed accelerations
and jerks. Their used limits in the joint space are displayed
in Table I, meaning, e.g., velocity limits  v
i
=T
0
in rad/4ms.
When the desired position is changed (because of a sensed
contact), in the ﬁrst step all methods are identical. An
overshooting cannot be avoided. Thus this step is not path-
accurate.
Then the method of Section II executes maximum accel-
eration until the desired value is reached. Then, as far as
the jerk limit allows, the deceleration is maximal. Like this,
a poorly damped oscillation around the desired position is
executed. The robot motion may even become unstable if
TABLE I
LIMITS OF THE INDIVIDUAL AXES (BEFORE FILTERING).
i  v
i
 a
i

j
i
1 0.014 rad 0.074 mrad 0.061 mrad
2 0.014 rad 0.037 mrad 0.030 mrad
3 0.014 rad 0.085 mrad 0.069 mrad
4 0.029 rad 0.250 mrad 0.204 mrad
5 0.030 rad 0.252 mrad 0.206 mrad
6 0.055 rad 0.450 mrad 0.368 mrad
685.5
686
686.5
687
687.5
688
2785 2795 2805 2815 2825 2835
z-position (mm) 
time (steps) 
desired
scaling
backtracking
Reflexxes
Fig. 5. Desired and limited desired trajectories inz using different methods.
999.8
1000
1000.2
1000.4
2785 2795 2805 2815 2825 2835
x-position (mm) 
time (steps) 
desired scaling backtracking Reflexxes
Fig. 6. Deviations in x from the desired path using different methods.
-0.1
0
0.1
scaling 
acceleration (mm) jerk (mm)
-0.1
0
0.1
backtracking 
-0.1
0
0.1
2785 2795 2805 2815 2825 2835
Reflexxes 
time (steps) 
Fig. 7. Limited acceleration and jerk.
the limits of the jerk are very restrictive.
In contrast, with backtracking there is no overshooting
since the acceleration is reduced in time. Apart from sam-
pling step 2801, the trajectory is path-accurate. The plots of
the acceleration and the jerk show however, that the trajectory
is sub-optimal since they do not feature the typical shape
as with the scaling. Tracing the experiment discloses that in
step 2802 backtracking is executed for time steps 2807 (jerk),
2808 (acc.), 2807 (jerk), 2805 (jerk), 2809( acc.), 2808 (acc.),
2807 (jerk), 2805 (jerk), 2808 (jerk), 2810 (acc.). Similarly,
backtracking is performed in each of the next sampling steps.
The result of the Reﬂexxes Motion Library [18] is similar
to this, at least according to Fig. 5. It is obtained by
computing trajectories from q
c
(k  1), v
c
(k  1), and
a
c
(k  1) to q
d
(k +) and v
d
(k +). This is done by
758
684.5
685
685.5
686
686.5
564 564.5 565 565.5 566 566.5 567
z-position (mm) 
y-position (mm) 
desired
scaling
backtracking
Reflexxes
Fig. 8. Desired and limited desired trajectories in the y-z-plane using a
force sensor with different methods.
tentatively calling the functionRMLPosition for = 0;;  
until the target is reached within at most  time steps.
4
The
intermediate time steps k;;k +  1 are not considered
in each case. Therefore the motion is not path-accurate, i.e.
there are small deviations in x-direction. In this example,
the deviations are not essential since there is no contact
in this direction. However, deviations in the sub-millimeter
range may be signiﬁcant if the robot is in stiff contact of
e.g. 1000 N/mm and thus generates undesired forces.
In a second experiment the task is overlaid by a constant
horizontal velocity in y direction. The resulting path is
displayed in Fig. 8.
As a third experiment the previous one is repeated 5 times
faster, where instead of the force-torque sensor a distance
sensor is simulated. This sensor can predict the contact point
and thus the changed desired trajectory. So the predictive
approach decelerates early enough, such that there is no
overshooting (Fig. 9). This cannot be exploited by the other
two methods.
The video attachment gives an impression of the three
experiments. However, the different methods cannot be dis-
tinguished there.
V. CONCLUSION
The paper presents a trajectory generator that in each
sampling step continues the so far commanded robot motion
towards the currently sensed path, complying with restric-
tions on the velocity, the acceleration, and the jerk, and
synchronizing with the ofﬂine computed desired trajectory.
The latter will be reached exactly or displaced after a short
time, depending on the sensed environment. With expected
sensor values, motion continues as in a typical industrial
robot program. Thus the method is applicable for industrial
robots with standard robot programs which in this way are
locally modiﬁed according to the sensor data.
REFERENCES
[1] F. Debrouwere, W. Van Loock, G. Pipeleers, Q. Tran Dinh, M. Diehl,
J. De Schutter, and J. Swevers. Time-optmal path following for robots
with trajectory jerk constraints using sequential convex programming.
4
Note that this is different to the intended usage. In addition, the used
backward computation of the derivatives is not adequate for the approach
of the library. Therefore overshooting and offset when using the Reﬂexxes
Motion Library are no deﬁciency of that library.
688
689
690
691
692
693
558 559 560 561 562 563 564 565 566 567 568
z-position (mm) 
y-position (mm) 
desired
scaling
backtracking
Reflexxes
Fig. 9. Desired and limited desired trajectories in the y-z-plane using a
predictive sensor with different methods (5 times as fast as Fig. 8).
In Proc. 2013 IEEE Int. Conf. on Robotics and Automation (ICRA),
pages 1908–1913, Karlsruhe, Germany, May 2013.
[2] M. Lawitzky, M. Kimmel, P. Ritzer, and S. Hirche. Trajectory
generation under the least action principle for physical human-robot
cooperation. In Proc. 2013 IEEE Int. Conf. on Robotics and Automa-
tion (ICRA), pages 4270–4275, Karlsruhe, Germany, May 2013.
[3] K. Erkorkmaz and Y . Altintas. High speed CNC system design. Part I:
jerk limited trajectory generation and quintic spline interpolation. Int.
J. of Machine Tools and Manufacture, 41(9):1323–1345, July 2001.
[4] L. van Aken and H. van Brussel. On-line robot trajectory control in
joint coordinates by means of imposed acceleration proﬁles. Robotica,
6(3):185–195, July 1988.
[5] B. Cao, G. I. Dodds, and G. W. Irwin. Time-optimal and smooth
constrained path planning for robot manipulators. In Proc. 1994 IEEE
Int. Conf. on Robotics and Automation (ICRA), pages 1853–1858, San
Diego, California, USA, May 1994.
[6] S. A. Bazaz and B. Tondu. Minimum-time on-line joint trajectory gen-
erator based on low order spline method for industrial manipulators.
Robotics and Autonomous Systems, 29(4):257–268, 1999.
[7] S. Macfarlane and E. A. Croft. Jerk-bounded manipulators trajectory
planning: Design for real-time applications. IEEE Trans. on Robotics,
19(1):42–52, Feb 2003.
[8] L. Biagiotti and C. Melchiorri. B-spline based ﬁlters for multi-point
trajectories planning. In Proc. 2010 IEEE Int. Conf. on Robotics and
Automation (ICRA), pages 3065–3070, Anchorage, Alaska, USA, May
2010.
[9] T. Kr¨ oger and F. M. Wahl. Online trajectory generation: Basic concepts
for instantaneous reactions to unforeseen events. IEEE Trans. on
Robotics, 26(1):94–111, Feb 2010.
[10] Y . Bestaoui. On-line motion generation with velocity and acceleration
constraints. Robotics and Autonomous Systems, 5:279–288, 3 1989.
[11] O. Dahl and L. Nielsen. Torque limited path following by on-line
trajectory time scaling. In Proc. 1989 IEEE Int. Conf. on Robotics
and Automation (ICRA), pages 1122–1128, Scottsdale, Arizona, USA,
May 1989.
[12] Z. Shiller and H.-H Lu. Computation of path constrained time optimal
motions with dynamic singularities. ASME Journal of Dynamic
Systems, Measurements, and Control, 114:34–40, 1 1992.
[13] J. Mattm¨ uller and D. Gisler. Calculating a near time-optimal jerk-
constrained trajectory along a speciﬁed smooth path. Int. J. Adv.
Manuf. Technol., 45:1007–1016, 2009.
[14] M. H. Ghasemi, N. Kashiri, and M. Dardel. Near time-optimal control
of redundant manipulatros along a speciﬁed path with jerk constraint.
Advanced Robotics, 25:2319–2339, 2011.
[15] C. Guarino Lo Bianco and F. Ghilardelli. Techniques to preserve
the stability of a trajectory scaling algorithm. In Proc. 2013 IEEE Int.
Conf. on Robotics and Automation (ICRA), pages 862–868, Karlsruhe,
Germany, May 2013.
[16] B. Cao, G. I. Dodds, and G. W. Irwin. A practical approach to near
time-optimal inspection-task-sequence planning for two cooperative
industrial robot arms. The Int. Journal of Robotics Research, 17:858–
867, 1998.
[17] F. Lange, W. Bertleff, and M. Suppa. Force and trajectory control
of industrial robots in stiff contact. In Proc. 2013 IEEE Int. Conf.
on Robotics and Automation (ICRA), pages 2912–2919, Karlsruhe,
Germany, May 2013.
[18] Reﬂexxes. http://www.reflexxes.com/, last visited 2013.
759
