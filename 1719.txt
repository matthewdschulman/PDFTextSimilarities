Interaction Primitives for Human-Robot Cooperation Tasks
Heni Ben Amor
1
, Gerhard Neumann
2
, Sanket Kamthe
2
, Oliver Kroemer
2
, Jan Peters
2
Abstract—To engage in cooperative activities with human
partners, robots have to possess basic interactive abilities
and skills. However, programming such interactive skills is a
challenging task, as each interaction partner can have different
timing or an alternative way of executing movements. In this
paper, we propose to learn interaction skills by observing how
two humans engage in a similar task. To this end, we introduce
a new representation called Interaction Primitives. Interaction
primitives build on the framework of dynamic motor primitives
(DMPs) by maintaining a distribution over the parameters of
the DMP. With this distribution, we can learn the inherent
correlations of cooperative activities which allow us to infer the
behavior of the partner and to participate in the cooperation.
We will provide algorithms for synchronizing and adapting the
behavior of humans and robots during joint physical activities.
I. INTRODUCTION
Creating autonomous robots that assist humans in situa-
tions of daily life has always been among the most important
visions in robotics research. Such human-friendly assistive
robotics requires robots with dexterous manipulation abilities
and safe compliant control as well as algorithms for human-
robot interaction during skill acquisition. Today, however,
most robots have limited interaction capabilities and are not
prepared to appropriately respond to the movements and
behaviors of their human partners. The main reason for
this limitation is the fact that programming robots for such
interaction scenarios is notoriously hard, as it is difﬁcult to
foresee many possible actions and responses of the human
counterpart.
Over the last ten years, the ﬁeld of imitation learning [12]
has made tremendous progress. In imitation learning, a user
does not specify the robot’s movements using traditional
programming languages. Instead, he only provides one or
more demonstrations of the desired behavior. Based on
these demonstrations, the robot autonomously generates a
control program that allows it to generalize the skill to
different situations. Imitation learning has been successfully
used to learn a wide range of tasks in robotics [2], such
as basic robot walking [4], [5], driving robot cars [10],
object manipulation [9], and helicopter manoeuvring [1].
A particularly successful approach to imitation learning is
based on Dynamic Motor Primitives (DMPs)[6]. DMPs use
dynamical systems as a way of representing control policies,
which can be generalized to new situations. Several motor
1
Institute for Robotics and Intelligent Machines, Georgia Institute of
Technology, 801 Atlantic Drive, Atlanta, GA 30332-0280, USA
2
Intelligent Autonomous Systems, Department of Computer Science,
Technical University Darmstadt, Hochschulstr. 10, 64289 Darmstadt, Ger-
many
Fig. 1. A human-robot interaction scenario as investigated in this paper.
A robot needs to learn when and how to interact with a human partner.
Programming such a behavior manually is a time-consuming and error-
prone process, as it hard to foresee how the interaction partner will behave.
primitives can be chained together to realize more complex
movement sequences.
In this paper, we generalize the concept of imitation learn-
ing to human-robot interaction scenarios. In particular, we
learn interactive motor skills, which allow anthropomorphic
robots to engage in joint physical activities with a human
partner. To this end, the movements of two humans are
recorded using motion capture and subsequently used to
learn a compact model of the observed interaction. In the
remainder of this paper, we will call such a model an
Interaction Primitive (IP). A learned IP is used by a robot
to engage in a similar interaction with a human partner. The
main contribution of this paper is to provide the theoretical
foundations of interaction primitives and their algorithmic
realization. We will discuss the general setup and introduce
three core components, namely methods for (1) phase es-
timation, (2) learning of predictive DMP distributions, and
(3) correlation the movements of two agents. Using exam-
ples from handwriting synthesis and human-robot interaction
tasks, we will clarify how these components relate to each
other. Finally, we will apply our approach to real-world
interaction scenarios using motion capture systems.
II. RELATED WORK
Finding simple and natural ways of specifying robot con-
trol programs is a focal point in robotics. Imitation learning,
also known as programming by demonstration, has been
proposed as a possible solution to this problem [12]. Most ap-
proaches to imitation learning obtain a control policy which
2014 IEEE International Conference on Robotics & Automation (ICRA)
Hong Kong Convention and Exhibition Center
May 31 - June 7, 2014. Hong Kong, China
978-1-4799-3684-7/14/$31.00 ©2014 IEEE 2831
encodes the behavior demonstrated by the user. The policy
can subsequently be used to generate a similar behavior that
is adapted to the current situation. Another way of encoding
policies is to use statistical modeling methods. For example,
in the mimesis model [8] a continuous hidden Markov
model is used for encoding the teacher’s demonstrations.
A similar approach to motion generation is presented by
Calinon et al. [3] who used Gaussian mixture regression to
learn gestures.
The methods discussed so far are limited to single agent
imitation learning scenarios. Recently, various attempts have
been undertaken for using machine learning in human-robot-
interaction scenarios. In [13], an extension of the Gaussian
process dynamics model was used to infer the intention of
a human player during a table-tennis game. Through the
analysis of the human player’s movement, a robot player
was able to determine the position to which the ball will be
returned. This predictive ability allowed the robot to initiate
its movements even before the human hit the ball. In [7],
Gaussian mixture models were used to adapt the timing of
a humanoid robot to a human partner in close-contact in-
teraction scenarios. The parameters of the interaction model
were updated using binary evaluation information obtained
from the human. While the approach allowed for human-
in-the-loop learning and adaptation, it did not include any
imitation of observed interactions. In a similar vein, the
work in [8] showed how a robot can be actively involved
in learning how to interact with a human partner. The
robot performed a previously learned motion pattern and
observed the partner’s reaction to it. Learning was realized
by recognizing the observed reaction and by encoding the
action-reaction patterns in a HMM. The HMM was then used
to synthesize similar interactions.
In our approach, learning of motion and interaction are
not split into two separate parts. Instead, we learn one inte-
grated interaction primitive which can directly synthesize an
appropriate movement in response to an observed movement
of the human partner. Furthermore, instead of modelling
symbolic action-reaction pairs, our approach models the joint
movement of a continuous level. This continuous control
is realized through the use of DMPs as the underlying
representation. By introducing probabilistic distributions and
bayesian inference in the context of DMPs, we obtain a new
set of tools for predicting and reacting to human movements.
III. INTERACTION PRIMITIVES
The goal of learning an Interaction Primitive is to obtain
a compact representation of a joint physical activity between
two persons and use it in human robot interaction. An inter-
action primitive speciﬁes how a person adapts his movements
to the movement of the interaction partner, and vice versa.
For example, in a handing-over task, the receiving person
adapts his arm movements to the reaching motion of the
person performing the handing-over. In this paper, we pro-
pose an imitation learning approach for learning such inter-
action primitives. First, one or several demonstrations of the
interaction task are performed by two human demonstrators
in a motion capture environment. Using the motion capture
data, we extract an interaction primitive which speciﬁes the
reciprocal dependencies during the execution of the task.
Finally, the learned model is used by a robot to engage in a
similar interaction with a human partner. An IP should also
be applicable to a wide variety of related interactions, for
example, handing over an object at different locations. An
example of an interaction of a humanoid robot with a human
partner performing a high-ﬁve movement is given in Fig. 2.
At the core of our approach is a new representation
for interaction tasks. An IP can formally be regarded as a
special type of DMP which represents a joint activity of
two interaction partners. After an IP is learned from the
demonstration data, it is used to control a robot in a similar
task. For the sake of notational clarity, we will refer to
the ﬁrst interaction partner, i.e., the human, as the observed
agent, while the second interaction partner, i.e., the robot,
will be called controlled agent.
The IP performs three steps to infer an appropriate way
of reacting to the movement of the observed agent.
1) Phase Estimation: The actions of the interaction part-
ners are executed in synchrony. In particular, the robot
adapt its timing such that it matches the timing of the
human partner. For this synchronization, we need to
identify the current phase of the interaction
2) Predictive DMP distributions: As a next step, we
compute predictions over the behavior of an agent
given a partial trajectory 
o
of the observed agent.
To do so, we use a probabilistic approach and model
a distribution p() over the parameters of the DMPs.
This distribution can be conditioned on a new, partial
observation, i.e., to obtain an updated parameter dis-
tribution p(j
o
). We use samples of this distribution
to predict the future behavior of the agent.
3) Correlating both Agents: In order to perform a suc-
cessful cooperation, the movement of the robot needs
to be correlated with the movement of the human.
Such operation is a straightforward extension to the
predictive DMP distributions. Instead of conditioning
on the observation of all DoFs, we only condition on
the DoFs of the observed agent, and, hence, we also
obtain a distribution over the DMP parameters of the
controlled agent, that can be used to control the robot.
In the following, we will address each of the steps above
in detail. First, we will recapitulate the basic properties and
components of DMPs. Subsequently, we will describe how
phase estimation, adaptation, and correlation can be realized
within the DMP framework in order to produce an interactive
motor primitive.
A. Dynamic Motor Primitives
A DMP is an adaptive representation of a trajectory
representing a human or robot movement [6]. In this section,
we will give a brief recap of DMPs. The general idea is to
encode a recorded trajectory as dynamical systems, which
can be used to generate different variations of the original
movement. As a result, a robot can generalize a demonstrated
2832
Motion Capture Interaction Primitive Human-Robot Interaction
Fig. 2. An overview of the presented machine learning approach. Left: Using motion capture we ﬁrst record the movements of two persons during
an interaction task. Center: Given the recorded motion capture data, we learn an interaction primitive specifying each persons’ movement as well as the
dependencies between them. Right: During human-robot interaction, the learned interaction primitive is used by the robot to adapt its behavior to that of
his human interaction partner.
movement to new situations that may arise. Formally, a DMP
can be written as a dynamical system
 y = (
y
(
y
(g y)  (( _ y)=)) +f(x))
2
(1)
where y is a state variable such as the joint angle to be
controlled,g is the corresponding goal state, and is a time
scaling factor. The ﬁrst set of terms represents a critically-
damped linear system with constant coefﬁcients 
y
and 
y
.
The last term is called the forcing function
f(x) =
P
m
i=1
 
i
(x)w
i
x
P
m
j=1
 
j
(x)
=(x)
T
w (2)
where 
i
(x) are Gaussian basis functions and w the corre-
sponding weight vectors. The basis functions only depend on
the phase variablex, which is the state of a canonical system
shared by all degrees of feedom (DoFs). The canonical
system acts as a timer to synchronize the different movement
components. It has the form _ x = 
x
x, where x
0
= 1 at
the beginning of the motion and, thereafter, it decays towards
zero. The elements of the weight vector w are denoted as
shape-parameters, as they determine the acceleration proﬁle
of the movement, and, hence, indirectly also the shape of
the movement. Typically, we learn a separate set of shape
parameters w as well as the goal attractor g for each DoF.
The goal attractorg can be used to change the target position
of the movement while the time scaling parameter  can be
used to change the execution speed of the movement.
The weight parametersw of the DMP can be straightfor-
wardly obtained from observed trajectoriesfy
1:T
; _ y
1:T
;  y
1:T
g
by ﬁrst computing the forcing function that would reproduce
the given trajectory, i.e.,
F
i
=
1

2
 y
i
 
y
(
y
(g y
i
)  _ y
i
=): (3)
Subsequently, we can solve the system w =F in a least
squares sense, i.e.,
w = (
T
)
 1

T
F; (4)
where  is a matrix containing of basis vectors for all time
steps, i.e., 
t
=
T
t
=(x
t
).
B. Phase Estimation by Dynamic Time Warping
For a joint activity to succeed, the movement of the
interaction partners needs to be temporally aligned. During
the execution of human-robot interaction, the robot observes
a partial movement of the human counterpart. Given this
partial movement sequence, we need to determine the current
state of the interaction. This is achieved by determining the
current value of the phase variablex. To this end, we will use
the dynamic time warping (DTW) algorithm [11]. DTW is a
method for the alignment of time series data. Given two time
series u = (u
1
; ;u
N
) and v = (v
1
; ;v
M
) of size N
and M, DTW ﬁnds optimal correspondences between data
points, such that a given distance function D is minimized.
This task can be formulated as ﬁnding an alignment between
a reference trajectory u and an observed subsequence v. In
our speciﬁc case, the reference trajectory is the movement of
the observed agent during the original demonstration of the
task, and the query trajectory is the currently seen partial
movement sequence of the human interaction partner. We
deﬁne an alignment  as a set of tuples (
1
;
2
) specifying
a correspondence between point 
1
of the ﬁrst time series
and point 
2
of the second time series. To ﬁnd such an
alignment, we ﬁrst calculate the accumulated cost matrix,
which is deﬁned as
 D(1;m) = 
m
k=1
c(u
1
;v
k
);m2 [1 :M],
 D(n; 1) = 
n
k=1
c(u
k
;v
1
);n2 [1 :N],
 D(n;m) =minfD(n  1;m  1);D(n;m  1);
D(n  1;m)g +c(u
n
;v
m
)
wherec is a local distance measure, which is often set to the
squared Euclidean distance, i.e.,c =jju vjj
2
. In the original
DTW formulation, ﬁnding the optimal alignment is cast as
the problem of ﬁnding a path from (1; 1) to (N;M) produc-
ing minimal costs according to the accumulated cost matrix.
This optimization is achieved using a dynamic programming
recursion. The DTW approach above assumes that both time
series have approximately the same length. However, in our
case we want to match a partial movement to the reference
movement. To this end, we modify the DTW algorithm and
determine the path with minimal distance starting at (1; 1)
and ending at (n

;M), where n

is given by
n

= argmin
n
D(n;M): (5)
2833
Training
Partial
Completion
Fig. 3. Phase estimation and pattern completion using DTW and DMPs.
Given the partial observation (black), we estimate the current phase, and
use it to generate the unseen part (red) of the letter. The goal does not have
to be speciﬁed and is estimated alongside the other parameters.
The index n

reﬂects the frame in the reference movement
which produces minimal costs with respect to the observed
query movement. As a result it can be used to estimate the
current value of the phase variablex of the canonical system.
More speciﬁcally, calculating (n

=N) yields an estimated
of the relative time that has passed, assuming a constant
sampling frequency. Scaling this term nonlinearly yields an
estimate of the phase x of the canonical system
x = exp

 
x

n

N



: (6)
A simple example for the explained phase estimation al-
gorithm can be see Fig 3. The grey trajectories show the
demonstrated handwriting samples for which DMPs have
been learned. The black trajectories show a new, partial
handwriting sample. Using DTW, we can identify the phase
of the DMP and then use it to automatically complete the
observed letter. To this end, we can set the starting position
of the DMP to the last point in the partial trajectory, and
set the phase according to the estimated x. By specifying
any goal positiong, we can generate the missing part of the
observed movement.
C. Predictive Distributions over DMPs
In this section we will introduce predictive distributions
over DMP parameters that can be used to predict the behavior
of an agent given a partial observed trajectory. We will ﬁrst
describe how to generate such predictive distribution for a
single agent and later show in the next section how this
model can be easily extended to infer a control policy for
the controlled agent in an interaction scenario.
In our probabilistic approach, we model a distribution
p() over the parameters of a DMP. In order to also
estimate the target position of the movement, we include
the shape parameters w
i
as well as the goal attractors g
i
for all DoFs i in the parameter vector  of the DMP, i.e.,
 = [w
T
1
;g
1
;:::;w
T
N
;g
N
], whereN is the number of DoFs
for the agent. Given the parameter vector samples 
[j]
of
multiple demonstrationsj = 1:::S, we estimate a Gaussian
distribution over the parameter, i.e.,p() =N (j

; 

),
with


=
P
S
j=1

[j]
S
; 

=
P
S
j=1
(
[j]
 )(
[j]
 )
T
S
:
(7)
In order to obtain a predictive distribution, we observe a
partial trajectory
o
=y
1:t
 up to time pointt

and our goal
is to estimate the distribution p(j
o
) over the parameters
 of the DMP. These parameters can be used to predict
the remaining movement y
t

:T
of the observed agent. The
updated distribution p(j
o
) can simply be computed by
applying Bayes rule, i.e.,
p(j
o
)/p(
o
j)p(): (8)
In order to compute this operation, we ﬁrst have to discuss
how the likelihood p(
o
j) can be implemented. The pa-
rameters of a DMP directly specify the forcing function,
however, we also include the goal positionsg
i
in the forcing
function f
i
for the ith DoF. Therefore, we reformulate the
forcing function, i.e., for a single degree of freedom i, we
will write the forcing function f
i
(t) as
f
i
(x
t
) =
T
t
w
i
+
y

y
g
i
(9)
= [
T
t
;
y

y
]

w
i
g
i

: (10)
The forcing function can be written in matrix form for all
DoFs of the observed agent and for all time steps 1tt

,
i.e.,
F =
2
6
6
6
4
~
 0 :::::
0
~
 0 ::
.
.
.
.
.
.
.
.
.
.
.
.
0 :::::
~

3
7
7
7
5
| {z }


2
6
6
6
6
6
4
w
1
g
1
.
.
.
w
N
g
N
3
7
7
7
7
7
5
= 
; (11)
where thet-th row
~

t;
= [
T
t
;
y

y
] of
~
 contains the basis
functions for time stept and a constant as basis for the goal
attractorg
i
. The matrix 
 contains the basis functions for all
DoFs on its block-diagonal. The vectorF contains the value
of the forcing function for all time steps and all degrees
of freedom, i.e., F = [f
T
1
;:::;f
T
N
]
T
, where f
i
contains
the values of the forcing function for all time steps for the
ith DoF. By concatenating the forcing vectors f
i
for the
single DoFs and by writing 
 as a block-diagonal matrix, we
achieve that the parameters of all DoF can be concatenated
in the vector.
Given an observed trajectoryy
1:t
, we can also compute
the forcing function vectorF

from the observation, i.e., the
elements of theF

vector are given by
f

i
(x
t
) =
1

2
 o
i
(t) 
y
( 
y
o
i
(t)  _ o
i
(t)=): (12)
Now, we can use a Gaussian observation model for the
likelihood
p(
o
j) =N (F

j
;
2
I); (13)
where
2
is the observation noise variance which will act as
regularizer in the subsequent conditioning.
In order to perform the conditioning, we ﬁrst write
p(
o
;) = p(
o
j)p() as a joint Gaussian distribution
2834
Training
Partial
Completion
Fig. 4. Given a set of training trajectories (in gray) we learn a predictive
distribution over the DMP weights. The distribution can then be used to
sample new trajectories with a similar shape. In this example, DTW is used
to determine the current phase of a partially observed trajectory (black). The
completions of this trajectory are performed by estimating the most likely
distribution of DMP weights.
and, subsequently, apply Gaussian conditioning. The joint
distribution is given as
p(
o
;) =N

F


; A 


 

; 



T



; (14)
withA =
2
I + 




T
.
The conditional distributionp(j
o
) is now also Gaussian
with mean and variance

jo
=

+ 



T
A
 1
(F

  


);

jo
= 

  



T
A
 1



:
(15)
Using the above distribution we can compute the most
likely weights 
jo
of the DMPs for any observed partial
movement. In Fig. 4, we see an example of using the above
procedure for estimating weights from partial observations.
On the left side, we see the demonstrations that have been
used to train the DMPs. The different demonstrations reﬂect
different versions of the same alphabet letter. On the right
side, we see the partial observation (black) of a new hand-
written sample as well as the automatic reconstruction using
a DMP with estimated weights.
D. Correlating two Agents with Predictive Distributions
Correlating the controlled agent with its interaction partner
is now a straightforward extension of the predictive DMP
framework. We now assume that we have two agents, the
observed and the controlled agent. In order to capture the
correlation between the agents, we use a combined parameter
vector  = [
T
o
;
T
c
]
T
which contains the DMP parameters

o
of the observed and the parameters
c
of the controlled
agent. We can now use the approach for obtaining a predic-
tive distributionp(j
o
), however, in contrast to the previous
section, the observed trajectory only contains the DoFs of the
observed agent. Hence, in order to write the forcing vector
F = 

o
in terms of the complete parameter vector, we
need to append a zero-matrix to the feature matrix 
, i.e.,
F =
~

, with
~

 = [
; 0]. The conditioning equations given
in (15) can now be applied straightforwardly by replacing 

x-axis [m]
-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
-2
-1.5
-1
-0.5
0
0.5
y-axis [m]
goal
attraction-point
Observed
Agent
Controlled
Agent
attraction-point
Fig. 5. A simple simulation setup for studying Interaction Primitives. Two
opposing (robot) arms of different kinematic structure (2 links vs. 3 links)
execute a high-ﬁve movement to a speciﬁc goal. Using optimal control
methods we can calculate optimal trajectories that reach the goal, while at
the same time being attracted by “attraction points”. The resulting data set
contains strong correlations between the movements of the two agents.
with
~

. The estimated parameter vector can, thus, be used
to to predict the remaining movement of the observed agent
(using
o
) but also to control the robot in the current situation
(using
c
). Hence, its behavior is always related the behavior
of the human interaction partner.
IV. EXPERIMENTS
To evaluate our approach under controlled and varying
conditions, we designed a simple simulation environment
that can be used to study interaction scenarios. The simu-
lation consists of two opposing robot arms with different
kinematic structures as can be seen in Fig. 5. The robot
on the left side (the observed agent) consists of two links
which are connected through a hinge joint, while the robot
on the right side (the controlled agent) has three links and
two joints. The task of the robots is to execute a high-ﬁve
movement. In order to generate training data for this task we
ﬁrst synthesize a set of training trajectories for both agents.
Using optimal control we determine for each agent a joint
angle trajectory which brings it from its start position to a
speciﬁed goal position. Attractor points are added in order to
generate realistic-looking high-ﬁve movements. During the
synthesis of training data, both the goal position and the
attractor positions are varied.
Given this training data, we learn an IP capturing the
mutual dependencies of the agents during the high-ﬁve
movement. After learning, we the use the IP to control the
three linked robot arm. Given partial joint angle trajectories
of the observed agent, we use the IP and conditioning to (1)
determine the most likely current goal, (2) the ideal joint
angle conﬁgurations of the controlled agent.
Fig. 6 depicts task space trajectories for the controlled
agent after conditioning. On the left side we see the results
of conditioning when 40% of the movement of the observed
agent is seen. On the right side are the results after condi-
tioning with 60% of the data. Each trajectory is a possible
prediction of the task space movement of the agent. The
2835
0
1
2
y-axis[m]
0 25 50 75 100
x-axis[m]
0 25 50 75 100
Fig. 6. The uncertainty over the goal position shrinks with increasing
amount of data points. Left: distribution after observing 40% of the
partners movements. Right: distribution after observing 60% of the partners
movements
0
2
4
6
8
10
12
14
16
MSE
0 10 20 30 40 50 60 70 80 90 100
Percentage of trajectory [%]
Controlled
Observed
Fig. 7. Mean squared error based on different percentage of partially
observed trajectories of the interaction partner. The red curve shows the
accuracy of predicting the movements of the observed agent from partial
trajectories. The black curve shows the accuracy in inferring the right
reaction in response to the observed movement.
ﬁgure shows that the uncertainty signiﬁcantly shrinks when
we transition fom 40% to 60% in this example.
To further analyze the accuracy of prediction, we gener-
ated a new test data set consisting of interactions to different
goal positions that were not part of the original training data.
We then calculated the mean squared error (MSE) between
the predicted joint angle trajectories generated from the IP
and the ground-truth data. Fig. 7 shows the evolution of
the MSE for observed partial trajectories of increasing size.
We can see that the MSE in the prediction of the observed
agent signiﬁcantly drops at around 20% and again at 60%. A
similar trend, albeit with higher variance, can also be seen in
the predictions for the ideal response of the controlled agent.
The plot suggests that after seeing 60% of the movement of
the interaction partner we can already roughly infer the goal
he is aiming at.
We also analyzed the difference in task space between the
inferred and the ground-truth data for the controlled agent.
More speciﬁcally, we evaluated how far the predicted goal
is from the true goal of the trajectory. Fig. 8 shows the
true goals and the inferred goals in task space after seeing
60% of the movements of the observed agent. We can see
that the predicted goals are in close proximity to the true
goal locations. Please note, that the depicted positions are
in task space while the inferred values are in joint space.
The depicted position is calculated by performing forward
-0.6
-0.5
-0.4
-0.3
-0.2
-0.1
0.0
y-axis[m]
1.5 1.6 1.7 1.8 1.9
x-axis[m]
Fig. 8. Difference between ground truth and predicted task space goals.
Blue circles show the true positions of the goals. Red circles depict the
predicted goals after observing 60% of the interaction.
(a) (b) (c)
Side
Middle
Fig. 9. Two reactions synthesized from an Interaction Primitive for a
handing-over task. The humanoid on the left side (controlled agent) is
controlled through the IP and has to receive an object from the humanoid
on the right side. Depending on the location where the object is handed
over, the reaction of the controlled agent is changed. Training of the IP was
performed using motion capture data of two humans.
kinematics using the inferred joint angle data. As a result,
even small errors in the joint angle of the ﬁrst link will
propagate and produce larger errors at the end-effector. Still,
the results indicate that the approach can be efﬁciently used
for intention inference in human-robot tasks. By predicting
the most likely goal of the human interaction partner, the
robot can proactively initiate his own response.
We also conducted experiments using real motion capture
data collected from the interactions of two human subjects.
In a ﬁrst experiment we asked two humans to demonstrate a
“handing-over” in which the ﬁrst subject hands a cup to the
second subject. The demonstrations were then used to learn
an IP. However, in order to cope with the high dimensionality
of the dataset, we applied Principal Component Analysis
(PCA) as a pre-processing step, in order to project the data
onto a ﬁve-dimensional space. After training, we tested the
learned IP on a set of data points that have not been used
during training. Fig. 9 shows two example situations, where
the controlled agent (left humanoid) automatically infers the
optimal reaction to the behavior of his interaction partner
(right humanoid). In the ﬁrst sequence the controlled agent
2836
Fig. 10. A frame sequence from a high-ﬁve interaction between a human and a humanoid. The robot automatically reacts to the movement of the human
and estimates the appripriate location of the executed high-ﬁve. The human interaction partner is tracked using an OptiTrack motion capture system.
correctly turns to the left side to receive an object. In contrast
to that, in the second sequence, the agent reaches for the
middle in order to properly react to the observed movement.
Finally, we performed a set of interaction experiments on
a real humanoid robot. The humanoid has two arms with 7
DoF each. During the experiment we used one arm with four
DoFs. More speciﬁcally, we trained an Interaction Primitive
for the high-ﬁve. Again, we collected motion capture data
from two humans for training this IP. After training, the
robot used the IP to predict the joint conﬁguration at the goal
position as well as the weight parameters of the DMP. Fig. 10
shows an example interaction realized via the presented
approach. Using prediction in this task is important, as it
helps the robot to match the timing of the human interaction
partner. Notice that the starting location of the robot is quite
far from the rest poses in the learning database.
V. CONCLUSION
In this paper, we proposed the novel Interaction Primitive
framework based on DMPs and introduced a set of basic
algorithmic tools for synchronizing, adapting, and correlating
motor primitives between cooperating agents. The research
introduced here lays the foundation for imitation learning
methods that are geared towards multi-agent scenarios. We
showed how demonstrations recorded from two interacting
persons can be used to learn an interaction primitive, which
speciﬁes both the executed movements, as well as the cor-
relations in the executed movements. The introduced phase
estimation method based on dynamic time warp proved to
very important for applying a learned interaction primitive in
new situations. Timing is a highly variable parameter, which
varies among different persons, but can also vary depending
on the current mood or fatigue.
In future work, we plan to concentrate on more complex
interaction scenarios, which are composes of several interac-
tion primitives. These primitives could executed in sequence
or in a hierarchy in order to produce complex interactions
with a human partner. We are also already working on using
the interaction primitive framework for predicting the most
likely future movements of a human interaction partner. The
underlying idea is that the same representation which is
used for movement synthesis can also be used for movement
prediction. The predicted actions of the human could then be
integrated into the action selection process of the robot, in
order to avoid any dangerous situations.
VI. ACKNOWLEDGEMENTS
The work presented in this paper is funded through the
Daimler-and-Benz Foundation and the European Communi-
tys Seventh Framework Programme under the grant agree-
ment n ICT-600716 (CoDyCo).
REFERENCES
[1] P. Abbeel, A. Coates, and A. Ng. Autonomous Helicopter Aerobatics
through Apprenticeship Learning. International Journal of Robotic
Research, 29:1608–1639, 2010.
[2] A. Billard, S. Calinon, R. Dillmann, and S. Schaal. Survey: Robot
Programming by Demonstration. In Handbook of Robotics, volume
chapter 59. MIT Press, 2008.
[3] S. Calinon, E.L. Sauser, A.G. Billard, and D.G. Caldwell. Evaluation
of a probabilistic approach to learn and reproduce gestures by imita-
tion. In Proc. IEEE Intl Conf. on Robotics and Automation (ICRA),
pages 2381–2388, Anchorage, Alaska, USA, May 2010.
[4] R. Chalodhorn, D. Grimes, K. Grochow, and R. Rao. Learning to
walk through imitation. In Proceedings of the 20th international joint
conference on Artiﬁcal intelligence, IJCAI’07, pages 2084–2090, San
Francisco, CA, USA, 2007. Morgan Kaufmann Publishers Inc.
[5] D. Grimes, R. Chalodhorn, and R. Rao. Dynamic imitation in a
humanoid robot through nonparametric probabilistic inference. In In
Proceedings of Robotics: Science and Systems (RSS). MIT Press, 2006.
[6] A. Ijspeert, J. Nakanishi, H. Hoffmann, P. Pastor, and S. Schaal.
Dynamical movement primitives: Learning attractor models for motor
behaviors. Neural Comput., 25(2):328–373, February 2013.
[7] S. Ikemoto, H Ben Amor, T. Minato, B. Jung, and H. Ishiguro.
Physical human-robot interaction: Mutual learning and adaptation.
IEEE Robotics and Automation Magazine, 19(4):24–35, Dec.
[8] D. Lee, C. Ott, and Y . Nakamura. Mimetic communication model
with compliant physical contact in human-humanoid interaction. Int.
Journal of Robotics Research., 29(13):1684–1704, November 2010.
[9] M. M¨ uhlig, M. Gienger, and J. Steil. Interactive imitation learning of
object movement skills. Autonomous Robots, 32:97–114, 2012.
[10] D. Pomerleau. ALVINN: an autonomous land vehicle in a neural net-
work. In David S. Touretzky, editor, Advances in Neural Information
Processing Systems 1, pages 305–313. San Francisco, CA: Morgan
Kaufmann, 1989.
[11] H. Sakoe and S. Chiba. Dynamic programming algorithm optimization
for spoken word recognition. Acoustics, Speech and Signal Processing,
IEEE Transactions on, 26(1):43–49, 1978.
[12] S. Schaal. Is imitation learning the route to humanoid robots? Trends
in Cognitive Sciences, 3:233–242, 1999.
[13] Z. Wang, M. Deisenroth, H. Ben Amor, D. V ogt, B. Schoelkopf, and
J Peters. Probabilistic modeling of human dynamics for intention
inference. In Proceedings of Robotics: Science and Systems (R:SS),
2012.
2837
