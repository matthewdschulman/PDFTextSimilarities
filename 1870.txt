Revision of Speciﬁcation Automata under Quantitative Preferences
Kangjin Kim and Georgios Fainekos
Abstract—We study the problem of revising speciﬁcations
withpreferencesforautomatabasedcontrolsynthesisproblems.
In this class of revision problems, the user provides a numerical
rankingofthedesirabilityofthesubgoalsintheirspeciﬁcations.
When the speciﬁcation cannot be satisﬁed on the system, then
our algorithms automatically revise the speciﬁcation so that the
least desirable user goals are removed from the speciﬁcation.
We propose two different versions of the revision problem
with preferences. In the ﬁrst version, the algorithm returns
an exact solution while in the second version the algorithm is
an approximation algorithm with non-constant approximation
ratio. Finally, we demonstrate the scalability of our algorithms
and we experimentally study the approximation ratio of the
approximation algorithm on random problem instances.
I. INTRODUCTION
Linear Temporal Logic (LTL) has been widely adopted
as a high-level speciﬁcation language for robotic behaviors
(see [1] for a recent overview). The wide spread adoption
of LTL can be attributed to the tractable algorithms that can
solve automation problems related to robotics (see [1]) and
the connections to natural language [2] and other intuitive
user interfaces [3]. In order for LTL-based control synthesis
methodstomoveoutsideresearchlabsandbewidelyadopted
by the robotics community as a speciﬁcation language of
choice, speciﬁcation debugging tools must be developed as
well. In [4], [5], we studied the theoretical foundations of
the speciﬁcation automata revision problem and we proposed
heuristic algorithms for its solution. In [6], we presented
a version of the revision problem for weighted transition
systems. In the last formulation, the debugging and revision
problem becomes harder to solve since the speciﬁcation
could fail due to not satisfying certain cost constraints, such
as, the battery capacity, certain time limit, etc.
Here, we revisit the problem posed in [4]. When auto-
matically revising speciﬁcations, we are often faced with the
challenge that not all goals have the same value for the user.
In particular, we assume that the user has certain utility or
preferencevalueforeachofthesubgoals.Thus,anautomatic
speciﬁcation revision should recommend removing the least
desirable goals. In detail, we assume that the speciﬁcation
is provided as an ?-automaton, i.e., a ﬁnite automaton with
B¨ uchi acceptance conditions, and that each symbol labeling
the transitions has a quantitative preference value (i.e., a
positive number).
We formulate two different revision problems. The ﬁrst
problem concerns removing a set of symbols such that
This work has been partially supported by award NSF CNS 1116136.
K. Kim and G. Fainekos are with the School of Computing, Informatics
and Decision Systems Engineering, Arizona State University, Tempe, AZ
85281, USA {Kangjin.Kim,fainekos}@asu.edu
the synthesis problem has now a solution and the sum
of the preference levels of the set of removed symbols is
minimized. The second problem again seeks to remove a
set of symbols such that the synthesis problem has now a
solution; but now the largest preference level of the symbols
in the removal set must be minimized.
Not surprisingly the former problem is intractable. How-
ever, interestingly, the latter problem can be solved in poly-
nomial time. We show how the algorithm that we presented
in [5] can be modiﬁed to provide an exact or approximate
solution (depending on the cost function) to the revision
problem with preferences in polynomial time. A practical
implication of the results in this paper is that the user can
now get an exact solution if the goal is to satisfy as many
high preference goals as possible.
Contributions: We deﬁne two new versions of the prob-
lem of revision under quantitative preferences. We show that
oneversioncanbesolvedoptimallyinpolynomialtimewhile
the other version of the problem is in general intractable.
We provide an exact and an approximate, respectively,
polynomial time algorithm based on Dijkstra’s algorithm.
Finally, we present some examples and we demonstrate the
computational savings of our approximate algorithm over
the Brute-Force Search Algorithm that solves the intractable
version of the problem exactly.
Related Research: The problem of revising or resolving
conﬂicting LTL speciﬁcations has received considerable at-
tention recently. The closest work to ours is presented in
[7]. The authors consider a number of high-level require-
ments in LTL which not all can be satisﬁed on the system.
Each formula that is satisﬁed gains some reward. The goal
of their algorithm is to maximize the rewards and, thus,
maximize the number of requirements that can be satisﬁed
on the system. Our problem deﬁnition is similar in spirit,
but the problem goals are substantially different and the
two approaches can be viewed as complementary. In [7],
if a whole sub-speciﬁcation cannot be realized, then it is
aborted. In our case, we try to minimally revise the sub-
speciﬁcation so that it can be partially satisﬁed. Another
substantial difference is that our proposed solutions can be
incorporated directly within the control synthesis algorithm.
Namely, as the algorithm searches for a satisﬁable plan, it
also creates the graph where the search for the revision will
take place. In [7], the graph to be used for the revision must
be constructed as a separate step.
The problem of LTL planning with qualitative preferences
has been studied in [8], [9] (see also the references therein
for more research in this direction). As opposed to revision
problem, planning with preferences is based on the fact
2014 IEEE International Conference on Robotics & Automation (ICRA)
Hong Kong Convention and Exhibition Center
May 31 - June 7, 2014. Hong Kong, China
978-1-4799-3684-7/14/$31.00 ©2014 IEEE 5339
that there are many satisﬁable plans and, thus, the most
preferable one should be selected. For LTL games, LTLMop
[10] was developed to debug unrealizable LTL speciﬁcations
in reactive planning for robotic applications. The problem of
revising LTL speciﬁcations on-the-ﬂy as the robot explores
its environment is studied in [11].
In the context of general planners, the problem of ﬁnding
good excuses on why the planning failed has been studied in
[12]. Over-Subscription Planning (OSP) [13] and Partial Sat-
isfaction Planning (PSP) [14] are also very related problems.
The aforementioned approaches do not consider extended
goals in LTL.
II. PRELIMINARIES
In this paper, we work with discrete abstractions (Finite
State Machines) of the continuous robotic control system
[15]. Each state of the Finite State Machine (FSM)T is
labeled by a number of symbols from a set ? ={π
0
, π
1
,
...,π
n
} that represent regions in the conﬁguration space of
the robot or, more generally, actions that can be performed
by the robot.
Deﬁnition 1 (FSM): A Finite State Machine is a tuple
T = (Q,Q
0
,?
T
,h
T
,?) where: Q is a set of states;
Q
0
?Qisthesetofpossibleinitialstates;?
T
=E?Q?Q
is the transition relation; and, h
T
: Q?P(?) maps each
state q to the set of atomic propositions that are true on q.
We deﬁne a pathp :N?Q on the FSM to be a sequence
of states and a trace to be the corresponding sequence of sets
of propositions. Formally, a path is a function p : N? Q
such that for each i?N we have p(i)?
T
p(i+1) and the
trace is the function composition ¯ p = h
T
?p :N?P(?).
The languageL(T ) ofT consists of all possible traces.
Assumption 1: All the states onT are reachable.
In this work, we are interested in the speciﬁcation au-
tomata that impose certain requirements on the traces ofT.
In the following,P(?) denotes the powerset of a set ?.
Deﬁnition 2: A speciﬁcation automaton is a tupleB
s
=
(S
Bs
,s
Bs
0
,P(?),?
Bs
,F
Bs
,?) where: S
Bs
is a ﬁnite set of
states; s
Bs
0
is the initial state;P(?) is the input alphabet;
?
Bs
:S
Bs
?P(?)?P(S
Bs
) is a transition function;F
Bs
?
S
Bs
is a set of ﬁnal states; and ? : ??S
2
Bs
? R
≥0
is a
preference function.
When s
?
? ?
Bs
(s,l), we also write s
l
?
Bs
s
?
or
(s,l,s
?
) ??
Bs
. A run r of B
s
is a sequence of states
r : N ? S
Bs
that occurs under an input trace ¯ p taking
values inP(?). That is, for i = 0 we have r(0) =s
Bs
0
and
for all i≥ 0 we have r(i)
¯ p(i)
?
Bs
r(i+1). Let lim(·) be the
function that returns the set of states that are encountered
inﬁnitely often in the run r of B
s
. Then, a run r of an
automatonB
s
over an inﬁnite trace ¯ p is accepting if and
only if lim(r)?F
Bs
6=?. This is called a B¨ uchi acceptance
condition. Finally, we deﬁne the languageL(B
s
) ofB
s
to be
the set of all traces ¯ p that have a run that is accepted byB
s
.
In order to simplify the discussion in Section III, we will
make the following assumption without loss of generality.
Assumption 2: Betweenanytwostatesofthespeciﬁcation
automaton there exists at most one transition.
We will also be using the following notations.
• we deﬁne the set E
Bs
? S
2
Bs
, such that (s,s
?
)? E
Bs
iff?l?P(?) , s
l
?
Bs
s
?
; and,
• wedeﬁnethefunction?
Bs
:S
2
Bs
?P(?)whichmapsa
pairofstatestothelabelofthecorrespondingtransition,
i.e., if s
l
?
Bs
s
?
, then ?
Bs
(s,s
?
) =l.
In brief, our goal is to generate paths onT that satisfy
the speciﬁcationB
s
[15]. This can be achived by ﬁnding
accepting runs on the product automatonA =T?B
s
.
Deﬁnition 3: The product automatonA =T?B
s
is the
automatonA = (S
A
,s
A
0
,P(?),?
A
,F
A
) where:
• S
A
=Q?S
Bs
,
• s
A
0
={(q
0
,s
Bs
0
)|q
0
?Q
0
},
• ?
A
:S
A
?P(?)?P(S
A
) s.t. (q
j
,s
j
)??
A
((q
i
,s
i
),l)
iff q
i
?
T
q
j
and s
j
??
Bs
(s
i
,l) with l?h
T
(q
j
),
• F
A
=Q?F is the set of accepting states.
We say thatB
s
is satisﬁable onT ifL(A)6=?. Moreover,
ﬁnding a satisfying path onT ?B
s
is an easy algorithmic
problem [15]. Each accepting (inﬁnite) run consists of two
parts: preﬁx: a part that is executed only once (from an
initial state to a ﬁnal state) and, lasso: a part that is repeated
inﬁnitely (from a ﬁnal state back to itself). Note that if the
preﬁx or the lasso do not contain a ﬁnal state, then the
languageL(A) is empty. Namely, the synthesis phase has
failed and we cannot ﬁnd a system behavior that satisﬁes
the speciﬁcation.
When a speciﬁcationB is not satisﬁable on a particular
systemT, the current motion planning and control synthesis
methodsbasedonautomatatheoreticconcepts[15]–[17]sim-
ply return that the speciﬁcation is not satisﬁable without any
other user feedback. In such cases, our previous algorithms
[4], [5] can provide as feedback to the user the closest
revision under equal preference for all goals. Formally, a
revision R is a subset ofP(?)?E
Bs
. Each (π,s,s
?
)? R
indicates that π must be removed from ?
Bs
(s,s
?
).
III. REVISION UNDER PREFERENCES
When choosing an alternative plan, each user can have
different preferences. Suppose that users can assign some
preference level to each proposition labeling the speciﬁca-
tion automaton through the preference function ?. When
preference level is 0, it is least preferred, and the greater
preference level is, the more preferred it is. However, pref-
erence level cannot be∞. We remark that each occurrence
of an atomic proposition over different transitions can have
different preference levels. Therefore, taking transitions on
the cross-product automaton A, we can get as a reward
preference levels of elements in ? on the transitions.
A revised speciﬁcation is one that can be satisﬁed on the
discrete abstraction of the workspace or the conﬁguration
space of the robot. In order to search for a minimal revision,
we need ﬁrst to deﬁne an ordering relation on automata
as well as a distance function between automata. We do
not want to consider the “space” of all possible automata,
but rather the “space” of speciﬁcation automata which are
semantically close to the initial speciﬁcation automatonB
s
.
5340
The later will imply that we remain close to the initial
intention of the designer. We propose that this space con-
sists of all the automata that can be derived fromB
s
by
removing symbols from the transitions. Our deﬁnition of the
ordering relation between automata relies upon the previous
assumption.
Deﬁnition 4 (Relaxation): Let B
1
= (S
B1
, s
B1
0
, P(?),
?
B1
, F
B1
, ?
B1
) andB
2
= (S
B2
,s
B2
0
,P(?),?
B2
,F
B2
,?
B2
)
be two speciﬁcation automata having the same preference
levels forP(?). Then, we say thatB
2
is a relaxation of
B
1
and we writeB
1
B
2
if and only if S
B1
= S
B2
= S,
s
B1
0
=s
B2
0
, F
B1
=F
B2
, ?
B1
=?
B2
and
1) ?(s,l,s
?
)??
B1
??
B2
.?l
?
.
(s,l
?
,s
?
)??
B2
??
B1
and l
?
?l.
2) ?(s,l,s
?
)??
B2
??
B1
.?l
?
.
(s,l
?
,s
?
)??
B1
??
B2
and l?l
?
.
We remark that ifB
1
B
2
, thenL(B
1
)?L(B
2
) since
the relaxed automaton allows more behaviors to occur.
We can now deﬁne the set of automata over which we will
search for a revision.
Deﬁnition 5: Given a systemT and and a speciﬁcation
automatonB
s
, the set of valid relaxations ofB
s
is deﬁned
asR(B
s
,T ) ={B|B
s
B andL(T?B)6=?}.
We can now search for a solution in the set R(B
s
,T ).
Different solutions can be compared from their revision sets.
Deﬁnition 6 (Revision Set): Givenaspeciﬁcationautoma-
tonB
s
and aB?R(B
s
,T ), the revision set is deﬁned as
R(B
s
,B) ={(π,s,s
?
)|π? (?
Bs
(s,s
?
)??
B
(s,s
?
))}.
We deﬁne two different revision problems.
Problem 1 (Min-Sum Revision): Given a system T and
a speciﬁcation automaton B
s
, if the speciﬁcation B
s
is
not satisﬁable onT, then ﬁnd a revision set R such that
P
??R
?(?) is minimized.
Problem 2 (Min-Max Revision): Given a system T and
a speciﬁcation automaton B
s
, if the speciﬁcation B
s
is
not satisﬁable onT, then ﬁnd a revision set R such that
max
??R
?(?) is minimized.
The edges ofG
A
are labeled by the set of symbols which
if removed from the corresponding transition onB
s
, they
will enable the transition onA. The overall problem then
becomes one of ﬁnding the least number of symbols to be
removed in order for the product graph to have an accepting
run.
Deﬁnition 7: Given a system T and a speciﬁca-
tion automaton B
s
, we deﬁne the graph G
A
=
(V,E,v
s
,V
f
,?,?,p), which corresponds to the product
A =T?B
s
as follows
• V =S is the set of nodes
• E = E
A
? E
D
? S?S, where E
A
is the set
of edges that correspond to transitions on A, i.e.,
((q,s),(q
?
,s
?
)) ? E
A
iff ?l ? P(?) . (q,s)
l
?
A
(q
?
,s
?
); and E
D
is the set of edges that correspond
to disabled transitions, i.e., ((q,s),(q
?
,s
?
)) ? E
D
iff
q?
T
q
?
and s
l
?
Bs
s
?
with l?(??h
T
(q
?
))6=?
• v
s
=s
A
0
is the source node
• V
f
=F
A
is the set of sinks
• ? ={hπ,(s,s
?
)i|π? ?,(s,s
?
)?E
Bs
}
• ? :E?P(?) is the edge labeling function such that
if e = ((q,s),(q
?
,s
?
)), then
?(e) ={hπ,(s,s
?
)i|π? (?
Bs
(s,s
?
)?h
T
(q
?
))}.
• ? : ??R
≥0
is the preference function ofB
s
restricted
on ?.
If ?(e)6=?, then it speciﬁes those atomic propositions
in ?
Bs
(s,s
?
) that need to be removed in order to enable the
edge inA. Again, note that the labels of the edges ofG
A
are
subsets of ? rather than ?. This is due to the fact that we
are looking into removing an atomic proposition π from a
speciﬁc transition (s,l,s
?
) ofB
s
rather than all occurrences
of π inB
s
.
Consider now a path that reaches an accept state and then
can loop back to the same accept state. The set of labels
of the path is a revision set R that corresponds to some
B? R(B
s
,T ). This is immediate by the deﬁnition of the
graphG
A
. Thus, our goal is to solve the Min-Sum and Min-
Max revision problems on this graph.
First, we study the computational complexity of the two
problemsbyrestrictingthesearchproblemonlytopathsfrom
source (initial state) to sink (accept state). Let Paths(G
A
)
denote all such paths on G
A
. We indicate that the graph
search equivalent problem of Problem 2 is in P. Given a
path p =v
s
v
1
v
2
...v
f
on G
A
with v
f
?V
f
, we deﬁne the
max-preference level of the path to be:
?
max
(p) = max
(vi,vi+1)?p
?(?(v
i
,v
i+1
))
Note that this is the same as the original cost function
in Problem 2 since clearly max
(vi,vi+1)?p
?(?(v
i
,v
i+1
)) =
max
??R
?(?) where R = ?
(vi,vi+1)?p
?(v
i
,v
i+1
). Thus,
Problem 2 is converted into the following optimization
problem:
p
?
= arg min
p?Paths(GA)
?(p) (1)
And, thus, the revision will beR =?
(vi,vi+1)?p
??(v
i
,v
i+1
).
Now, we recall the weak optimality principle [18].
Deﬁnition 8 (Weak optimality principle): There is an op-
timal path formed by optimal subpaths.
Proposition 1: The graph search equivalent of Problem 2
satisﬁes the weak optimality principle.
The importance of the weak optimality principle being
satisﬁed is that label correcting and label setting algorithms
can be applied to such problems [18]. Dijkstra’s algorithm
is such an algorithm [19] and, thus, it can provide an exact
solution to the problem.
Now, we proceed to the Min-Sum preference problem.
Given a path p = v
s
v
1
v
2
...v
f
on G
A
with v
f
? V
f
, we
deﬁne the sum-preference level of the path to be:
?
+
(p) =
X
{?(?)|???
(vi,vi+1)?p
?(v
i
,v
i+1
)}
and if we are directly provided with a revision set R, then
?
+
(R) =
X
??R
?(?)
5341
Problem 3: Labeled Path under Additive Preferences
(LPAP). INPUTS: A graphG
A
= (V,E,v
s
,V
f
,?,?,?), and
a preference boundK?N. OUTPUT: a setR? ? such that
removing all elements in R from edges in E enables a path
from v
s
to some ﬁnal vertex v
f
?V
f
and ?
+
(R)≤K.
We can show that the corresponding decision problem is
NP-Complete.
Theorem 1: Given an instance of the LPAP (G
A
,K), the
decision problem of whether there exists a path p such that
?
+
(p)≤K is NP-Complete.
IV. ALGORITHMS FOR THE REVISION PROBLEM WITH
PREFERENCES
In this section, we present Algorithms for the Revision
Problem with Preferences (ARPP). It is based on the Ap-
proximation Algorithm of the Minimal Revision Problem
(AAMRP) [5] which is in turn based on Dijkstra’s shortest
path algorithm [19]. The main difference from AAMRP
is that instead of ﬁnding the minimum number of atomic
propositions that must be removed from each edge on the
paths of the graph G
A
, ARPP tracks paths having atomic
propositions that minimize the preference level from each
edge on the paths of the graph G
A
.
Here, we present the pseudocode for ARPP. ARPP is
similar to AAMRP in [5]. The difference from [5] is that
AARP uses PREF function instead of using cardinality of the
set. For Min-Sum Revision, the function PREF: ?? R
≥0
is deﬁned as following: given a set of label R? ? and the
preference function ?
+
: ?? R
≥0
, PREF(R) = ?
+
(R).
The Min-Sum ARPP is denoted by ARPP
+
. For Min-
Max Revision, the function PREF: ?? R
≥0
is deﬁned as
following: given a set of label R? ? and the preference
function? : ??R
≥0
, PREF(R) = max
??R
?(?). The Min-
Max ARPP is denoted by ARPP
max
.
The main algorithm (Alg. 1) divides the problem into
two tasks. First, in line 5, it ﬁnds an approximation to the
minimum preference level of atomic propositions from ?
that must be removed to have a preﬁx path to each reachable
sink (see Section II). Then, in line 9, it repeats the process
from each reachable ﬁnal state to ﬁnd an approximation to
the minimum preference level of atomic propositions from
? that must be removed so that a lasso path is enabled. The
combination of preﬁx/lasso that removes the least preferable
atomic propositions is returned to the user. Due to space lim-
itations,weomitAlgorithm2 FINDMINPATH andAlgorithm
3 RELAX (for details, see [20]).
The analysis of the algorithm ARPP follows closely
the analysis of AAMRP in [5]. The only difference in
the time complexity is that ARPP uses PREF function
in order to compute preference levels of all elements in
?. Both Min-Sum Revision and Min-Max Revision take
O(?) since at most they compute preference levels of all
elements in ?. Hence, the running time of FINDMINPATH
is O(E(?
2
log? + logV)). Therefore, the running time
of ARPP is O(V
f
(V?log? +E(?
2
log? + logV))) =
O(V
f
E(?
2
log?+logV)) which is polynomial in the size
of the input graph.
Algorithm 1 ARPP
Inputs: a graph G
A
= (V,E,v
s
,V
f
,?,?,?).
Outputs: the listL of symbols from ? that must be removed
fromB
s
.
1: procedure ARPP(G
A
)
2: L? ?
3: M[:,:]? (?,∞) ? Each row is set to (?,∞)
4: M[v
s
,:]? (?,0) ? Initialize the source node
5: hM,P,Vi? FINDMINPATH(G
A
,M,0)
6: ifV?V
f
=? then L??
7: else
8: for v
f
?V?V
f
do
9: L
p
? GETAPFROMPATH(v
s
,v
f
,M,P)
10: M
?
[:,:]? (?,∞)
11: M
?
[v
f
,:]?M[v
f
,:]
12: G
?
A
? (V,E,v
f
,{v
f
},?,L)
13: hM
?
,P
?
,V
?
i? FINDMINPATH(G
?
A
,M
?
,1)
14: if v
f
?V
?
then
15: L
l
? GETAPFROMPATH(v
f
,v
f
,M
?
,P
?
)
16: if PREF(L
p
?L
l
)≤ PREF(L) then
17: L?L
p
?L
l
18: end if
19: end if
20: end for
21: end if
22: return L
23: end procedure
The function GETAPFROMPATH((v
s
,v
f
,M,P)) returns the
atomic propositions that must be removed fromB
s
in order
to enable a path onA from a starting statev
s
to a ﬁnal state
v
f
given the tablesM andP.
V. EXAMPLE AND EXPERIMENTS
In this section, we present an example scenario and
experimental results using our prototype implementation of
algorithms and brute-force search.
In the following example, we will be using LTL as a spec-
iﬁcation language. We remark that the results presented here
canbeeasilyextendedtoLTLformulasbyrenamingrepeated
occurrences of atomic propositions in the speciﬁcation and
adding them on the transition system (for details, see [21]).
Thefollowingexamplescenariowasinspiredby[16],[22],
and we will be using LTL as a speciﬁcation language.
Example 1 (Single Robot Data Gathering Task): In this
example, we use a simpliﬁed road network having three
gathering locations and two upload locations with four
intersections of the road. In Fig. 1, the data gather locations,
which are labeled g
1
, g
2
, and g
3
, are dark gray, the data
upload locations, which are labeled u
1
and u
2
, are light
gray, and the intersections are labeledi
1
throughi
4
. In order
to gather data and upload the gather-data persistently, the
following LTL formula may be considered: ?
A
:= GF(?)?
GF(π), where ? := g
1
?g
2
?g
3
and π := u
1
?u
2
. The
following formula can make the robot move from gather
locations to upload locations after gathering data: ?
G
:=
5342
u
1
u
2
i
1
i
2
i
3
i
4
g
1
g
2
g
3
u1
g1
g2
g3
u2
i1
i2 i4
i3
Fig. 1: Illustration of the simple road network environment
of Example 1. The robot is required to drive right-side of
the road.
G(?? X(¬?Uπ)). In order for the robot to move to gather
location after uploading, the following formula is needed:
?
U
:= G(π? X(¬πU?)).
Let us consider that some parts of road are not recom-
mended to drive from gather locations, such as from i
4
to
i
2
and from i
1
to i
2
. We can describe those constraints as
follows:?
1
:=G(g
1
?¬(i
4
?Xi
2
)Uu
1
)and?
2
:=G(g
2
?
¬(i
1
? Xi
2
)Uu
2
). If the gathering task should have an order
such asg
3
,g
1
,g
2
,g
3
,g
1
,g
2
,..., then the following formula
could be considered: ?
O
:= ((¬g
1
?¬g
2
)Ug
3
)? G(g
3
?
X((¬g
2
?¬g
3
)Ug
1
))? G(g
1
? X((¬g
1
?¬g
3
)Ug
2
))?
G(g
2
? X((¬g
1
? ¬g
2
)Ug
3
)). Now, we can informally
describe the mission. The mission is “Always gather data
from g
3
, g
1
, g
2
in this order and upload the collected data
to u
1
and u
2
. Once data gathering is ﬁnished, do not visit
gather locations until the data is uploaded. Once uploading
is ﬁnished, do not visit upload locations until gathering data.
You should always avoid the road from i
4
to i
2
when you
head to u
1
from g
1
and from i
1
to i
2
when you head to u
2
from g
2
”. The following formula represents this mission:
?
single
:= ?
O
??
G
??
U
??
1
??
2
? GF(π).
Assume that initially, the robot is in i
3
and ﬁnal nodes
are u
1
and u
2
. When we made a cross product with the
roadandthespeciﬁcation,wecouldget36824states,350114
transitions and 100 ﬁnal states. Not removing some atomic
propositions, the speciﬁcation was not satisﬁable.
We tested two different preference levels. For clarity in
presentation, we omit for presenting preference levels on
eachtransitionsincewesetforalltheoccurancesofthesame
symbols the same preference level, we abuse notation and
write ?(π) instead of ?(π,(s
i
,s
j
)). However, the revision
is for speciﬁcation transitions. First, the preference level of
the symbols are as follows: for g
1
, g
2
, g
3
, u
1
, u
2
, i
1
, i
2
,
i
3
, i
4
, the preference levels are 3, 4, 5, 20, 20, 1, 1, 1, 1,
respectively, and for¬g
1
,¬g
2
,¬g
3
,¬u
1
,¬u
2
,¬i
1
,¬i
2
,
¬i
3
,¬i
4
, the preference levels are 3, 4, 5, 20, 20, 1, 1, 1,
1, respectively. ARPP for Min-Sum Revision took 210.979
seconds, and suggested removing¬g
1
and¬i
4
. The total
returned preference was 4 since ?(¬g
1
) = 3 and ?(¬i
4
) =
1. The sequence of the locations suggested by ARPP
is i
3
g
3
i
2
u
1
(i
1
g
1
i
3
u
2
i
1
i
2
i
4
g
2
i
3
u
2
i
1
g
1
i
3
g
3
i
4
i
2
u
1
)
+
. We can
check that ¬g
1
is from G(g
2
? X((¬g
1
?¬g
2
)Ug
3
))
of the formula ?
O
and from ¬? = ¬(g
1
? g
2
? g
3
) of
the formula ?
G
= G(? ? (¬?Uπ)), and ¬i
4
is from
G(g
1
?¬(i
4
?Xi
2
)Uu
1
) of the formula ?
1
. AARP for
Min-Max Revision took 239 seconds, and returned g
1
,¬g
1
,
¬i
1
, and¬i
4
. The maximum returned preference was 3 since
?(g
1
) = 3 and ?(¬g
1
) = 3.
In the second case, the preference level of the posi-
tive atomic propositions are same as the ﬁrst test, and
the preference level of the negative atomic propositions
are as follow: for ¬g
1
, ¬g
2
, ¬g
3
, ¬u
1
, ¬u
2
, ¬i
1
, ¬i
2
,
¬i
3
, ¬i
4
, the preference levels are 3, 4, 5, 20, 20, 10,
10, 10, 10, respectively. In this case, ARPP for Min-Sum
Revision took 207.885 seconds, and suggested removing
g
3
. The total returned preference was 5 since ?(g
3
) =
5. The sequence of the locations suggested by ARPP
is i
3
g
3
i
4
i
2
u
1
(i
1
g
1
i
3
u
2
i
1
i
2
i
4
g
2
i
3
u
2
i
1
i
2
u
1
)
+
. We can check
thatg
3
is fromG(g
3
?X((¬g
2
?¬g
3
)Ug1)) of the formula
?
O
and from ? = (g
1
?g
2
? g
3
) of the formula ?
U
=
G(? ? X(¬?U?). ARPP for Min-Max Revision took
214.322 seconds, and returned g
1
and¬g
1
. The maximum
preference was 3 since ?(g
1
) = 3 and ?(¬g
1
) = 3. ?
Now,wepresentsomeexperimentalresults.Thepropotype
implementationiswritteninPython.Fortheexperiments,we
utilized the ASU super computing center which consists of
clusters of Dual 4-core processors, 16 GB Intel(R) Xeon(R)
CPU X5355 @2.66 Ghz. The operating system is CentOS
release 5.9. The clusters were used to run each test case on
each single core in parallel.
In order to assess the experimental approximation ratio of
theheuristic(Min-SumRevision),wecomparedthesolutions
returned by the heuristic with Brute-force search algorithm.
The Brute-force search is guaranteed to return a minimal
solution to the Min-Sum Revision problem. We omit the
explanation of the each test case and full experiment results
(for details, see [20]).
Table I compares the results of the Brute-Force Search
Algorithm with the results of ARPP for Min-Sum Revision
(ARPP
+
) on test cases of different sizes (total number of
nodes). For each graph size, we performed 200 tests and
we report minimum, average, and maximum computation
times in sec. The “avg # nodes” column shows the average
number of nodes returned from ARPP
+
. Both algorithms
were able to ﬁnish the computation and return a minimal
revision for instances having 9 nodes and 100 nodes. How-
ever, for instances having 196 nodes, the Brute-Force Search
Algorithm had one failed instance which exceeded the 2 hrs
windowlimit.Inthelargeprobleminstances,ARPPforMin-
Sum Revision achieved a 600 time speed-up on the average
running time.
Table II shows the results of ARPP for Min-Max Revision
(ARPP
max
) on test cases of different sizes (total number of
nodes). This test results also used same test cases as the ones
for Table I. We report minimum, average, and maximum
computation times in sec. The “avg # nodes” shows the
average number of nodes returned from ARPP
max
.
5343
Nodes Brute-Force Min-Sum Revision (ARPP
+
) RATIO
min avg max succ min avg max succ avg # nodes min avg max
9 0.033 0.0921 0.945 200/200 0.019 0.183 0.874 200/200 1.305 1 1 1
100 0.065 0.3707 3.997 200/200 0.065 0.1598 2.66 200/200 1.95 1 1.003 1.619
196 0.278 303.55 11974 199/200 0.137 0.4927 12.057 200/200 2.305 1 1.0014 1.1475
TABLE I: Numerical Experiments: Number of nodes versus the results of Brute-Force Search Algorithm and ARPP for
Min-Sum Revision. Under the Brute-Force and Min-Sum Revision columns the numbers indicate computation times in sec.
RATIO indicates the experimentally observed approximation ratio to the optimal solution.
Nodes Min-Max Revision (ARPPmax)
min avg max succ avg # nodes
9 0.02 0.0508 0.66 200/200 1.785
100 0.061 0.1258 0.471 200/200 3.215
196 0.139 0.29824 0.74 200/200 3.84
TABLE II: Numerical Experiments: For each graph G
A
,
Number of nodes versus the result of ARPP for Min-Max
Revision (ARPP
max
). Under the min, avg, max columns
the numbers indicate computation times in sec.
VI. CONCLUSIONS
This paper discusses the problem of speciﬁcation revision
with user preferences. We have demonstrated that adding
preference levels to the goals in the speciﬁcation can render
the revision problem easier to solve under the appropriate
cost function. We view the automatic debugging and speciﬁ-
cation revision problems as foundational for formal methods
to receive wider adoption in the robotics community and
beyond. With the current paper and the predecessors [4]–[6],
[23], we have studied the theoretical foundations of different
versions of the problem. Our algorithms and tools can be
used as add-ons to control synthesis methods developed by
our and other groups [15]–[17], [24], [25]. Our goal for
the future is to incorporate all the speciﬁcation revision
methods in a comprehensive user-friendly tool that can run
on different platforms.
ACKNOWLEDGMENTS
The authors would like to thank the anonymous reviewers
for their detailed comments.
REFERENCES
[1] H. Kress-Gazit, “Robot challenges: Toward development of veriﬁca-
tion and synthesis techniques [errata],” IEEE Robotics Automation
Magazine, vol. 18, no. 4, pp. 108–109, Dec. 2011.
[2] H. Kress-Gazit, G. E. Fainekos, and G. J. Pappas, “Translating
structured english to robot controllers,” Advanced Robotics, vol. 22,
no. 12, pp. 1343–1359, 2008.
[3] S. Srinivas, R. Kermani, K. Kim, Y. Kobayashi, and G. Fainekos,
“A graphical language for LTL motion and mission planning,” in
Proceedings of the IEEE International Conference on Robotics and
Biomimetics, 2013.
[4] K. Kim, G. Fainekos, and S. Sankaranarayanan, “On the revision
problem of speciﬁcation automata,” in Proceedings of the IEEE
Conference on Robotics and Automation, May 2012.
[5] K. Kim and G. Fainekos, “Approximate solutions for the minimal
revision problem of speciﬁcation automata,” in Proceedings of the
IEEE/RSJ International Conference on Intelligent Robots and Systems,
2012.
[6] ——,“Minimalspeciﬁcationrevisionforweightedtransitionsystems,”
in Proceedings of the IEEE Conference on Robotics and Automation,
May 2013.
[7] J. Tumova, L. I. R. Castro, S. Karaman, E. Frazzoli, and D. Rus,
“Minimum-violating planning with conﬂicting speciﬁcations,” in
American Control Conference, 2013.
[8] T. C. Son, E. Pontelli, and C. Baral, “A non-monotonic goal speciﬁca-
tion language for planning with preferences,” in 6th Multidisciplinary
Workshop on Advances in Preference Handling, 2012.
[9] M. Bienvenu, C. Fritz, and S. McIlraith, “Planning with qualitative
temporal preferences,” in International Conference on Principles of
Knowledge Representation and Reasoning, 2006.
[10] V. Raman and H. Kress-Gazit, “Analyzing unsynthesizable speciﬁca-
tions for high-level robot behavior using LTLMoP,” in 23rd Interna-
tional Conference on Computer Aided Veriﬁcation, ser. LNCS, vol.
6806. Springer, 2011, pp. 663–668.
[11] M. Guo, K. H. Johansson, and D. V. Dimarogonas, “Revising motion
planning under linear temporal logic speciﬁcations in partially known
workspaces,” in Proceedings of the IEEE Conference on Robotics and
Automation, 2013.
[12] M. G¨ obelbecker, T. Keller, P. Eyerich, M. Brenner, and B. Nebel,
“Coming up with good excuses: What to do when no plan can
be found,” in Proceedings of the 20th International Conference on
Automated Planning and Scheduling. AAAI, 2010, pp. 81–88.
[13] D. E. Smith, “Choosing objectives in over-subscription planning,”
in Proceedings of the 14th International Conference on Automated
Planning and Scheduling, 2004, p. 393401.
[14] M.vandenBriel,R.Sanchez,M.B.Do,andS.Kambhampati,“Effec-
tiveapproachesforpartialsatisfaction(over-subscription)planning,”in
Proceedings of the 19th national conference on Artiﬁcal intelligence.
AAAI Press, 2004, p. 562569.
[15] G.E.Fainekos,A.Girard,H.Kress-Gazit,andG.J.Pappas,“Temporal
logic motion planning for dynamic robots,” Automatica, vol. 45, no. 2,
pp. 343–352, Feb. 2009.
[16] A. Ulusoy, S. L. Smith, X. C. Ding, C. Belta, and D. Rus, “Op-
timal multi-robot path planning with temporal logic constraints,” in
IEEE/RSJ International Conference on Intelligent Robots and Sys-
tems,, 2011, pp. 3087 –3092.
[17] A. LaViers, M. Egerstedt, Y. Chen, and C. Belta, “Automatic gen-
eration of balletic motions,” IEEE/ACM International Conference on
Cyber-Physical Systems, vol. 0, pp. 13–21, 2011.
[18] E. Martins, M. Pascoal, D. Rasteiro, and J. Dos Santos, “The optimal
path problem,” Investigac˜ ao Operacional, vol. 19, pp. 43–60, 1999.
[19] S. M. LaValle, Planning Algorithms. Cambridge University Press,
2006. [Online]. Available: http://msl.cs.uiuc.edu/planning/
[20] K. Kim and G. Fainekos, “Revision of speciﬁcation automata under
quantitative preferences,” Cornell University Library arXiv.org, Tech.
Rep., 2014.
[21] LTL2BA modiﬁcation. [Online]. Available: https://www.assembla.
com/code/ltl2ba cpslab/git/nodes
[22] A. Ulusoy, S. L. Smith, X. C. Ding, and C. Belta, “Robust multi-robot
optimal path planning with temporal logic constraints,” in 2012 IEEE
International Conference on Robotics and Automation (ICRA), 2012.
[23] G. E. Fainekos, “Revising temporal logic speciﬁcations for motion
planning,” in Proceedings of the IEEE Conference on Robotics and
Automation, May 2011.
[24] L. Bobadilla, O. Sanchez, J. Czarnowski, K. Gossman, and S. LaValle,
“Controlling wild bodies using linear temporal logic,” in Proceedings
of Robotics: Science and Systems, Los Angeles, CA, USA, June 2011.
[25] E. M. Wolff, U. Topcu, and R. M. Murray, “Automaton-guided
controller synthesis for nonlinear systems with temporal logic,” in
International Conference on Intelligent Robots and Systems, 2013.
5344
