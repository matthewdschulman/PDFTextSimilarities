Polygon Guarding with Orientation
Pratap Tokekar and V olkan Isler
Abstract— The art gallery problem is a classical sensor
placement problem that asks for the minimum number of
guards required to see every point in an environment. The
standard formulation does not take into account self-occlusions
caused by a person or an object within the environment.
Obtaining good views of an object from all orientations is
important for surveillance and visual tracking applications. We
study the art gallery problem under a constraint, termed ?-
guarding, that ensures that all sides of any convex object are
always visible in spite of self-occlusion.
Our contributions in this paper are two-fold: we ﬁrst prove
that Ω(
√
n) guards are always necessary for ?-guarding the
interior of a simple polygon having n vertices. Next, we study
the problem of ?-guarding a set of line segments connecting
points on the boundary of the polygon. This is motivated by
applications where an object or person of interest can only move
along certain paths in the polygon. We present a constant factor
approximation algorithm for this problem – one of the few such
results for art gallery problems.
I. INTRODUCTION
Consider the basic task of placing cameras in an environ-
ment in order to ensure that every point in the environment
is seen from at least one camera. By carefully choosing
their locations, the total number of cameras required can be
minimized. This is known as the art gallery problem, and has
been the area of active research for over three decades [1].
The art gallery problem asks for the minimum number of
cameras required to see all points in an n–sided polygon.
Various bounds have been established on the minimum
number of guards required for different classes of poly-
gons [1], [2]. In particular,?n/3? guards are always sufﬁcient
and sometimes necessary for guarding an n–sided simple
polygon without holes.
O’Rourke and Supowit [3] proved that the problem of
determining the minimum number of guards required to
cover a given polygon is NP-hard. Efrat and Har-Peled [4]
presented a polynomial time algorithm to guard a polygon
using at mostO(OPTlog OPT) guards, where OPT is the
optimal number of guards. Nilsson [5] presented a constant
factor approximation algorithm to guard the interior of
any monotone polygon. No constant factor approximation
algorithm for guarding general polygons is known.
The classical art gallery problem only requires that each
point in the environment to be visible from a camera. How-
ever, for many applications visibility along is not sufﬁcient.
Obtaining a good view is equally important. For example,
The authors are with the Department of Computer Science and
Engineering, University of Minnesota, Minneapolis, MN, USA.
{tokekar,isler}@cs.umn.edu.
This material is based upon work supported by the National Science
Foundation under Grant Nos. 1317788 and 0917676.
consider a video conferencing system where a person can
move within a conference room. If the room is convex, then
a single camera is sufﬁcient to guarantee visibility (Figure 1).
However, if the person stands with his or her back to the only
camera, no good view of the person will be available. Our
goal will be to place cameras such that any person or object
will be seen from all orientations, in spite of self-occlusion.
Fig. 1. The standard polygon guarding problem ensures that every point
in the environment is seen from at least one guard. However, due to self-
occlusions, some part of a person may not be visible. We study the polygon
guarding problem in the presence of self-occlusions.
We use this as motivation to study the problem of placing
the minimum number of cameras in order to see all faces
of any convex object moving in the environment. Smith and
Evans [6] introduced this problem, and formalized it as the
following?-guarding condition:
Deﬁnition 1 A point p is said to be?-guarded by a set
of guards G, if p is visible from a non-empty set of guards
G
?
? G andp lies in the convex hull ofG
?
. A simple polygon
P is said to be?-guarded by a set of guards G, if every
point p? P is?-guarded by G.
Note that the guards themselves need not be visible from
each other.
Smith and Evans [6] proved that deciding if k vertex
guards can ?-guard a simple polygon is NP-hard. Efrat
et al. [7] presented a randomized algorithm based on
[8] that when applied to the ?-guarding problem yields
a O(log OPT)–approximation for polygons without holes.
Since the?-guarding constraint generalizes the simple vis-
ibility requirement for the art gallery problem, we expect to
place more cameras. In this paper, our ﬁrst contribution is to
show that Ω(
√
n) guards are always necessary to?-guard
any simple polygon with n vertices (with or without holes).
The large lower bound comes as a result of having to
?-guard the entire polygon. In many applications such as
surveillance or mobile video conferencing, we may not need
to ?-guard the entire polygon. Instead, ?-guarding may
be required only for a set of paths a person or object
of interest is likely to take within the environment. With
this as motivation, we study the problem of placing the
fewest number of guards to?-guard a set of line segments
2014 IEEE International Conference on Robotics & Automation (ICRA)
Hong Kong Convention and Exhibition Center
May 31 - June 7, 2014. Hong Kong, China
978-1-4799-3684-7/14/$31.00 ©2014 IEEE 1014
between points on the boundary of a polygon. For example,
these points can correspond to entry and exit points in the
environment, the line segments being paths likely to be taken
by a person. Our goal is to?-guard at least one point on
each line segment, thus guaranteeing that independent of the
orientation, all sides of the person will be seen at some
point along the path. Our second contribution is to present
an approximation algorithm that places at most 12 times as
many guards as an optimal algorithm. In addition to being of
practical interest, our result is one of the few constant factor
approximation algorithms for an art gallery problem.
II. LOWER BOUND ON THE NUMBER OF GUARDS FOR
?-GUARDING A SIMPLE POLYGON
In this section, we prove a lower bound on the number
of guards necessary to?-guard any simple polygon P . The
deﬁnition of?-guarding allows the degenerate cases of a
point being?-guarded by two visible guards if it lies on the
segment joining them. The next statement follows from the
deﬁnition of?-guarding and will be useful in the analysis.
Corollary 1 A pointp is?-guarded if and only if any closed
half-plane drawn with the line passing through p contains a
guard visible from p.
For establishing the lower bound, we will prove necessary
conditions on where the guards must be placed. We ﬁrst
deﬁne an edge extension as follows. Extend an edge of P
from either endpoint until it reaches the boundary of the
polygon. Each of the (closed) line segments lying on either
side of the edge is termed as an edge extension. An edge
introduces as many edge extensions as the number of its
reﬂex endpoints. As a matter of convention, we will refer to
a vertex on a hole as a convex vertex if the angle formed by
the two adjacent sides containing the interior of the polygon
is smaller than
π
2
. Else, we refer to the vertex as a reﬂex
vertex.
Lemma 1 Let G be a set of guards that?-guards a simple
polygon P . If v is a convex vertex in P (lying on the exterior
or hole boundary), then v? G. If e is any edge extension in
P , then there exists a guard in G that lies on e.
The proof is presented in the accompanying technical
report [9]. Using Lemma 1, we can prove the lower bound
on the number of guards of any?-guarding set of P .
Theorem 1 (Lower Bound) If a set of guardsG,?-guards
a simple polygon having n vertices, then|G| = Ω(
√
n).
Proof: Let the total number of convex and reﬂex
vertices in P be n
c
and n
r
, respectively. We have two cases,
n
c
≥ n/4 or n
c
< n/4. First consider, n
c
≥ n/4. From
Lemma 1 we know |G| ≥ n
c
. Hence, |G| ≥ n/4 and
consequently|G| = Ω(
√
n).
Now consider, n
c
< n/4. That is, n
r
≥ 3n/4. Each
edge in P may introduce up to two unique edge extensions.
Consider the set of edge extensions due to edges whose
endpoints are both reﬂex vertices. Let m be the total number
of such edge extensions. We know, m≥ 2(n
r
?n
c
)≥ n.
From Lemma 1, we know each of thesem extensions must
have a guard placed on them. The optimal algorithm may be
able to use the same guard if two or more extensions intersect
at a point. Let k be the maximum number of extensions that
intersect in one point. To cover m extensions, any algorithm
will require at least m/k guards. Hence,|G|≥ m/k.
Now consider the polygon edges that contributed to the k
extensions which intersect at a point. Since we are focusing
only on edges with reﬂex vertices on both ends, each such
edge must have introduced another extension, contributing
anotherk extensions. Since the two extensions resulting from
a polygon edge are colinear, any guarding set will be forced
to use a separate guard for covering each of the other k
extensions. Hence,|G|≥ k.
Multiplying the two lower bounds, we get|G|
2
≥ m or
|G|≥
√
m. Since m≥ n, the theorem statement follows.
The bound is tight for polygon with holes. Figure 2 shows an
instance where the?-guarding has sizeO(
√
n). The bound
may not be tight for polygons without holes.
Fig. 2. Polygon P consists of k? k holes aligned along a grid. The
outer boundary of the polygon forms a square. The number of vertices of
P are n = 4k
2
+4.O(k) =O(
√
n) guards (marked by small squares)
are sufﬁcient for?-guarding P .
The lower bound shows that the number of guards required
to?-guard the complete interior is always high. This results
from having to guard each convex vertex and edge extension,
which may not be important for many applications. As
described in the introduction, we will restrict our attention
to?-guarding only a set of line segments joining points on
the boundary of a simply-connected polygon.
III. ?-GUARDING CHORDS
Let P be a simply-connected polygon. A chord in P is
any line segment which joins two mutually visible points
that lie on the boundary of P . A diagonal is special type of
chord where both points are vertices of P .
Deﬁnition 2 A chord is said to be?-guarded by a set of
guards G, if there exists at least one point on the chord?-
guarded by G.
The chord?-guarding problem is deﬁned as: Given a set
of chordsC in a simply-connected polygon, ﬁnd the minimum
set of guards to?-guard every chord in C.
The above deﬁnition uses the notion of?-guarding at least
one point per chord. For the problem of?-guarding every
point on the chord, one can construct an instance where
the set of input chords ﬁll the entire polygon. Thus, the
problem becomes at least as hard as?-guarding the entire
polygon. Hence, we need Ω(
√
n) guards in the worst-case.
The algorithm from [7] can be applied to obtain a log factor
1015
approximation for?-guarding every point on a set of chords.
We focus on?-guarding at least one point per chord, and
present a constant factor approximation algorithm.
Our main result for this problem is as follows.
Theorem 2 (Chord Guarding) Given a set of chords C in
a simply-connected polygon P , there exists an algorithm
which ﬁnds a set of guards G ?-guarding C, such that
|G| ≤ 12k
?
where k
?
is the minimum number of guards
required to?-guard C.
A. Terminology and notation
We label the points on the boundary of P in the clockwise
order, starting from an arbitrarily chosen vertex. If a point
p on the boundary appears before point q in the clockwise
ordering, then we denote this by p ? q. For each chord
C
i
, we term the endpoint that appears ﬁrst in the clockwise
ordering along the boundary as its start point (s
i
) and the
other endpoint as the terminal point (t
i
). Thus, s
i
? t
i
.
We map all s
i
and t
i
to a circle maintaining their clock-
wise ordering (Figure 3). The part of the boundary of P
from s
i
to t
i
along the clockwise order maps to an arc on
the circle; we term this as the induced arc (A
i
). The chord
also divides the polygon into two subpolygons. We term the
subpolygon corresponding to the induced arc as the induced
subpolygon, denoted by P
i
. P
i
is made up of the boundary
of P between s
i
and t
i
and the edge t
i
s
i
.
s
4
v
1
s
1
s
3
s
2
s
5
t
1
t
3
t
4
t
2
t
5
s
1
t
1
s
2
s
3
s
4
t
3
t
4
t
2
s
5
t
5
A
1
A
2
A
3
A
4
A
5
P
3
Fig. 3. The endpoints of all chords map to a circle in clockwise order. The
corresponding arc is termed as the induced arc A
i
. P
i
is the subpolygon
induced by C
i
.
The set of all arcs induced by C creates a circular-arc
graph [10], with arcs as vertices, and an edge between two
vertices if the corresponding arcs overlap. The maximum
independent set (MIS) of this graph is the largest set of dis-
joint arcs. Masuda and Nakajima [10] presented an optimal
algorithm for ﬁnding the MIS of circular-arc graphs.
We use the following distinction for non-disjoint arcs: A
i
andA
j
withA
i
?A
j
6=? are termed cutting arcs, ifA
i
6? A
j
and A
j
6? A
i
. A
i
and A
j
are said to cut each other.
We will refer to a chord, its induced arc, and the corre-
sponding vertex in the circular-arc graph, interchangeably.
Next, we present a high level discussion of our strategy for
placing guards.
B. Strategy for guard placement
Given the MIS of the circular-arc graph, we classify each
chord in C into four types. A chord C
i
is of
• Type I if A
i
is in the MIS,
• Type II if A
i
cuts some arc in the MIS,
• Type III if A
i
contains some arc in the MIS,
• Type IV if A
i
is contained in some arc in the MIS.
First in Section IV-A, we describe the placement of a guard
set?-guarding chords of Types I & II. In Section IV-B,
we will?-guard a subset of Type III guards. Finally, in
Section IV-C we describe an algorithm for?-guarding the
remaining set of guards of Type III and Type IV chords.
We will show that the total number of guards placed by
our algorithm is at most a constant times that of an optimal
algorithm. We will use the following two useful properties
speciﬁc to the?-guarding chords that will allow us to obtain
a constant factor approximation.
Lemma 2 Two chords C
i
and C
j
intersect if and only if
their corresponding arcs A
i
and A
j
cut each other.
The proof, which veriﬁes the ordering ofs
i
,s
j
,t
i
,t
j
for both
directions, is presented in the technical report [9].
Lemma 3 If chord C
i
is ?-guarded by a set of guards
G, then at least one guard in G must lie in its induced
subpolygon P
i
.
Proof: Let p be a point on C
i
that is?-guarded by G.
Consider the line containing chord C
i
which passes through
p. This line creates two closed half-planes one of which
contains all points from P
i
visible from p. From Corollary 1,
we know this closed half-plane must contain a guard visible
from p. Since no point in this half-plane outside of P
i
lies
within the polygon, this guard must be contained in P
i
.
We term such a guard as the cardinal guard of C
i
. We
will charge a constant number of guards in our placement to
a cardinal guard in the optimal placement.
IV. PLACING GUARDS TO?-GUARD CHORDS
In this section, we describe our guard placement scheme in
detail. We will ﬁrst establish a lower bound on the minimum
number of guards necessary to?-guard C, using the MIS
of the circular arc graph.
A. Guarding Type I and II chords
Lemma 4 If M is the MIS of disjoint arcs in the circular-
arc graph, then|M|≤ k
?
, where k
?
is minimum number of
guards for?-guarding C.
Proof: Since all arcs in the MIS are disjoint, their
induced subpolygons are disjoint. That is, for any two arcs
A
i
,A
j
? M we have P
i
? P
j
=?. From Lemma 3, we
know each chord must have at least one guard in its induced
subpolygons. Since the subpolygons for all chords in the
MIS are disjoint, no two chords may share a cardinal guard.
Hence, there are at least as many cardinal guards as the
number of disjoint subpolygons. Therefore,|M|≥ k
?
.
We now describe set S
1
guarding chords of Types I & II.
Lemma 5 If S
1
is the set of endpoints of chords in M, then
S
1
?-guards all chords of Types I & II, and|S
1
|≤ 2k
?
.
1016
Proof: First consider Type I chords. Since we place a
guard at both endpoints of each such chord, all points lying
on a Type I chord are?-guarded. Let C
i
by a Type II chord
whose arc cuts an arc of C
j
, a Type I chord. According to
Lemma 2, C
i
and C
j
must intersect in a point. Since all
points on C
j
are?-guarded, C
i
is?-guarded. Hence, all
Type II chords are?-guarded.
B. Guarding a subset of Type III chords
Now consider chords of Type III. We call the portion of
the circle between two consecutive arcs in the MIS gaps.
Type III chords have both endpoints in a gap, and the start
and terminal endpoints must lie in different gaps. Each gap
may contain multiple start and terminal points. Since there
are as many gaps as arcs in the MIS, from Lemma 4, we
may place a constant number of guards per gap and perform
comparable to an optimal algorithm.
A
2
A
3
A
4
A
5
A
1
Fig. 4. Type III chords. The arcs in MIS are shown dotted, gaps are marked
shaded. In each gap, we place guards (marked square) on the endpoints of
chords with earliest start point or latest terminal point. Chords with arcs
A
1
,...,A
4
may not be?-guarded by this set of guards, where as A
5
is.
We will place at most four guards per gap in a guard set
S
2
as follows (Figure 4):
• on the two endpoints of the Type III chord with the ﬁrst
start point within each gap (if any), and
• on the two endpoints of the Type III chord with the last
terminal point within each gap (if any).
Lemma 6 If C
i
and C
j
are any two Type III chords not?-
guarded by S
2
, then either A
i
and A
j
are non-cutting arcs
or both chords start from the same gap and end in the same
gap.|S
2
|≤ 4k
?
, where k
?
is the optimal number of guards
for?-guarding C.
Proof: There are as many gaps as the number of arcs
in the MIS. We place at most four guards per gap. Using
Lemma 4,|S
2
|≤ 4k
?
.
We will prove the contrapositive of the statement of the
lemma. If A
i
and A
j
are cutting arcs with either their start
or terminal points in different gaps, then C
i
and C
j
are?-
guarded byS
2
. We will prove the case when their start points
lie in different gaps. The case for the terminal points of C
i
and C
j
lying in different gaps is symmetric.
Without loss of generality, let s
i
? s
j
. For contradiction,
assume that C
i
and C
j
are not?-guarded by S
2
.
Consider the gap containings
j
. We know this gap contains
at least one start point of a Type III chord, i.e., s
j
. If s
j
is the earliest start point in this gap, then S
2
contains two
guards placed on either endpoints of C
j
and hence, C
j
must
be?-guarded, which is a contradiction. Thus, there exists
some other start point in the same gap before s
j
, say s
k
corresponding to a Type III chord C
k
.
s
k t
k
s
j
s
i
t
j
s
k
t
k
s
j
s
i
t
j
Fig. 5. Illustration of the proof for Lemma 6. C
i
and C
j
start in different
gaps. At least one of C
i
or C
j
cuts a chord with guards placed on two
endpoints, C
k
.
For the terminal point of C
k
, we have two possibilities
(See Figure 5)
1) t
k
? t
j
. We know s
k
? s
j
. t
k
and t
j
do not lie
in the same gap as s
k
and s
j
respectively. Thus we
get, s
k
? s
j
? t
k
? t
j
. Therefore, A
k
cuts A
j
.
From Lemma 2, C
k
must intersect with C
j
. Since
we have guards placed on both endpoints of C
k
, all
points on C
k
are?-guarded including C
j
’s point of
intersection with C
k
. Hence, C
j
is?-guarded, which
is a contradiction.
2) t
j
? t
k
. Since C
i
and C
j
are cutting arcs and s
i
? s
j
,
we get t
i
? t
j
. Therefore t
i
? t
k
. Since s
i
lies in
a gap before the one that contains s
j
and s
k
, we get
s
i
? s
k
? t
i
? t
k
. Hence, the arcs of C
i
and C
k
cut
each other. Following the similar argument, C
i
must
be?-guarded, which is a contradiction.
Lemmas 5 and 6 present guard placement of size at most
6k
?
covering all Type I, II and a subset of III chords in
C. We now describe the placement of another guard set to
?-guard all remaining chords in C.
C. Guarding remaining Type III and IV chords
Let C
?
? C be the set of chords not?-guarded by guard
sets S
1
and S
2
described in Section IV-A. C
?
consists of a
subset of Type III chords given by Lemma 6, and all Type
IV guards. Lemma 6 states that if C
i
,C
j
? C
?
cut each
other, then they must start and terminate in the same gap.
We will deﬁne an equivalence class of all Type III chords
that start and terminate in the same gap. Similarly, we will
deﬁne another equivalence class of Type IV chords that are
contained in the same arc in the MIS. We term each such
class as a group. Thus two chords in C
?
lie in the same
group if they start and terminate in the same gap, or if they
are contained within the same arc in the MIS.
While the chords within each group may cut each other,
we show that chords in distinct groups do not.
Lemma 7 If C
m
? G
i
and C
n
? G
j
are two chords in
distinct groups, then A
m
and A
n
do not cut each other.
The full proof, presented in [9], veriﬁes all the cases and
shows that the arcs cannot cut each other. Hence, two groups
are either disjoint or one completely contains the other.
This gives a partial ordering on all groups based on
inclusion. We use this to create a tree of chordsT :
1017
1) Re-index all chords inT , such that for any C
i
and C
j
if s
i
? s
j
then i < j. That is, if a chord starts before
another, then it has a lower index than the other.
2) The circumference of the circle forms the root.
3) First create a tree of groups. Iteratively add all groups
as nodes in the tree using the rule: group G
j
is an
ancestor of G
i
if and only if the induced arc of G
i
is
completely contained in G
j
.
4) Replace each group node G
i
with a chain of chord
nodes, one node per chord in the group. The chord
with a lower index is at a lower depth in this chain.
The subtree rooted at G
i
is attached to the chord node
with the highest index, and the parent ofG
i
is attached
to the chord node with the lowest index.
In the following lemmas, we will prove useful properties
of T which will form the basis of our guard placement
algorithm. Denote the shortest path from any node C
k
towards the root by ?(C
k
). We show the start points of
chords lying on the same path follow in order of the path.
Furthermore, no chord which is an ancestor of C
k
in ?(C
k
)
terminates before C
k
starts.
Lemma 8 If C
m
is the ancestor of C
n
then s
m
 s
n
and
s
n
 t
m
.
Proof: First let C
m
and C
n
belong to the same group.
By construction, s
m
 s
n
. Furthermore, if both are Type III
chords, thens
m
ands
n
must lie in the same gap which comes
before the gap containing t
m
and t
n
. Therefore, s
n
? t
m
.
Similarly, if both are Type IV chords, then if t
m
? s
n
then
A
m
andA
n
are disjoint leading to a contradiction about them
being contained in the same arc in the MIS. Hence, if C
m
and C
n
belong to the same group then the lemma follows.
Next, let C
m
and C
n
belong to different groups. Since
C
m
is an ancestor of C
n
, we know that the group containing
C
m
completely contains the group containing C
n
(Steps (3)
and (4) of the construction ofT ). Therefore, A
m
completely
contains A
n
implying s
m
? s
n
? t
n
? t
m
.
We now place guards to?-guard chords in the ordered
treeT . By construction, all leaf nodes inT have disjoint
induced subpolygons. Furthermore, only guards along the
same path to the root may share a cardinal guard. Hence,
any guard set must contain at least as many cardinal guards
as the number of paths from leaf nodes to the root. However,
this lower bound is not sufﬁcient to obtain a constant
factor approximation directly. There are instances where the
number of guards necessary to?-guard a path can vary from
as few as two to as many as the number of chords along the
path. In addition, two or more paths may merge and thus be
able to share guards. Nevertheless, we show that the greedy
approach in Algorithm 1 correctly?-guards all chords inT
using at most a constant times the number of guards in an
optimal guard set (Lemma 11).
The algorithm uses the ordering property presented in
Lemma 8. Initially all chords are marked as not being?-
guarded. At the start of each iteration (Step 4), we pick a
chord C
k
with the highest depth not yet marked?-guarded.
All descendants of C
k
have been ?-guarded in previous
iterations. We will place a cardinal guard x? P
k
for C
k
.
We will choose its location to be such that it sees a point
on the chord with the lowest depth which lies on C
k
’s path
to the root. All intermediate chords are marked?-guarded
using at most six guards as given in Step 6. The following
lemma proves the correctness of this intermediate step.
Algorithm 1: TreeGuarding
Input:T Ordered tree of chords in C
?
Output: S
3
guard set?-guarding C
?
1 S
3
??
2 mark all chords inT as not?-guarded
3 while? a chord inT is not marked?-guarded do
4 k? largest index such that C
k
is not?-guarded
5 i? smallest index such that some point
y? C
i
? ?(C
k
) is visible from a point x? P
k
6 S
3
? S
3
?{x,y,s
k
,t
k
,s
i
,t
i
}
7 mark all C
j
? ?(C
k
) with i≤ j≤ k as?-guarded
8 end
9 return guarding set S
3
Lemma 9 If a point x? P
k
sees a point y? C
i
such that
C
i
is the ancestor of C
k
, then{x,y,s
k
,t
k
,s
i
,t
i
}?-guard
all chords on the path from C
k
to C
i
.
Proof: First observe that C
i
and C
k
are?-guarded by
guards on their endpoints. Let C
j
be any chord on the path
from C
k
to C
i
. If either endpoint of C
j
is shared with that
of C
i
or C
k
, then C
j
is?-guarded.
Otherwise, we have C
j
lying on the path from C
k
to C
i
,
i < l < k. By the ordering property (Lemma 8), s
i
? s
j
?
s
k
. We have two cases:
(1) t
i
 t
k
. From Lemma 8, we get the ordering s
i
?
s
j
? s
k
 t
i
 t
k
. Also from Lemma 8,C
j
cannot terminate
befores
k
sinceC
k
is a descendant ofC
j
. Therefore,C
j
must
intersect at least one of C
i
and C
k
and thus be?-guarded
by the guards placed on the endpoints of C
i
and C
k
.
Fig. 6. One iteration of Algorithm 1 (Steps 4–7). The guards are placed
at locations marked by a square. Any chord with a starting vertex lying in
between s
i
and s
k
is?-guarded.
(2) t
k
? t
i
. We have three cases: (a) t
k
? t
j
? t
i
, (b)
t
j
? t
k
, or (c) t
i
? t
j
. Recall that s
i
? s
j
? s
k
. Hence for
(b) and (c), C
j
intersects with either C
k
or C
i
, respectively.
Hence,C
j
will be?-guarded by the guards on the endpoints
of C
k
and C
i
.
1018
Consider case (a) (Figure 6). We have P
k
? P
j
? P
i
.
x? P
k
sees a point y? C
i
. Extend the segment from y to
x till it hits the boundary of P
k
at point z. Segment zy is a
chord in P
i
. Since z? P
j
, let y
?
be the point of intersection
of segment zy (other than z) with the boundary of P
j
. y
?
may either lie on the edge C
j
of P
j
or on the part of the
boundary of P from s
j
to t
j
. However, the latter is also a
part of the boundary of P
i
– in fact, the part of the boundary
of P
i
which does not contain the edge C
i
. This leads to the
contradiction that a chord zy intersects the boundary of P
i
at three distinct points, z, y and y
?
. Hence, y
?
must lie on
C
j
which implies y
?
is visible from the guards at x and z.
Thus, C
j
is?-guarded.
The correctness of the algorithm follows from the correctness
of the intermediate step.
Corollary 2 All chords inT are?-guarded by Algorithm 1.
Now we show that the size of S
3
is only a constant times
that of any optimal guarding set. Consider an optimal guard
set G
?
covering C
?
. For each guard in G
?
, we create a new
set of all chords for which the guard acts as a cardinal guard.
That is, for any g? G
?
we create the set{C
i
|C
i
? C
?
,g?
P
i
}. Denote this collection of sets byC
?
.
We now create another collection of sets, denotedC, for
Algorithm 1. For each iteration of the algorithm, we create a
new set that contains all chords marked?-guarded in Step 7.
That is, create the setC
k
={C
j
|i≤ j≤ k} and add it toC.
The largest index of chords contained in this set corresponds
to the largest unmarked index (i.e. k) found in Step 4.
Lemma 10 If k and k
?
are the largest indices in distinct
setsC
k
andC
k
? inC respectively, then k6= k
?
and no set in
C
?
contains both C
k
and C
k
?.
Proof: Consider any iteration of Algorithm 1 and the
corresponding set inC. If k was the largest unmarked index
in Step 4, then it is not included in the sets inC from previous
iterations. Furthermore, all descendants of k are marked
?-guarded. All chords in the current iteration marked?-
guarded have index smaller than k. Hence, if k and k
?
are
the largest indices in two distinct sets ofC then k6= k
?
.
Now we show that C
k
and C
k
? cannot appear in the same
set inC
?
. Suppose they do. We have two possibilities: C
k
and C
k
? lie on the same or different paths to the root. If C
k
and C
k
? lie on different paths to the root, then their induced
subpolygons P
k
and P
k
? are disjoint. Hence, their cardinal
guards cannot be the same, implying C
k
? and C
k
? cannot be
in the same set inC
?
.
Then C
k
? and C
k
? must lie on the same path. Assume
without loss of generality, k < k
?
. Since k and k
?
lie in the
same set inC
?
, they must share the same cardinal guard, say
g? P
k
?. Furthermore, g also sees a point on C
k
. Therefore,
C
k
will be marked?-guarded and included inC
k
? according
to Step 7. However, C
k
cannot be included in some other
setC
k
??C, which gives a contradiction.
Lemma 11 If S
3
is the guarding set obtained in Algo-
rithm 1, and k
?
is the optimal number of guards for?-
guarding C
?
, then|S
3
|≤ 6k
?
.
Proof: Since we place at most six guards per iteration,
|S
3
|≤ 6|C|. We know|C
?
| = k
?
. If we show|C|≤|C
?
|, we
are done. Suppose|C| >|C
?
|. Using Lemma 10 this implies
there is some chord C
i
not contained in any set inC
?
such
that i is the largest index of some set inC. This implies
no guard in the optimal guard set acts as the cardinal guard
for C
i
. From Lemma 3 this implies C
i
is not?-guarded,
which is a contradiction. Thus,|C|≤|C
?
|, which proves the
statement of the lemma.
From Lemmas 5, 6, and 11, the guard sets S
1
,S
2
and S
3
?-guard all input chords using at most 12 times as many
guards as an optimal algorithm.
V. CONCLUSION
In this paper, we studied the problem of guarding a poly-
gon under the?-guarding constraint [6]. The?-guarding
constraint is motivated by practical surveillance scenarios
where the goal is to see all sides of a person despite
self-occlusion. We showed that Ω(
√
n) guards are always
necessary to?-guard any simple n–sided polygon. Since
the required number of guards to cover the entire polygon
is large, we turned our attention to a scenario in which we
are given entry and exit points to the environment connected
by straight-line paths, i.e., chords. The goal is to?-guard
at least one point on each chord. We presented an approxi-
mation algorithm for simply-connected polygons which uses
at most 12 times the optimal number of guards. In addition
to solving a practical problem, our result is of theoretical
interest because this is one of the few instances where a
constant factor approximation algorithm for an art gallery
problem is known. Our future work includes extending the
result to arbitrary paths as well as polygons with obstacles.
REFERENCES
[1] J. O’Rourke, Art gallery theorems and algorithms. Oxford University
Press Oxford, 1987, vol. 1092.
[2] J. Urrutia, “Art gallery and illumination problems,” Handbook of
Computational Geometry, pp. 973–1027, 2000.
[3] J. O’Rourke and K. Supowit, “Some NP-hard polygon decomposition
problems,” IEEE Transactions on Information Theory, vol. 29, no. 2,
pp. 181–190, 1983.
[4] A. Efrat and S. Har-Peled, “Guarding galleries and terrains,” Informa-
tion Processing Letters, vol. 100, no. 6, pp. 238–245, 2006.
[5] B. J. Nilsson, “Approximate guarding of monotone and rectilinear
polygons,” in Automata, Languages and Programming. Springer,
2005, pp. 1362–1373.
[6] J. Smith and W. S. Evans, “Triangle guarding.” in Canadian Confer-
ence on Computational Geometry, 2003, pp. 76–80.
[7] A. Efrat, S. Har-Peled, and J. S. Mitchell, “Approximation algorithms
for two optimal location problems in sensor networks,” in 2nd Inter-
national Conference on Broadband Networks, 2005, pp. 714–723.
[8] H. Br¨ onnimann and M. T. Goodrich, “Almost optimal set covers in
ﬁnite VC-dimension,” Discrete & Computational Geometry, vol. 14,
no. 1, pp. 463–479, 1995.
[9] P. Tokekar and V . Isler, “Polygon guarding with orientation,” Depart-
ment of Computer Science & Engineering, University of Minnesota,
Tech. Rep. 14-001, January 2014, http://www.cs.umn.edu/research/
technical reports/view/14-001.
[10] S. Masuda and K. Nakajima, “An optimal algorithm for ﬁnding a
maximum independent set of a circular-arc graph,” SIAM Journal on
Computing, vol. 17, no. 1, pp. 41–52, 1988.
1019
